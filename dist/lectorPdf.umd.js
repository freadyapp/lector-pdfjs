(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('canvas'), require('fs'), require('zlib'), require('http'), require('https'), require('url')) :
	typeof define === 'function' && define.amd ? define(['exports', 'canvas', 'fs', 'zlib', 'http', 'https', 'url'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.lectorPdf = {}, global.require$$0, global.require$$1, global.require$$2, global.require$$3, global.require$$4, global.require$$5));
}(this, (function (exports, require$$0, require$$1, require$$2, require$$3, require$$4, require$$5) { 'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
	var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
	var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
	var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);
	var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
	var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule$1(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	function commonjsRequire (target) {
		throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
	}

	/**
	 * @licstart The following is the entire license notice for the
	 * Javascript code in this page
	 *
	 * Copyright 2021 Mozilla Foundation
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @licend The above is the entire license notice for the
	 * Javascript code in this page
	 */

	var pdf = createCommonjsModule$1(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
		module.exports = factory();
	})(commonjsGlobal, function() {
	return /******/ (() => { // webpackBootstrap
	/******/ 	var __webpack_modules__ = ([
	/* 0 */,
	/* 1 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.addLinkAttributes = addLinkAttributes;
	exports.deprecated = deprecated;
	exports.getFilenameFromUrl = getFilenameFromUrl;
	exports.isFetchSupported = isFetchSupported;
	exports.isPdfFile = isPdfFile;
	exports.isValidFetchUrl = isValidFetchUrl;
	exports.loadScript = loadScript;
	exports.StatTimer = exports.RenderingCancelledException = exports.PDFDateString = exports.PageViewport = exports.LinkTarget = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.BaseCMapReaderFactory = exports.BaseCanvasFactory = void 0;

	var _util = __w_pdfjs_require__(2);

	const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
	exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
	const SVG_NS = "http://www.w3.org/2000/svg";

	class BaseCanvasFactory {
	  constructor() {
	    if (this.constructor === BaseCanvasFactory) {
	      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
	    }
	  }

	  create(width, height) {
	    (0, _util.unreachable)("Abstract method `create` called.");
	  }

	  reset(canvasAndContext, width, height) {
	    if (!canvasAndContext.canvas) {
	      throw new Error("Canvas is not specified");
	    }

	    if (width <= 0 || height <= 0) {
	      throw new Error("Invalid canvas size");
	    }

	    canvasAndContext.canvas.width = width;
	    canvasAndContext.canvas.height = height;
	  }

	  destroy(canvasAndContext) {
	    if (!canvasAndContext.canvas) {
	      throw new Error("Canvas is not specified");
	    }

	    canvasAndContext.canvas.width = 0;
	    canvasAndContext.canvas.height = 0;
	    canvasAndContext.canvas = null;
	    canvasAndContext.context = null;
	  }

	}

	exports.BaseCanvasFactory = BaseCanvasFactory;

	class DOMCanvasFactory extends BaseCanvasFactory {
	  constructor({
	    ownerDocument = globalThis.document
	  } = {}) {
	    super();
	    this._document = ownerDocument;
	  }

	  create(width, height) {
	    if (width <= 0 || height <= 0) {
	      throw new Error("Invalid canvas size");
	    }

	    const canvas = this._document.createElement("canvas");

	    const context = canvas.getContext("2d");
	    canvas.width = width;
	    canvas.height = height;
	    return {
	      canvas,
	      context
	    };
	  }

	}

	exports.DOMCanvasFactory = DOMCanvasFactory;

	class BaseCMapReaderFactory {
	  constructor({
	    baseUrl = null,
	    isCompressed = false
	  }) {
	    if (this.constructor === BaseCMapReaderFactory) {
	      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
	    }

	    this.baseUrl = baseUrl;
	    this.isCompressed = isCompressed;
	  }

	  async fetch({
	    name
	  }) {
	    if (!this.baseUrl) {
	      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
	    }

	    if (!name) {
	      throw new Error("CMap name must be specified.");
	    }

	    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
	    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
	    return this._fetchData(url, compressionType).catch(reason => {
	      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
	    });
	  }

	  _fetchData(url, compressionType) {
	    (0, _util.unreachable)("Abstract method `_fetchData` called.");
	  }

	}

	exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

	class DOMCMapReaderFactory extends BaseCMapReaderFactory {
	  _fetchData(url, compressionType) {
	    if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {
	      return fetch(url).then(async response => {
	        if (!response.ok) {
	          throw new Error(response.statusText);
	        }

	        let cMapData;

	        if (this.isCompressed) {
	          cMapData = new Uint8Array(await response.arrayBuffer());
	        } else {
	          cMapData = (0, _util.stringToBytes)(await response.text());
	        }

	        return {
	          cMapData,
	          compressionType
	        };
	      });
	    }

	    return new Promise((resolve, reject) => {
	      const request = new XMLHttpRequest();
	      request.open("GET", url, true);

	      if (this.isCompressed) {
	        request.responseType = "arraybuffer";
	      }

	      request.onreadystatechange = () => {
	        if (request.readyState !== XMLHttpRequest.DONE) {
	          return;
	        }

	        if (request.status === 200 || request.status === 0) {
	          let cMapData;

	          if (this.isCompressed && request.response) {
	            cMapData = new Uint8Array(request.response);
	          } else if (!this.isCompressed && request.responseText) {
	            cMapData = (0, _util.stringToBytes)(request.responseText);
	          }

	          if (cMapData) {
	            resolve({
	              cMapData,
	              compressionType
	            });
	            return;
	          }
	        }

	        reject(new Error(request.statusText));
	      };

	      request.send(null);
	    });
	  }

	}

	exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

	class DOMSVGFactory {
	  create(width, height) {
	    (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
	    const svg = document.createElementNS(SVG_NS, "svg:svg");
	    svg.setAttribute("version", "1.1");
	    svg.setAttribute("width", width + "px");
	    svg.setAttribute("height", height + "px");
	    svg.setAttribute("preserveAspectRatio", "none");
	    svg.setAttribute("viewBox", "0 0 " + width + " " + height);
	    return svg;
	  }

	  createElement(type) {
	    (0, _util.assert)(typeof type === "string", "Invalid SVG element type");
	    return document.createElementNS(SVG_NS, type);
	  }

	}

	exports.DOMSVGFactory = DOMSVGFactory;

	class PageViewport {
	  constructor({
	    viewBox,
	    scale,
	    rotation,
	    offsetX = 0,
	    offsetY = 0,
	    dontFlip = false
	  }) {
	    this.viewBox = viewBox;
	    this.scale = scale;
	    this.rotation = rotation;
	    this.offsetX = offsetX;
	    this.offsetY = offsetY;
	    const centerX = (viewBox[2] + viewBox[0]) / 2;
	    const centerY = (viewBox[3] + viewBox[1]) / 2;
	    let rotateA, rotateB, rotateC, rotateD;
	    rotation = rotation % 360;
	    rotation = rotation < 0 ? rotation + 360 : rotation;

	    switch (rotation) {
	      case 180:
	        rotateA = -1;
	        rotateB = 0;
	        rotateC = 0;
	        rotateD = 1;
	        break;

	      case 90:
	        rotateA = 0;
	        rotateB = 1;
	        rotateC = 1;
	        rotateD = 0;
	        break;

	      case 270:
	        rotateA = 0;
	        rotateB = -1;
	        rotateC = -1;
	        rotateD = 0;
	        break;

	      case 0:
	        rotateA = 1;
	        rotateB = 0;
	        rotateC = 0;
	        rotateD = -1;
	        break;

	      default:
	        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
	    }

	    if (dontFlip) {
	      rotateC = -rotateC;
	      rotateD = -rotateD;
	    }

	    let offsetCanvasX, offsetCanvasY;
	    let width, height;

	    if (rotateA === 0) {
	      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
	      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
	      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
	      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
	    } else {
	      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
	      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
	      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
	      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
	    }

	    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
	    this.width = width;
	    this.height = height;
	  }

	  clone({
	    scale = this.scale,
	    rotation = this.rotation,
	    offsetX = this.offsetX,
	    offsetY = this.offsetY,
	    dontFlip = false
	  } = {}) {
	    return new PageViewport({
	      viewBox: this.viewBox.slice(),
	      scale,
	      rotation,
	      offsetX,
	      offsetY,
	      dontFlip
	    });
	  }

	  convertToViewportPoint(x, y) {
	    return _util.Util.applyTransform([x, y], this.transform);
	  }

	  convertToViewportRectangle(rect) {
	    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

	    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

	    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
	  }

	  convertToPdfPoint(x, y) {
	    return _util.Util.applyInverseTransform([x, y], this.transform);
	  }

	}

	exports.PageViewport = PageViewport;

	class RenderingCancelledException extends _util.BaseException {
	  constructor(msg, type) {
	    super(msg);
	    this.type = type;
	  }

	}

	exports.RenderingCancelledException = RenderingCancelledException;
	const LinkTarget = {
	  NONE: 0,
	  SELF: 1,
	  BLANK: 2,
	  PARENT: 3,
	  TOP: 4
	};
	exports.LinkTarget = LinkTarget;

	function addLinkAttributes(link, {
	  url,
	  target,
	  rel,
	  enabled = true
	} = {}) {
	  (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
	  const urlNullRemoved = (0, _util.removeNullCharacters)(url);

	  if (enabled) {
	    link.href = link.title = urlNullRemoved;
	  } else {
	    link.href = "";
	    link.title = `Disabled: ${urlNullRemoved}`;

	    link.onclick = () => {
	      return false;
	    };
	  }

	  let targetStr = "";

	  switch (target) {
	    case LinkTarget.NONE:
	      break;

	    case LinkTarget.SELF:
	      targetStr = "_self";
	      break;

	    case LinkTarget.BLANK:
	      targetStr = "_blank";
	      break;

	    case LinkTarget.PARENT:
	      targetStr = "_parent";
	      break;

	    case LinkTarget.TOP:
	      targetStr = "_top";
	      break;
	  }

	  link.target = targetStr;
	  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
	}

	function isPdfFile(filename) {
	  return typeof filename === "string" && /\.pdf$/i.test(filename);
	}

	function getFilenameFromUrl(url) {
	  const anchor = url.indexOf("#");
	  const query = url.indexOf("?");
	  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
	  return url.substring(url.lastIndexOf("/", end) + 1, end);
	}

	class StatTimer {
	  constructor() {
	    this.started = Object.create(null);
	    this.times = [];
	  }

	  time(name) {
	    if (name in this.started) {
	      (0, _util.warn)(`Timer is already running for ${name}`);
	    }

	    this.started[name] = Date.now();
	  }

	  timeEnd(name) {
	    if (!(name in this.started)) {
	      (0, _util.warn)(`Timer has not been started for ${name}`);
	    }

	    this.times.push({
	      name,
	      start: this.started[name],
	      end: Date.now()
	    });
	    delete this.started[name];
	  }

	  toString() {
	    const outBuf = [];
	    let longest = 0;

	    for (const time of this.times) {
	      const name = time.name;

	      if (name.length > longest) {
	        longest = name.length;
	      }
	    }

	    for (const time of this.times) {
	      const duration = time.end - time.start;
	      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`);
	    }

	    return outBuf.join("");
	  }

	}

	exports.StatTimer = StatTimer;

	function isFetchSupported() {
	  return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
	}

	function isValidFetchUrl(url, baseUrl) {
	  try {
	    const {
	      protocol
	    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
	    return protocol === "http:" || protocol === "https:";
	  } catch (ex) {
	    return false;
	  }
	}

	function loadScript(src, removeScriptElement = false) {
	  return new Promise((resolve, reject) => {
	    const script = document.createElement("script");
	    script.src = src;

	    script.onload = function (evt) {
	      if (removeScriptElement) {
	        script.remove();
	      }

	      resolve(evt);
	    };

	    script.onerror = function () {
	      reject(new Error(`Cannot load script at: ${script.src}`));
	    };

	    (document.head || document.documentElement).appendChild(script);
	  });
	}

	function deprecated(details) {
	  console.log("Deprecated API usage: " + details);
	}

	let pdfDateStringRegex;

	class PDFDateString {
	  static toDateObject(input) {
	    if (!input || !(0, _util.isString)(input)) {
	      return null;
	    }

	    if (!pdfDateStringRegex) {
	      pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
	    }

	    const matches = pdfDateStringRegex.exec(input);

	    if (!matches) {
	      return null;
	    }

	    const year = parseInt(matches[1], 10);
	    let month = parseInt(matches[2], 10);
	    month = month >= 1 && month <= 12 ? month - 1 : 0;
	    let day = parseInt(matches[3], 10);
	    day = day >= 1 && day <= 31 ? day : 1;
	    let hour = parseInt(matches[4], 10);
	    hour = hour >= 0 && hour <= 23 ? hour : 0;
	    let minute = parseInt(matches[5], 10);
	    minute = minute >= 0 && minute <= 59 ? minute : 0;
	    let second = parseInt(matches[6], 10);
	    second = second >= 0 && second <= 59 ? second : 0;
	    const universalTimeRelation = matches[7] || "Z";
	    let offsetHour = parseInt(matches[8], 10);
	    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
	    let offsetMinute = parseInt(matches[9], 10) || 0;
	    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

	    if (universalTimeRelation === "-") {
	      hour += offsetHour;
	      minute += offsetMinute;
	    } else if (universalTimeRelation === "+") {
	      hour -= offsetHour;
	      minute -= offsetMinute;
	    }

	    return new Date(Date.UTC(year, month, day, hour, minute, second));
	  }

	}

	exports.PDFDateString = PDFDateString;

	/***/ }),
	/* 2 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.arrayByteLength = arrayByteLength;
	exports.arraysToBytes = arraysToBytes;
	exports.assert = assert;
	exports.bytesToString = bytesToString;
	exports.createObjectURL = createObjectURL;
	exports.createPromiseCapability = createPromiseCapability;
	exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
	exports.escapeString = escapeString;
	exports.getModificationDate = getModificationDate;
	exports.getVerbosityLevel = getVerbosityLevel;
	exports.info = info;
	exports.isArrayBuffer = isArrayBuffer;
	exports.isArrayEqual = isArrayEqual;
	exports.isAscii = isAscii;
	exports.isBool = isBool;
	exports.isNum = isNum;
	exports.isSameOrigin = isSameOrigin;
	exports.isString = isString;
	exports.objectFromEntries = objectFromEntries;
	exports.objectSize = objectSize;
	exports.removeNullCharacters = removeNullCharacters;
	exports.setVerbosityLevel = setVerbosityLevel;
	exports.shadow = shadow;
	exports.string32 = string32;
	exports.stringToBytes = stringToBytes;
	exports.stringToPDFString = stringToPDFString;
	exports.stringToUTF16BEString = stringToUTF16BEString;
	exports.stringToUTF8String = stringToUTF8String;
	exports.unreachable = unreachable;
	exports.utf8StringToString = utf8StringToString;
	exports.warn = warn;
	exports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;

	__w_pdfjs_require__(3);

	const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
	exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
	const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
	exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
	const PermissionFlag = {
	  PRINT: 0x04,
	  MODIFY_CONTENTS: 0x08,
	  COPY: 0x10,
	  MODIFY_ANNOTATIONS: 0x20,
	  FILL_INTERACTIVE_FORMS: 0x100,
	  COPY_FOR_ACCESSIBILITY: 0x200,
	  ASSEMBLE: 0x400,
	  PRINT_HIGH_QUALITY: 0x800
	};
	exports.PermissionFlag = PermissionFlag;
	const TextRenderingMode = {
	  FILL: 0,
	  STROKE: 1,
	  FILL_STROKE: 2,
	  INVISIBLE: 3,
	  FILL_ADD_TO_PATH: 4,
	  STROKE_ADD_TO_PATH: 5,
	  FILL_STROKE_ADD_TO_PATH: 6,
	  ADD_TO_PATH: 7,
	  FILL_STROKE_MASK: 3,
	  ADD_TO_PATH_FLAG: 4
	};
	exports.TextRenderingMode = TextRenderingMode;
	const ImageKind = {
	  GRAYSCALE_1BPP: 1,
	  RGB_24BPP: 2,
	  RGBA_32BPP: 3
	};
	exports.ImageKind = ImageKind;
	const AnnotationType = {
	  TEXT: 1,
	  LINK: 2,
	  FREETEXT: 3,
	  LINE: 4,
	  SQUARE: 5,
	  CIRCLE: 6,
	  POLYGON: 7,
	  POLYLINE: 8,
	  HIGHLIGHT: 9,
	  UNDERLINE: 10,
	  SQUIGGLY: 11,
	  STRIKEOUT: 12,
	  STAMP: 13,
	  CARET: 14,
	  INK: 15,
	  POPUP: 16,
	  FILEATTACHMENT: 17,
	  SOUND: 18,
	  MOVIE: 19,
	  WIDGET: 20,
	  SCREEN: 21,
	  PRINTERMARK: 22,
	  TRAPNET: 23,
	  WATERMARK: 24,
	  THREED: 25,
	  REDACT: 26
	};
	exports.AnnotationType = AnnotationType;
	const AnnotationStateModelType = {
	  MARKED: "Marked",
	  REVIEW: "Review"
	};
	exports.AnnotationStateModelType = AnnotationStateModelType;
	const AnnotationMarkedState = {
	  MARKED: "Marked",
	  UNMARKED: "Unmarked"
	};
	exports.AnnotationMarkedState = AnnotationMarkedState;
	const AnnotationReviewState = {
	  ACCEPTED: "Accepted",
	  REJECTED: "Rejected",
	  CANCELLED: "Cancelled",
	  COMPLETED: "Completed",
	  NONE: "None"
	};
	exports.AnnotationReviewState = AnnotationReviewState;
	const AnnotationReplyType = {
	  GROUP: "Group",
	  REPLY: "R"
	};
	exports.AnnotationReplyType = AnnotationReplyType;
	const AnnotationFlag = {
	  INVISIBLE: 0x01,
	  HIDDEN: 0x02,
	  PRINT: 0x04,
	  NOZOOM: 0x08,
	  NOROTATE: 0x10,
	  NOVIEW: 0x20,
	  READONLY: 0x40,
	  LOCKED: 0x80,
	  TOGGLENOVIEW: 0x100,
	  LOCKEDCONTENTS: 0x200
	};
	exports.AnnotationFlag = AnnotationFlag;
	const AnnotationFieldFlag = {
	  READONLY: 0x0000001,
	  REQUIRED: 0x0000002,
	  NOEXPORT: 0x0000004,
	  MULTILINE: 0x0001000,
	  PASSWORD: 0x0002000,
	  NOTOGGLETOOFF: 0x0004000,
	  RADIO: 0x0008000,
	  PUSHBUTTON: 0x0010000,
	  COMBO: 0x0020000,
	  EDIT: 0x0040000,
	  SORT: 0x0080000,
	  FILESELECT: 0x0100000,
	  MULTISELECT: 0x0200000,
	  DONOTSPELLCHECK: 0x0400000,
	  DONOTSCROLL: 0x0800000,
	  COMB: 0x1000000,
	  RICHTEXT: 0x2000000,
	  RADIOSINUNISON: 0x2000000,
	  COMMITONSELCHANGE: 0x4000000
	};
	exports.AnnotationFieldFlag = AnnotationFieldFlag;
	const AnnotationBorderStyleType = {
	  SOLID: 1,
	  DASHED: 2,
	  BEVELED: 3,
	  INSET: 4,
	  UNDERLINE: 5
	};
	exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
	const AnnotationActionEventType = {
	  E: "Mouse Enter",
	  X: "Mouse Exit",
	  D: "Mouse Down",
	  U: "Mouse Up",
	  Fo: "Focus",
	  Bl: "Blur",
	  PO: "PageOpen",
	  PC: "PageClose",
	  PV: "PageVisible",
	  PI: "PageInvisible",
	  K: "Keystroke",
	  F: "Format",
	  V: "Validate",
	  C: "Calculate"
	};
	exports.AnnotationActionEventType = AnnotationActionEventType;
	const DocumentActionEventType = {
	  WC: "WillClose",
	  WS: "WillSave",
	  DS: "DidSave",
	  WP: "WillPrint",
	  DP: "DidPrint"
	};
	exports.DocumentActionEventType = DocumentActionEventType;
	const PageActionEventType = {
	  O: "PageOpen",
	  C: "PageClose"
	};
	exports.PageActionEventType = PageActionEventType;
	const StreamType = {
	  UNKNOWN: "UNKNOWN",
	  FLATE: "FLATE",
	  LZW: "LZW",
	  DCT: "DCT",
	  JPX: "JPX",
	  JBIG: "JBIG",
	  A85: "A85",
	  AHX: "AHX",
	  CCF: "CCF",
	  RLX: "RLX"
	};
	exports.StreamType = StreamType;
	const FontType = {
	  UNKNOWN: "UNKNOWN",
	  TYPE1: "TYPE1",
	  TYPE1C: "TYPE1C",
	  CIDFONTTYPE0: "CIDFONTTYPE0",
	  CIDFONTTYPE0C: "CIDFONTTYPE0C",
	  TRUETYPE: "TRUETYPE",
	  CIDFONTTYPE2: "CIDFONTTYPE2",
	  TYPE3: "TYPE3",
	  OPENTYPE: "OPENTYPE",
	  TYPE0: "TYPE0",
	  MMTYPE1: "MMTYPE1"
	};
	exports.FontType = FontType;
	const VerbosityLevel = {
	  ERRORS: 0,
	  WARNINGS: 1,
	  INFOS: 5
	};
	exports.VerbosityLevel = VerbosityLevel;
	const CMapCompressionType = {
	  NONE: 0,
	  BINARY: 1,
	  STREAM: 2
	};
	exports.CMapCompressionType = CMapCompressionType;
	const OPS = {
	  dependency: 1,
	  setLineWidth: 2,
	  setLineCap: 3,
	  setLineJoin: 4,
	  setMiterLimit: 5,
	  setDash: 6,
	  setRenderingIntent: 7,
	  setFlatness: 8,
	  setGState: 9,
	  save: 10,
	  restore: 11,
	  transform: 12,
	  moveTo: 13,
	  lineTo: 14,
	  curveTo: 15,
	  curveTo2: 16,
	  curveTo3: 17,
	  closePath: 18,
	  rectangle: 19,
	  stroke: 20,
	  closeStroke: 21,
	  fill: 22,
	  eoFill: 23,
	  fillStroke: 24,
	  eoFillStroke: 25,
	  closeFillStroke: 26,
	  closeEOFillStroke: 27,
	  endPath: 28,
	  clip: 29,
	  eoClip: 30,
	  beginText: 31,
	  endText: 32,
	  setCharSpacing: 33,
	  setWordSpacing: 34,
	  setHScale: 35,
	  setLeading: 36,
	  setFont: 37,
	  setTextRenderingMode: 38,
	  setTextRise: 39,
	  moveText: 40,
	  setLeadingMoveText: 41,
	  setTextMatrix: 42,
	  nextLine: 43,
	  showText: 44,
	  showSpacedText: 45,
	  nextLineShowText: 46,
	  nextLineSetSpacingShowText: 47,
	  setCharWidth: 48,
	  setCharWidthAndBounds: 49,
	  setStrokeColorSpace: 50,
	  setFillColorSpace: 51,
	  setStrokeColor: 52,
	  setStrokeColorN: 53,
	  setFillColor: 54,
	  setFillColorN: 55,
	  setStrokeGray: 56,
	  setFillGray: 57,
	  setStrokeRGBColor: 58,
	  setFillRGBColor: 59,
	  setStrokeCMYKColor: 60,
	  setFillCMYKColor: 61,
	  shadingFill: 62,
	  beginInlineImage: 63,
	  beginImageData: 64,
	  endInlineImage: 65,
	  paintXObject: 66,
	  markPoint: 67,
	  markPointProps: 68,
	  beginMarkedContent: 69,
	  beginMarkedContentProps: 70,
	  endMarkedContent: 71,
	  beginCompat: 72,
	  endCompat: 73,
	  paintFormXObjectBegin: 74,
	  paintFormXObjectEnd: 75,
	  beginGroup: 76,
	  endGroup: 77,
	  beginAnnotations: 78,
	  endAnnotations: 79,
	  beginAnnotation: 80,
	  endAnnotation: 81,
	  paintJpegXObject: 82,
	  paintImageMaskXObject: 83,
	  paintImageMaskXObjectGroup: 84,
	  paintImageXObject: 85,
	  paintInlineImageXObject: 86,
	  paintInlineImageXObjectGroup: 87,
	  paintImageXObjectRepeat: 88,
	  paintImageMaskXObjectRepeat: 89,
	  paintSolidColorImageMask: 90,
	  constructPath: 91
	};
	exports.OPS = OPS;
	const UNSUPPORTED_FEATURES = {
	  unknown: "unknown",
	  forms: "forms",
	  javaScript: "javaScript",
	  smask: "smask",
	  shadingPattern: "shadingPattern",
	  font: "font",
	  errorTilingPattern: "errorTilingPattern",
	  errorExtGState: "errorExtGState",
	  errorXObject: "errorXObject",
	  errorFontLoadType3: "errorFontLoadType3",
	  errorFontState: "errorFontState",
	  errorFontMissing: "errorFontMissing",
	  errorFontTranslate: "errorFontTranslate",
	  errorColorSpace: "errorColorSpace",
	  errorOperatorList: "errorOperatorList",
	  errorFontToUnicode: "errorFontToUnicode",
	  errorFontLoadNative: "errorFontLoadNative",
	  errorFontGetPath: "errorFontGetPath",
	  errorMarkedContent: "errorMarkedContent"
	};
	exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
	const PasswordResponses = {
	  NEED_PASSWORD: 1,
	  INCORRECT_PASSWORD: 2
	};
	exports.PasswordResponses = PasswordResponses;
	let verbosity = VerbosityLevel.WARNINGS;

	function setVerbosityLevel(level) {
	  if (Number.isInteger(level)) {
	    verbosity = level;
	  }
	}

	function getVerbosityLevel() {
	  return verbosity;
	}

	function info(msg) {
	  if (verbosity >= VerbosityLevel.INFOS) {
	    console.log(`Info: ${msg}`);
	  }
	}

	function warn(msg) {
	  if (verbosity >= VerbosityLevel.WARNINGS) {
	    console.log(`Warning: ${msg}`);
	  }
	}

	function unreachable(msg) {
	  throw new Error(msg);
	}

	function assert(cond, msg) {
	  if (!cond) {
	    unreachable(msg);
	  }
	}

	function isSameOrigin(baseUrl, otherUrl) {
	  let base;

	  try {
	    base = new URL(baseUrl);

	    if (!base.origin || base.origin === "null") {
	      return false;
	    }
	  } catch (e) {
	    return false;
	  }

	  const other = new URL(otherUrl, base);
	  return base.origin === other.origin;
	}

	function _isValidProtocol(url) {
	  if (!url) {
	    return false;
	  }

	  switch (url.protocol) {
	    case "http:":
	    case "https:":
	    case "ftp:":
	    case "mailto:":
	    case "tel:":
	      return true;

	    default:
	      return false;
	  }
	}

	function createValidAbsoluteUrl(url, baseUrl) {
	  if (!url) {
	    return null;
	  }

	  try {
	    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

	    if (_isValidProtocol(absoluteUrl)) {
	      return absoluteUrl;
	    }
	  } catch (ex) {}

	  return null;
	}

	function shadow(obj, prop, value) {
	  Object.defineProperty(obj, prop, {
	    value,
	    enumerable: true,
	    configurable: true,
	    writable: false
	  });
	  return value;
	}

	const BaseException = function BaseExceptionClosure() {
	  function BaseException(message) {
	    if (this.constructor === BaseException) {
	      unreachable("Cannot initialize BaseException.");
	    }

	    this.message = message;
	    this.name = this.constructor.name;
	  }

	  BaseException.prototype = new Error();
	  BaseException.constructor = BaseException;
	  return BaseException;
	}();

	exports.BaseException = BaseException;

	class PasswordException extends BaseException {
	  constructor(msg, code) {
	    super(msg);
	    this.code = code;
	  }

	}

	exports.PasswordException = PasswordException;

	class UnknownErrorException extends BaseException {
	  constructor(msg, details) {
	    super(msg);
	    this.details = details;
	  }

	}

	exports.UnknownErrorException = UnknownErrorException;

	class InvalidPDFException extends BaseException {}

	exports.InvalidPDFException = InvalidPDFException;

	class MissingPDFException extends BaseException {}

	exports.MissingPDFException = MissingPDFException;

	class UnexpectedResponseException extends BaseException {
	  constructor(msg, status) {
	    super(msg);
	    this.status = status;
	  }

	}

	exports.UnexpectedResponseException = UnexpectedResponseException;

	class FormatError extends BaseException {}

	exports.FormatError = FormatError;

	class AbortException extends BaseException {}

	exports.AbortException = AbortException;
	const NullCharactersRegExp = /\x00/g;

	function removeNullCharacters(str) {
	  if (typeof str !== "string") {
	    warn("The argument for removeNullCharacters must be a string.");
	    return str;
	  }

	  return str.replace(NullCharactersRegExp, "");
	}

	function bytesToString(bytes) {
	  assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
	  const length = bytes.length;
	  const MAX_ARGUMENT_COUNT = 8192;

	  if (length < MAX_ARGUMENT_COUNT) {
	    return String.fromCharCode.apply(null, bytes);
	  }

	  const strBuf = [];

	  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
	    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
	    const chunk = bytes.subarray(i, chunkEnd);
	    strBuf.push(String.fromCharCode.apply(null, chunk));
	  }

	  return strBuf.join("");
	}

	function stringToBytes(str) {
	  assert(typeof str === "string", "Invalid argument for stringToBytes");
	  const length = str.length;
	  const bytes = new Uint8Array(length);

	  for (let i = 0; i < length; ++i) {
	    bytes[i] = str.charCodeAt(i) & 0xff;
	  }

	  return bytes;
	}

	function arrayByteLength(arr) {
	  if (arr.length !== undefined) {
	    return arr.length;
	  }

	  assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
	  return arr.byteLength;
	}

	function arraysToBytes(arr) {
	  const length = arr.length;

	  if (length === 1 && arr[0] instanceof Uint8Array) {
	    return arr[0];
	  }

	  let resultLength = 0;

	  for (let i = 0; i < length; i++) {
	    resultLength += arrayByteLength(arr[i]);
	  }

	  let pos = 0;
	  const data = new Uint8Array(resultLength);

	  for (let i = 0; i < length; i++) {
	    let item = arr[i];

	    if (!(item instanceof Uint8Array)) {
	      if (typeof item === "string") {
	        item = stringToBytes(item);
	      } else {
	        item = new Uint8Array(item);
	      }
	    }

	    const itemLength = item.byteLength;
	    data.set(item, pos);
	    pos += itemLength;
	  }

	  return data;
	}

	function string32(value) {
	  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
	}

	function objectSize(obj) {
	  return Object.keys(obj).length;
	}

	function objectFromEntries(iterable) {
	  return Object.assign(Object.create(null), Object.fromEntries(iterable));
	}

	function isLittleEndian() {
	  const buffer8 = new Uint8Array(4);
	  buffer8[0] = 1;
	  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
	  return view32[0] === 1;
	}

	const IsLittleEndianCached = {
	  get value() {
	    return shadow(this, "value", isLittleEndian());
	  }

	};
	exports.IsLittleEndianCached = IsLittleEndianCached;

	function isEvalSupported() {
	  try {
	    new Function("");
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	const IsEvalSupportedCached = {
	  get value() {
	    return shadow(this, "value", isEvalSupported());
	  }

	};
	exports.IsEvalSupportedCached = IsEvalSupportedCached;
	const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

	class Util {
	  static makeHexColor(r, g, b) {
	    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
	  }

	  static transform(m1, m2) {
	    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
	  }

	  static applyTransform(p, m) {
	    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
	    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
	    return [xt, yt];
	  }

	  static applyInverseTransform(p, m) {
	    const d = m[0] * m[3] - m[1] * m[2];
	    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
	    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
	    return [xt, yt];
	  }

	  static getAxialAlignedBoundingBox(r, m) {
	    const p1 = Util.applyTransform(r, m);
	    const p2 = Util.applyTransform(r.slice(2, 4), m);
	    const p3 = Util.applyTransform([r[0], r[3]], m);
	    const p4 = Util.applyTransform([r[2], r[1]], m);
	    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
	  }

	  static inverseTransform(m) {
	    const d = m[0] * m[3] - m[1] * m[2];
	    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
	  }

	  static apply3dTransform(m, v) {
	    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
	  }

	  static singularValueDecompose2dScale(m) {
	    const transpose = [m[0], m[2], m[1], m[3]];
	    const a = m[0] * transpose[0] + m[1] * transpose[2];
	    const b = m[0] * transpose[1] + m[1] * transpose[3];
	    const c = m[2] * transpose[0] + m[3] * transpose[2];
	    const d = m[2] * transpose[1] + m[3] * transpose[3];
	    const first = (a + d) / 2;
	    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
	    const sx = first + second || 1;
	    const sy = first - second || 1;
	    return [Math.sqrt(sx), Math.sqrt(sy)];
	  }

	  static normalizeRect(rect) {
	    const r = rect.slice(0);

	    if (rect[0] > rect[2]) {
	      r[0] = rect[2];
	      r[2] = rect[0];
	    }

	    if (rect[1] > rect[3]) {
	      r[1] = rect[3];
	      r[3] = rect[1];
	    }

	    return r;
	  }

	  static intersect(rect1, rect2) {
	    function compare(a, b) {
	      return a - b;
	    }

	    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
	    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
	    const result = [];
	    rect1 = Util.normalizeRect(rect1);
	    rect2 = Util.normalizeRect(rect2);

	    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
	      result[0] = orderedX[1];
	      result[2] = orderedX[2];
	    } else {
	      return null;
	    }

	    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
	      result[1] = orderedY[1];
	      result[3] = orderedY[2];
	    } else {
	      return null;
	    }

	    return result;
	  }

	}

	exports.Util = Util;
	const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];

	function stringToPDFString(str) {
	  const length = str.length,
	        strBuf = [];

	  if (str[0] === "\xFE" && str[1] === "\xFF") {
	    for (let i = 2; i < length; i += 2) {
	      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
	    }
	  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
	    for (let i = 2; i < length; i += 2) {
	      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
	    }
	  } else {
	    for (let i = 0; i < length; ++i) {
	      const code = PDFStringTranslateTable[str.charCodeAt(i)];
	      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
	    }
	  }

	  return strBuf.join("");
	}

	function escapeString(str) {
	  return str.replace(/([()\\\n\r])/g, match => {
	    if (match === "\n") {
	      return "\\n";
	    } else if (match === "\r") {
	      return "\\r";
	    }

	    return `\\${match}`;
	  });
	}

	function isAscii(str) {
	  return /^[\x00-\x7F]*$/.test(str);
	}

	function stringToUTF16BEString(str) {
	  const buf = ["\xFE\xFF"];

	  for (let i = 0, ii = str.length; i < ii; i++) {
	    const char = str.charCodeAt(i);
	    buf.push(String.fromCharCode(char >> 8 & 0xff));
	    buf.push(String.fromCharCode(char & 0xff));
	  }

	  return buf.join("");
	}

	function stringToUTF8String(str) {
	  return decodeURIComponent(escape(str));
	}

	function utf8StringToString(str) {
	  return unescape(encodeURIComponent(str));
	}

	function isBool(v) {
	  return typeof v === "boolean";
	}

	function isNum(v) {
	  return typeof v === "number";
	}

	function isString(v) {
	  return typeof v === "string";
	}

	function isArrayBuffer(v) {
	  return typeof v === "object" && v !== null && v.byteLength !== undefined;
	}

	function isArrayEqual(arr1, arr2) {
	  if (arr1.length !== arr2.length) {
	    return false;
	  }

	  for (let i = 0, ii = arr1.length; i < ii; i++) {
	    if (arr1[i] !== arr2[i]) {
	      return false;
	    }
	  }

	  return true;
	}

	function getModificationDate(date = new Date()) {
	  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
	  return buffer.join("");
	}

	function createPromiseCapability() {
	  const capability = Object.create(null);
	  let isSettled = false;
	  Object.defineProperty(capability, "settled", {
	    get() {
	      return isSettled;
	    }

	  });
	  capability.promise = new Promise(function (resolve, reject) {
	    capability.resolve = function (data) {
	      isSettled = true;
	      resolve(data);
	    };

	    capability.reject = function (reason) {
	      isSettled = true;
	      reject(reason);
	    };
	  });
	  return capability;
	}

	function createObjectURL(data, contentType = "", forceDataSchema = false) {
	  if (URL.createObjectURL && !forceDataSchema) {
	    return URL.createObjectURL(new Blob([data], {
	      type: contentType
	    }));
	  }

	  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	  let buffer = `data:${contentType};base64,`;

	  for (let i = 0, ii = data.length; i < ii; i += 3) {
	    const b1 = data[i] & 0xff;
	    const b2 = data[i + 1] & 0xff;
	    const b3 = data[i + 2] & 0xff;
	    const d1 = b1 >> 2,
	          d2 = (b1 & 3) << 4 | b2 >> 4;
	    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
	    const d4 = i + 2 < ii ? b3 & 0x3f : 64;
	    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
	  }

	  return buffer;
	}

	/***/ }),
	/* 3 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {



	__w_pdfjs_require__(4);

	/***/ }),
	/* 4 */
	/***/ ((__unused_webpack_module, exports) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.isNodeJS = void 0;
	const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
	exports.isNodeJS = isNodeJS;

	/***/ }),
	/* 5 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.getDocument = getDocument;
	exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
	exports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;

	var _util = __w_pdfjs_require__(2);

	var _display_utils = __w_pdfjs_require__(1);

	var _font_loader = __w_pdfjs_require__(6);

	var _node_utils = __w_pdfjs_require__(7);

	var _annotation_storage = __w_pdfjs_require__(8);

	var _api_compatibility = __w_pdfjs_require__(9);

	var _canvas = __w_pdfjs_require__(10);

	var _worker_options = __w_pdfjs_require__(12);

	var _is_node = __w_pdfjs_require__(4);

	var _message_handler = __w_pdfjs_require__(13);

	var _metadata = __w_pdfjs_require__(14);

	var _optional_content_config = __w_pdfjs_require__(15);

	var _transport_stream = __w_pdfjs_require__(16);

	var _webgl = __w_pdfjs_require__(17);

	const DEFAULT_RANGE_CHUNK_SIZE = 65536;
	const RENDERING_CANCELLED_TIMEOUT = 100;
	const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
	exports.DefaultCanvasFactory = DefaultCanvasFactory;
	const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
	exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
	let createPDFNetworkStream;

	function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
	  createPDFNetworkStream = pdfNetworkStreamFactory;
	}

	function getDocument(src) {
	  const task = new PDFDocumentLoadingTask();
	  let source;

	  if (typeof src === "string") {
	    source = {
	      url: src
	    };
	  } else if ((0, _util.isArrayBuffer)(src)) {
	    source = {
	      data: src
	    };
	  } else if (src instanceof PDFDataRangeTransport) {
	    source = {
	      range: src
	    };
	  } else {
	    if (typeof src !== "object") {
	      throw new Error("Invalid parameter in getDocument, " + "need either Uint8Array, string or a parameter object");
	    }

	    if (!src.url && !src.data && !src.range) {
	      throw new Error("Invalid parameter object: need either .data, .range or .url");
	    }

	    source = src;
	  }

	  const params = Object.create(null);
	  let rangeTransport = null,
	      worker = null;

	  for (const key in source) {
	    if (key === "url" && typeof window !== "undefined") {
	      params[key] = new URL(source[key], window.location).href;
	      continue;
	    } else if (key === "range") {
	      rangeTransport = source[key];
	      continue;
	    } else if (key === "worker") {
	      worker = source[key];
	      continue;
	    } else if (key === "data" && !(source[key] instanceof Uint8Array)) {
	      const pdfBytes = source[key];

	      if (typeof pdfBytes === "string") {
	        params[key] = (0, _util.stringToBytes)(pdfBytes);
	      } else if (typeof pdfBytes === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {
	        params[key] = new Uint8Array(pdfBytes);
	      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
	        params[key] = new Uint8Array(pdfBytes);
	      } else {
	        throw new Error("Invalid PDF binary data: either typed array, " + "string or array-like object is expected in the " + "data property.");
	      }

	      continue;
	    }

	    params[key] = source[key];
	  }

	  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
	  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
	  params.ignoreErrors = params.stopAtErrors !== true;
	  params.fontExtraProperties = params.fontExtraProperties === true;
	  params.pdfBug = params.pdfBug === true;

	  if (!Number.isInteger(params.maxImageSize)) {
	    params.maxImageSize = -1;
	  }

	  if (typeof params.isEvalSupported !== "boolean") {
	    params.isEvalSupported = true;
	  }

	  if (typeof params.disableFontFace !== "boolean") {
	    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
	  }

	  if (typeof params.ownerDocument === "undefined") {
	    params.ownerDocument = globalThis.document;
	  }

	  if (typeof params.disableRange !== "boolean") {
	    params.disableRange = false;
	  }

	  if (typeof params.disableStream !== "boolean") {
	    params.disableStream = false;
	  }

	  if (typeof params.disableAutoFetch !== "boolean") {
	    params.disableAutoFetch = false;
	  }

	  (0, _util.setVerbosityLevel)(params.verbosity);

	  if (!worker) {
	    const workerParams = {
	      verbosity: params.verbosity,
	      port: _worker_options.GlobalWorkerOptions.workerPort
	    };
	    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
	    task._worker = worker;
	  }

	  const docId = task.docId;
	  worker.promise.then(function () {
	    if (task.destroyed) {
	      throw new Error("Loading aborted");
	    }

	    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

	    const networkStreamPromise = new Promise(function (resolve) {
	      let networkStream;

	      if (rangeTransport) {
	        networkStream = new _transport_stream.PDFDataTransportStream({
	          length: params.length,
	          initialData: params.initialData,
	          progressiveDone: params.progressiveDone,
	          contentDispositionFilename: params.contentDispositionFilename,
	          disableRange: params.disableRange,
	          disableStream: params.disableStream
	        }, rangeTransport);
	      } else if (!params.data) {
	        networkStream = createPDFNetworkStream({
	          url: params.url,
	          length: params.length,
	          httpHeaders: params.httpHeaders,
	          withCredentials: params.withCredentials,
	          rangeChunkSize: params.rangeChunkSize,
	          disableRange: params.disableRange,
	          disableStream: params.disableStream
	        });
	      }

	      resolve(networkStream);
	    });
	    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {
	      if (task.destroyed) {
	        throw new Error("Loading aborted");
	      }

	      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
	      messageHandler.postMessageTransfers = worker.postMessageTransfers;
	      const transport = new WorkerTransport(messageHandler, task, networkStream, params);
	      task._transport = transport;
	      messageHandler.send("Ready", null);
	    });
	  }).catch(task._capability.reject);
	  return task;
	}

	function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
	  if (worker.destroyed) {
	    return Promise.reject(new Error("Worker was destroyed"));
	  }

	  if (pdfDataRangeTransport) {
	    source.length = pdfDataRangeTransport.length;
	    source.initialData = pdfDataRangeTransport.initialData;
	    source.progressiveDone = pdfDataRangeTransport.progressiveDone;
	    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
	  }

	  return worker.messageHandler.sendWithPromise("GetDocRequest", {
	    docId,
	    apiVersion: '2.8.188',
	    source: {
	      data: source.data,
	      url: source.url,
	      password: source.password,
	      disableAutoFetch: source.disableAutoFetch,
	      rangeChunkSize: source.rangeChunkSize,
	      length: source.length
	    },
	    maxImageSize: source.maxImageSize,
	    disableFontFace: source.disableFontFace,
	    postMessageTransfers: worker.postMessageTransfers,
	    docBaseUrl: source.docBaseUrl,
	    ignoreErrors: source.ignoreErrors,
	    isEvalSupported: source.isEvalSupported,
	    fontExtraProperties: source.fontExtraProperties
	  }).then(function (workerId) {
	    if (worker.destroyed) {
	      throw new Error("Worker was destroyed");
	    }

	    return workerId;
	  });
	}

	const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
	  let nextDocumentId = 0;

	  class PDFDocumentLoadingTask {
	    constructor() {
	      this._capability = (0, _util.createPromiseCapability)();
	      this._transport = null;
	      this._worker = null;
	      this.docId = "d" + nextDocumentId++;
	      this.destroyed = false;
	      this.onPassword = null;
	      this.onProgress = null;
	      this.onUnsupportedFeature = null;
	    }

	    get promise() {
	      return this._capability.promise;
	    }

	    destroy() {
	      this.destroyed = true;
	      const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
	      return transportDestroyed.then(() => {
	        this._transport = null;

	        if (this._worker) {
	          this._worker.destroy();

	          this._worker = null;
	        }
	      });
	    }

	  }

	  return PDFDocumentLoadingTask;
	}();

	class PDFDataRangeTransport {
	  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
	    this.length = length;
	    this.initialData = initialData;
	    this.progressiveDone = progressiveDone;
	    this.contentDispositionFilename = contentDispositionFilename;
	    this._rangeListeners = [];
	    this._progressListeners = [];
	    this._progressiveReadListeners = [];
	    this._progressiveDoneListeners = [];
	    this._readyCapability = (0, _util.createPromiseCapability)();
	  }

	  addRangeListener(listener) {
	    this._rangeListeners.push(listener);
	  }

	  addProgressListener(listener) {
	    this._progressListeners.push(listener);
	  }

	  addProgressiveReadListener(listener) {
	    this._progressiveReadListeners.push(listener);
	  }

	  addProgressiveDoneListener(listener) {
	    this._progressiveDoneListeners.push(listener);
	  }

	  onDataRange(begin, chunk) {
	    for (const listener of this._rangeListeners) {
	      listener(begin, chunk);
	    }
	  }

	  onDataProgress(loaded, total) {
	    this._readyCapability.promise.then(() => {
	      for (const listener of this._progressListeners) {
	        listener(loaded, total);
	      }
	    });
	  }

	  onDataProgressiveRead(chunk) {
	    this._readyCapability.promise.then(() => {
	      for (const listener of this._progressiveReadListeners) {
	        listener(chunk);
	      }
	    });
	  }

	  onDataProgressiveDone() {
	    this._readyCapability.promise.then(() => {
	      for (const listener of this._progressiveDoneListeners) {
	        listener();
	      }
	    });
	  }

	  transportReady() {
	    this._readyCapability.resolve();
	  }

	  requestDataRange(begin, end) {
	    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
	  }

	  abort() {}

	}

	exports.PDFDataRangeTransport = PDFDataRangeTransport;

	class PDFDocumentProxy {
	  constructor(pdfInfo, transport) {
	    this._pdfInfo = pdfInfo;
	    this._transport = transport;
	  }

	  get annotationStorage() {
	    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
	  }

	  get numPages() {
	    return this._pdfInfo.numPages;
	  }

	  get fingerprint() {
	    return this._pdfInfo.fingerprint;
	  }

	  getPage(pageNumber) {
	    return this._transport.getPage(pageNumber);
	  }

	  getPageIndex(ref) {
	    return this._transport.getPageIndex(ref);
	  }

	  getDestinations() {
	    return this._transport.getDestinations();
	  }

	  getDestination(id) {
	    return this._transport.getDestination(id);
	  }

	  getPageLabels() {
	    return this._transport.getPageLabels();
	  }

	  getPageLayout() {
	    return this._transport.getPageLayout();
	  }

	  getPageMode() {
	    return this._transport.getPageMode();
	  }

	  getViewerPreferences() {
	    return this._transport.getViewerPreferences();
	  }

	  getOpenAction() {
	    return this._transport.getOpenAction();
	  }

	  getAttachments() {
	    return this._transport.getAttachments();
	  }

	  getJavaScript() {
	    return this._transport.getJavaScript();
	  }

	  getJSActions() {
	    return this._transport.getDocJSActions();
	  }

	  getOutline() {
	    return this._transport.getOutline();
	  }

	  getOptionalContentConfig() {
	    return this._transport.getOptionalContentConfig();
	  }

	  getPermissions() {
	    return this._transport.getPermissions();
	  }

	  getMetadata() {
	    return this._transport.getMetadata();
	  }

	  getMarkInfo() {
	    return this._transport.getMarkInfo();
	  }

	  getData() {
	    return this._transport.getData();
	  }

	  getDownloadInfo() {
	    return this._transport.downloadInfoCapability.promise;
	  }

	  getStats() {
	    return this._transport.getStats();
	  }

	  cleanup() {
	    return this._transport.startCleanup();
	  }

	  destroy() {
	    return this.loadingTask.destroy();
	  }

	  get loadingParams() {
	    return this._transport.loadingParams;
	  }

	  get loadingTask() {
	    return this._transport.loadingTask;
	  }

	  saveDocument(annotationStorage) {
	    return this._transport.saveDocument(annotationStorage);
	  }

	  getFieldObjects() {
	    return this._transport.getFieldObjects();
	  }

	  hasJSActions() {
	    return this._transport.hasJSActions();
	  }

	  getCalculationOrderIds() {
	    return this._transport.getCalculationOrderIds();
	  }

	}

	exports.PDFDocumentProxy = PDFDocumentProxy;

	class PDFPageProxy {
	  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
	    this._pageIndex = pageIndex;
	    this._pageInfo = pageInfo;
	    this._ownerDocument = ownerDocument;
	    this._transport = transport;
	    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
	    this._pdfBug = pdfBug;
	    this.commonObjs = transport.commonObjs;
	    this.objs = new PDFObjects();
	    this.cleanupAfterRender = false;
	    this.pendingCleanup = false;
	    this._intentStates = new Map();
	    this.destroyed = false;
	  }

	  get pageNumber() {
	    return this._pageIndex + 1;
	  }

	  get rotate() {
	    return this._pageInfo.rotate;
	  }

	  get ref() {
	    return this._pageInfo.ref;
	  }

	  get userUnit() {
	    return this._pageInfo.userUnit;
	  }

	  get view() {
	    return this._pageInfo.view;
	  }

	  getViewport({
	    scale,
	    rotation = this.rotate,
	    offsetX = 0,
	    offsetY = 0,
	    dontFlip = false
	  } = {}) {
	    return new _display_utils.PageViewport({
	      viewBox: this.view,
	      scale,
	      rotation,
	      offsetX,
	      offsetY,
	      dontFlip
	    });
	  }

	  getAnnotations({
	    intent = null
	  } = {}) {
	    if (!this.annotationsPromise || this.annotationsIntent !== intent) {
	      this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
	      this.annotationsIntent = intent;
	    }

	    return this.annotationsPromise;
	  }

	  getJSActions() {
	    return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
	  }

	  render({
	    canvasContext,
	    viewport,
	    intent = "display",
	    enableWebGL = false,
	    renderInteractiveForms = false,
	    transform = null,
	    imageLayer = null,
	    canvasFactory = null,
	    background = null,
	    annotationStorage = null,
	    optionalContentConfigPromise = null
	  }) {
	    if (this._stats) {
	      this._stats.time("Overall");
	    }

	    const renderingIntent = intent === "print" ? "print" : "display";
	    this.pendingCleanup = false;

	    if (!optionalContentConfigPromise) {
	      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
	    }

	    let intentState = this._intentStates.get(renderingIntent);

	    if (!intentState) {
	      intentState = Object.create(null);

	      this._intentStates.set(renderingIntent, intentState);
	    }

	    if (intentState.streamReaderCancelTimeout) {
	      clearTimeout(intentState.streamReaderCancelTimeout);
	      intentState.streamReaderCancelTimeout = null;
	    }

	    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
	      ownerDocument: this._ownerDocument
	    });
	    const webGLContext = new _webgl.WebGLContext({
	      enable: enableWebGL
	    });

	    if (!intentState.displayReadyCapability) {
	      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
	      intentState.operatorList = {
	        fnArray: [],
	        argsArray: [],
	        lastChunk: false
	      };

	      if (this._stats) {
	        this._stats.time("Page Request");
	      }

	      this._pumpOperatorList({
	        pageIndex: this._pageIndex,
	        intent: renderingIntent,
	        renderInteractiveForms: renderInteractiveForms === true,
	        annotationStorage: annotationStorage?.serializable || null
	      });
	    }

	    const complete = error => {
	      const i = intentState.renderTasks.indexOf(internalRenderTask);

	      if (i >= 0) {
	        intentState.renderTasks.splice(i, 1);
	      }

	      if (this.cleanupAfterRender || renderingIntent === "print") {
	        this.pendingCleanup = true;
	      }

	      this._tryCleanup();

	      if (error) {
	        internalRenderTask.capability.reject(error);

	        this._abortOperatorList({
	          intentState,
	          reason: error
	        });
	      } else {
	        internalRenderTask.capability.resolve();
	      }

	      if (this._stats) {
	        this._stats.timeEnd("Rendering");

	        this._stats.timeEnd("Overall");
	      }
	    };

	    const internalRenderTask = new InternalRenderTask({
	      callback: complete,
	      params: {
	        canvasContext,
	        viewport,
	        transform,
	        imageLayer,
	        background
	      },
	      objs: this.objs,
	      commonObjs: this.commonObjs,
	      operatorList: intentState.operatorList,
	      pageIndex: this._pageIndex,
	      canvasFactory: canvasFactoryInstance,
	      webGLContext,
	      useRequestAnimationFrame: renderingIntent !== "print",
	      pdfBug: this._pdfBug
	    });

	    if (!intentState.renderTasks) {
	      intentState.renderTasks = [];
	    }

	    intentState.renderTasks.push(internalRenderTask);
	    const renderTask = internalRenderTask.task;
	    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
	      if (this.pendingCleanup) {
	        complete();
	        return;
	      }

	      if (this._stats) {
	        this._stats.time("Rendering");
	      }

	      internalRenderTask.initializeGraphics({
	        transparency,
	        optionalContentConfig
	      });
	      internalRenderTask.operatorListChanged();
	    }).catch(complete);
	    return renderTask;
	  }

	  getOperatorList() {
	    function operatorListChanged() {
	      if (intentState.operatorList.lastChunk) {
	        intentState.opListReadCapability.resolve(intentState.operatorList);
	        const i = intentState.renderTasks.indexOf(opListTask);

	        if (i >= 0) {
	          intentState.renderTasks.splice(i, 1);
	        }
	      }
	    }

	    const renderingIntent = "oplist";

	    let intentState = this._intentStates.get(renderingIntent);

	    if (!intentState) {
	      intentState = Object.create(null);

	      this._intentStates.set(renderingIntent, intentState);
	    }

	    let opListTask;

	    if (!intentState.opListReadCapability) {
	      opListTask = Object.create(null);
	      opListTask.operatorListChanged = operatorListChanged;
	      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
	      intentState.renderTasks = [];
	      intentState.renderTasks.push(opListTask);
	      intentState.operatorList = {
	        fnArray: [],
	        argsArray: [],
	        lastChunk: false
	      };

	      if (this._stats) {
	        this._stats.time("Page Request");
	      }

	      this._pumpOperatorList({
	        pageIndex: this._pageIndex,
	        intent: renderingIntent
	      });
	    }

	    return intentState.opListReadCapability.promise;
	  }

	  streamTextContent({
	    normalizeWhitespace = false,
	    disableCombineTextItems = false
	  } = {}) {
	    const TEXT_CONTENT_CHUNK_SIZE = 100;
	    return this._transport.messageHandler.sendWithStream("GetTextContent", {
	      pageIndex: this._pageIndex,
	      normalizeWhitespace: normalizeWhitespace === true,
	      combineTextItems: disableCombineTextItems !== true
	    }, {
	      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,

	      size(textContent) {
	        return textContent.items.length;
	      }

	    });
	  }

	  getTextContent(params = {}) {
	    const readableStream = this.streamTextContent(params);
	    return new Promise(function (resolve, reject) {
	      function pump() {
	        reader.read().then(function ({
	          value,
	          done
	        }) {
	          if (done) {
	            resolve(textContent);
	            return;
	          }

	          Object.assign(textContent.styles, value.styles);
	          textContent.items.push(...value.items);
	          pump();
	        }, reject);
	      }

	      const reader = readableStream.getReader();
	      const textContent = {
	        items: [],
	        styles: Object.create(null)
	      };
	      pump();
	    });
	  }

	  _destroy() {
	    this.destroyed = true;
	    this._transport.pageCache[this._pageIndex] = null;
	    const waitOn = [];

	    for (const [intent, intentState] of this._intentStates) {
	      this._abortOperatorList({
	        intentState,
	        reason: new Error("Page was destroyed."),
	        force: true
	      });

	      if (intent === "oplist") {
	        continue;
	      }

	      for (const internalRenderTask of intentState.renderTasks) {
	        waitOn.push(internalRenderTask.completed);
	        internalRenderTask.cancel();
	      }
	    }

	    this.objs.clear();
	    this.annotationsPromise = null;
	    this._jsActionsPromise = null;
	    this.pendingCleanup = false;
	    return Promise.all(waitOn);
	  }

	  cleanup(resetStats = false) {
	    this.pendingCleanup = true;
	    return this._tryCleanup(resetStats);
	  }

	  _tryCleanup(resetStats = false) {
	    if (!this.pendingCleanup) {
	      return false;
	    }

	    for (const {
	      renderTasks,
	      operatorList
	    } of this._intentStates.values()) {
	      if (renderTasks.length !== 0 || !operatorList.lastChunk) {
	        return false;
	      }
	    }

	    this._intentStates.clear();

	    this.objs.clear();
	    this.annotationsPromise = null;
	    this._jsActionsPromise = null;

	    if (resetStats && this._stats) {
	      this._stats = new _display_utils.StatTimer();
	    }

	    this.pendingCleanup = false;
	    return true;
	  }

	  _startRenderPage(transparency, intent) {
	    const intentState = this._intentStates.get(intent);

	    if (!intentState) {
	      return;
	    }

	    if (this._stats) {
	      this._stats.timeEnd("Page Request");
	    }

	    if (intentState.displayReadyCapability) {
	      intentState.displayReadyCapability.resolve(transparency);
	    }
	  }

	  _renderPageChunk(operatorListChunk, intentState) {
	    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
	      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
	      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
	    }

	    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

	    for (let i = 0; i < intentState.renderTasks.length; i++) {
	      intentState.renderTasks[i].operatorListChanged();
	    }

	    if (operatorListChunk.lastChunk) {
	      this._tryCleanup();
	    }
	  }

	  _pumpOperatorList(args) {
	    (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');

	    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);

	    const reader = readableStream.getReader();

	    const intentState = this._intentStates.get(args.intent);

	    intentState.streamReader = reader;

	    const pump = () => {
	      reader.read().then(({
	        value,
	        done
	      }) => {
	        if (done) {
	          intentState.streamReader = null;
	          return;
	        }

	        if (this._transport.destroyed) {
	          return;
	        }

	        this._renderPageChunk(value, intentState);

	        pump();
	      }, reason => {
	        intentState.streamReader = null;

	        if (this._transport.destroyed) {
	          return;
	        }

	        if (intentState.operatorList) {
	          intentState.operatorList.lastChunk = true;

	          for (let i = 0; i < intentState.renderTasks.length; i++) {
	            intentState.renderTasks[i].operatorListChanged();
	          }

	          this._tryCleanup();
	        }

	        if (intentState.displayReadyCapability) {
	          intentState.displayReadyCapability.reject(reason);
	        } else if (intentState.opListReadCapability) {
	          intentState.opListReadCapability.reject(reason);
	        } else {
	          throw reason;
	        }
	      });
	    };

	    pump();
	  }

	  _abortOperatorList({
	    intentState,
	    reason,
	    force = false
	  }) {
	    (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');

	    if (!intentState.streamReader) {
	      return;
	    }

	    if (!force) {
	      if (intentState.renderTasks.length !== 0) {
	        return;
	      }

	      if (reason instanceof _display_utils.RenderingCancelledException) {
	        intentState.streamReaderCancelTimeout = setTimeout(() => {
	          this._abortOperatorList({
	            intentState,
	            reason,
	            force: true
	          });

	          intentState.streamReaderCancelTimeout = null;
	        }, RENDERING_CANCELLED_TIMEOUT);
	        return;
	      }
	    }

	    intentState.streamReader.cancel(new _util.AbortException(reason?.message));
	    intentState.streamReader = null;

	    if (this._transport.destroyed) {
	      return;
	    }

	    for (const [intent, curIntentState] of this._intentStates) {
	      if (curIntentState === intentState) {
	        this._intentStates.delete(intent);

	        break;
	      }
	    }

	    this.cleanup();
	  }

	  get stats() {
	    return this._stats;
	  }

	}

	exports.PDFPageProxy = PDFPageProxy;

	class LoopbackPort {
	  constructor() {
	    this._listeners = [];
	    this._deferred = Promise.resolve(undefined);
	  }

	  postMessage(obj, transfers) {
	    function cloneValue(value) {
	      if (typeof value !== "object" || value === null) {
	        return value;
	      }

	      if (cloned.has(value)) {
	        return cloned.get(value);
	      }

	      let buffer, result;

	      if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
	        if (transfers?.includes(buffer)) {
	          result = new value.constructor(buffer, value.byteOffset, value.byteLength);
	        } else {
	          result = new value.constructor(value);
	        }

	        cloned.set(value, result);
	        return result;
	      }

	      if (value instanceof Map) {
	        result = new Map();
	        cloned.set(value, result);

	        for (const [key, val] of value) {
	          result.set(key, cloneValue(val));
	        }

	        return result;
	      }

	      if (value instanceof Set) {
	        result = new Set();
	        cloned.set(value, result);

	        for (const val of value) {
	          result.add(cloneValue(val));
	        }

	        return result;
	      }

	      result = Array.isArray(value) ? [] : {};
	      cloned.set(value, result);

	      for (const i in value) {
	        let desc,
	            p = value;

	        while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
	          p = Object.getPrototypeOf(p);
	        }

	        if (typeof desc.value === "undefined") {
	          continue;
	        }

	        if (typeof desc.value === "function") {
	          if (value.hasOwnProperty?.(i)) {
	            throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);
	          }

	          continue;
	        }

	        result[i] = cloneValue(desc.value);
	      }

	      return result;
	    }

	    const cloned = new WeakMap();
	    const event = {
	      data: cloneValue(obj)
	    };

	    this._deferred.then(() => {
	      for (const listener of this._listeners) {
	        listener.call(this, event);
	      }
	    });
	  }

	  addEventListener(name, listener) {
	    this._listeners.push(listener);
	  }

	  removeEventListener(name, listener) {
	    const i = this._listeners.indexOf(listener);

	    this._listeners.splice(i, 1);
	  }

	  terminate() {
	    this._listeners.length = 0;
	  }

	}

	exports.LoopbackPort = LoopbackPort;

	const PDFWorker = function PDFWorkerClosure() {
	  const pdfWorkerPorts = new WeakMap();
	  let isWorkerDisabled = false;
	  let fallbackWorkerSrc;
	  let nextFakeWorkerId = 0;
	  let fakeWorkerCapability;

	  if (_is_node.isNodeJS && typeof commonjsRequire === "function") {
	    isWorkerDisabled = true;
	    fallbackWorkerSrc = "./pdf.worker.js";
	  } else if (typeof document === "object" && "currentScript" in document) {
	    const pdfjsFilePath = document.currentScript?.src;

	    if (pdfjsFilePath) {
	      fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
	    }
	  }

	  function getWorkerSrc() {
	    if (_worker_options.GlobalWorkerOptions.workerSrc) {
	      return _worker_options.GlobalWorkerOptions.workerSrc;
	    }

	    if (typeof fallbackWorkerSrc !== "undefined") {
	      if (!_is_node.isNodeJS) {
	        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
	      }

	      return fallbackWorkerSrc;
	    }

	    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
	  }

	  function getMainThreadWorkerMessageHandler() {
	    let mainWorkerMessageHandler;

	    try {
	      mainWorkerMessageHandler = globalThis.pdfjsWorker?.WorkerMessageHandler;
	    } catch (ex) {}

	    return mainWorkerMessageHandler || null;
	  }

	  function setupFakeWorkerGlobal() {
	    if (fakeWorkerCapability) {
	      return fakeWorkerCapability.promise;
	    }

	    fakeWorkerCapability = (0, _util.createPromiseCapability)();

	    const loader = async function () {
	      const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();

	      if (mainWorkerMessageHandler) {
	        return mainWorkerMessageHandler;
	      }

	      if (_is_node.isNodeJS && typeof commonjsRequire === "function") {
	        const worker = eval("require")(getWorkerSrc());
	        return worker.WorkerMessageHandler;
	      }

	      await (0, _display_utils.loadScript)(getWorkerSrc());
	      return window.pdfjsWorker.WorkerMessageHandler;
	    };

	    loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
	    return fakeWorkerCapability.promise;
	  }

	  function createCDNWrapper(url) {
	    const wrapper = "importScripts('" + url + "');";
	    return URL.createObjectURL(new Blob([wrapper]));
	  }

	  class PDFWorker {
	    constructor({
	      name = null,
	      port = null,
	      verbosity = (0, _util.getVerbosityLevel)()
	    } = {}) {
	      if (port && pdfWorkerPorts.has(port)) {
	        throw new Error("Cannot use more than one PDFWorker per port");
	      }

	      this.name = name;
	      this.destroyed = false;
	      this.postMessageTransfers = true;
	      this.verbosity = verbosity;
	      this._readyCapability = (0, _util.createPromiseCapability)();
	      this._port = null;
	      this._webWorker = null;
	      this._messageHandler = null;

	      if (port) {
	        pdfWorkerPorts.set(port, this);

	        this._initializeFromPort(port);

	        return;
	      }

	      this._initialize();
	    }

	    get promise() {
	      return this._readyCapability.promise;
	    }

	    get port() {
	      return this._port;
	    }

	    get messageHandler() {
	      return this._messageHandler;
	    }

	    _initializeFromPort(port) {
	      this._port = port;
	      this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

	      this._messageHandler.on("ready", function () {});

	      this._readyCapability.resolve();
	    }

	    _initialize() {
	      if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
	        let workerSrc = getWorkerSrc();

	        try {
	          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
	            workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
	          }

	          const worker = new Worker(workerSrc);
	          const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

	          const terminateEarly = () => {
	            worker.removeEventListener("error", onWorkerError);
	            messageHandler.destroy();
	            worker.terminate();

	            if (this.destroyed) {
	              this._readyCapability.reject(new Error("Worker was destroyed"));
	            } else {
	              this._setupFakeWorker();
	            }
	          };

	          const onWorkerError = () => {
	            if (!this._webWorker) {
	              terminateEarly();
	            }
	          };

	          worker.addEventListener("error", onWorkerError);
	          messageHandler.on("test", data => {
	            worker.removeEventListener("error", onWorkerError);

	            if (this.destroyed) {
	              terminateEarly();
	              return;
	            }

	            if (data) {
	              this._messageHandler = messageHandler;
	              this._port = worker;
	              this._webWorker = worker;

	              if (!data.supportTransfers) {
	                this.postMessageTransfers = false;
	              }

	              this._readyCapability.resolve();

	              messageHandler.send("configure", {
	                verbosity: this.verbosity
	              });
	            } else {
	              this._setupFakeWorker();

	              messageHandler.destroy();
	              worker.terminate();
	            }
	          });
	          messageHandler.on("ready", data => {
	            worker.removeEventListener("error", onWorkerError);

	            if (this.destroyed) {
	              terminateEarly();
	              return;
	            }

	            try {
	              sendTest();
	            } catch (e) {
	              this._setupFakeWorker();
	            }
	          });

	          const sendTest = () => {
	            const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);

	            try {
	              messageHandler.send("test", testObj, [testObj.buffer]);
	            } catch (ex) {
	              (0, _util.warn)("Cannot use postMessage transfers.");
	              testObj[0] = 0;
	              messageHandler.send("test", testObj);
	            }
	          };

	          sendTest();
	          return;
	        } catch (e) {
	          (0, _util.info)("The worker has been disabled.");
	        }
	      }

	      this._setupFakeWorker();
	    }

	    _setupFakeWorker() {
	      if (!isWorkerDisabled) {
	        (0, _util.warn)("Setting up fake worker.");
	        isWorkerDisabled = true;
	      }

	      setupFakeWorkerGlobal().then(WorkerMessageHandler => {
	        if (this.destroyed) {
	          this._readyCapability.reject(new Error("Worker was destroyed"));

	          return;
	        }

	        const port = new LoopbackPort();
	        this._port = port;
	        const id = "fake" + nextFakeWorkerId++;
	        const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
	        WorkerMessageHandler.setup(workerHandler, port);
	        const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
	        this._messageHandler = messageHandler;

	        this._readyCapability.resolve();

	        messageHandler.send("configure", {
	          verbosity: this.verbosity
	        });
	      }).catch(reason => {
	        this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
	      });
	    }

	    destroy() {
	      this.destroyed = true;

	      if (this._webWorker) {
	        this._webWorker.terminate();

	        this._webWorker = null;
	      }

	      pdfWorkerPorts.delete(this._port);
	      this._port = null;

	      if (this._messageHandler) {
	        this._messageHandler.destroy();

	        this._messageHandler = null;
	      }
	    }

	    static fromPort(params) {
	      if (!params || !params.port) {
	        throw new Error("PDFWorker.fromPort - invalid method signature.");
	      }

	      if (pdfWorkerPorts.has(params.port)) {
	        return pdfWorkerPorts.get(params.port);
	      }

	      return new PDFWorker(params);
	    }

	    static getWorkerSrc() {
	      return getWorkerSrc();
	    }

	  }

	  return PDFWorker;
	}();

	exports.PDFWorker = PDFWorker;

	class WorkerTransport {
	  constructor(messageHandler, loadingTask, networkStream, params) {
	    this.messageHandler = messageHandler;
	    this.loadingTask = loadingTask;
	    this.commonObjs = new PDFObjects();
	    this.fontLoader = new _font_loader.FontLoader({
	      docId: loadingTask.docId,
	      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
	      ownerDocument: params.ownerDocument
	    });
	    this._params = params;
	    this.CMapReaderFactory = new params.CMapReaderFactory({
	      baseUrl: params.cMapUrl,
	      isCompressed: params.cMapPacked
	    });
	    this.destroyed = false;
	    this.destroyCapability = null;
	    this._passwordCapability = null;
	    this._networkStream = networkStream;
	    this._fullReader = null;
	    this._lastProgress = null;
	    this.pageCache = [];
	    this.pagePromises = [];
	    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
	    this.setupMessageHandler();
	  }

	  get loadingTaskSettled() {
	    return this.loadingTask._capability.settled;
	  }

	  destroy() {
	    if (this.destroyCapability) {
	      return this.destroyCapability.promise;
	    }

	    this.destroyed = true;
	    this.destroyCapability = (0, _util.createPromiseCapability)();

	    if (this._passwordCapability) {
	      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
	    }

	    const waitOn = [];
	    this.pageCache.forEach(function (page) {
	      if (page) {
	        waitOn.push(page._destroy());
	      }
	    });
	    this.pageCache.length = 0;
	    this.pagePromises.length = 0;
	    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
	    waitOn.push(terminated);

	    if (this.loadingTaskSettled) {
	      const annotationStorageResetModified = this.loadingTask.promise.then(pdfDocument => {
	        if (pdfDocument.hasOwnProperty("annotationStorage")) {
	          pdfDocument.annotationStorage.resetModified();
	        }
	      }).catch(() => {});
	      waitOn.push(annotationStorageResetModified);
	    }

	    Promise.all(waitOn).then(() => {
	      this.commonObjs.clear();
	      this.fontLoader.clear();
	      this._hasJSActionsPromise = null;

	      if (this._networkStream) {
	        this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
	      }

	      if (this.messageHandler) {
	        this.messageHandler.destroy();
	        this.messageHandler = null;
	      }

	      this.destroyCapability.resolve();
	    }, this.destroyCapability.reject);
	    return this.destroyCapability.promise;
	  }

	  setupMessageHandler() {
	    const {
	      messageHandler,
	      loadingTask
	    } = this;
	    messageHandler.on("GetReader", (data, sink) => {
	      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
	      this._fullReader = this._networkStream.getFullReader();

	      this._fullReader.onProgress = evt => {
	        this._lastProgress = {
	          loaded: evt.loaded,
	          total: evt.total
	        };
	      };

	      sink.onPull = () => {
	        this._fullReader.read().then(function ({
	          value,
	          done
	        }) {
	          if (done) {
	            sink.close();
	            return;
	          }

	          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
	          sink.enqueue(new Uint8Array(value), 1, [value]);
	        }).catch(reason => {
	          sink.error(reason);
	        });
	      };

	      sink.onCancel = reason => {
	        this._fullReader.cancel(reason);

	        sink.ready.catch(readyReason => {
	          if (this.destroyed) {
	            return;
	          }

	          throw readyReason;
	        });
	      };
	    });
	    messageHandler.on("ReaderHeadersReady", data => {
	      const headersCapability = (0, _util.createPromiseCapability)();
	      const fullReader = this._fullReader;
	      fullReader.headersReady.then(() => {
	        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
	          if (this._lastProgress && loadingTask.onProgress) {
	            loadingTask.onProgress(this._lastProgress);
	          }

	          fullReader.onProgress = evt => {
	            if (loadingTask.onProgress) {
	              loadingTask.onProgress({
	                loaded: evt.loaded,
	                total: evt.total
	              });
	            }
	          };
	        }

	        headersCapability.resolve({
	          isStreamingSupported: fullReader.isStreamingSupported,
	          isRangeSupported: fullReader.isRangeSupported,
	          contentLength: fullReader.contentLength
	        });
	      }, headersCapability.reject);
	      return headersCapability.promise;
	    });
	    messageHandler.on("GetRangeReader", (data, sink) => {
	      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

	      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

	      if (!rangeReader) {
	        sink.close();
	        return;
	      }

	      sink.onPull = () => {
	        rangeReader.read().then(function ({
	          value,
	          done
	        }) {
	          if (done) {
	            sink.close();
	            return;
	          }

	          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
	          sink.enqueue(new Uint8Array(value), 1, [value]);
	        }).catch(reason => {
	          sink.error(reason);
	        });
	      };

	      sink.onCancel = reason => {
	        rangeReader.cancel(reason);
	        sink.ready.catch(readyReason => {
	          if (this.destroyed) {
	            return;
	          }

	          throw readyReason;
	        });
	      };
	    });
	    messageHandler.on("GetDoc", ({
	      pdfInfo
	    }) => {
	      this._numPages = pdfInfo.numPages;

	      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
	    });
	    messageHandler.on("DocException", function (ex) {
	      let reason;

	      switch (ex.name) {
	        case "PasswordException":
	          reason = new _util.PasswordException(ex.message, ex.code);
	          break;

	        case "InvalidPDFException":
	          reason = new _util.InvalidPDFException(ex.message);
	          break;

	        case "MissingPDFException":
	          reason = new _util.MissingPDFException(ex.message);
	          break;

	        case "UnexpectedResponseException":
	          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
	          break;

	        case "UnknownErrorException":
	          reason = new _util.UnknownErrorException(ex.message, ex.details);
	          break;
	      }

	      if (!(reason instanceof Error)) {
	        const msg = "DocException - expected a valid Error.";
	        (0, _util.warn)(msg);
	      }

	      loadingTask._capability.reject(reason);
	    });
	    messageHandler.on("PasswordRequest", exception => {
	      this._passwordCapability = (0, _util.createPromiseCapability)();

	      if (loadingTask.onPassword) {
	        const updatePassword = password => {
	          this._passwordCapability.resolve({
	            password
	          });
	        };

	        try {
	          loadingTask.onPassword(updatePassword, exception.code);
	        } catch (ex) {
	          this._passwordCapability.reject(ex);
	        }
	      } else {
	        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
	      }

	      return this._passwordCapability.promise;
	    });
	    messageHandler.on("DataLoaded", data => {
	      if (loadingTask.onProgress) {
	        loadingTask.onProgress({
	          loaded: data.length,
	          total: data.length
	        });
	      }

	      this.downloadInfoCapability.resolve(data);
	    });
	    messageHandler.on("StartRenderPage", data => {
	      if (this.destroyed) {
	        return;
	      }

	      const page = this.pageCache[data.pageIndex];

	      page._startRenderPage(data.transparency, data.intent);
	    });
	    messageHandler.on("commonobj", data => {
	      if (this.destroyed) {
	        return;
	      }

	      const [id, type, exportedData] = data;

	      if (this.commonObjs.has(id)) {
	        return;
	      }

	      switch (type) {
	        case "Font":
	          const params = this._params;

	          if ("error" in exportedData) {
	            const exportedError = exportedData.error;
	            (0, _util.warn)(`Error during font loading: ${exportedError}`);
	            this.commonObjs.resolve(id, exportedError);
	            break;
	          }

	          let fontRegistry = null;

	          if (params.pdfBug && globalThis.FontInspector?.enabled) {
	            fontRegistry = {
	              registerFont(font, url) {
	                globalThis.FontInspector.fontAdded(font, url);
	              }

	            };
	          }

	          const font = new _font_loader.FontFaceObject(exportedData, {
	            isEvalSupported: params.isEvalSupported,
	            disableFontFace: params.disableFontFace,
	            ignoreErrors: params.ignoreErrors,
	            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
	            fontRegistry
	          });
	          this.fontLoader.bind(font).catch(reason => {
	            return messageHandler.sendWithPromise("FontFallback", {
	              id
	            });
	          }).finally(() => {
	            if (!params.fontExtraProperties && font.data) {
	              font.data = null;
	            }

	            this.commonObjs.resolve(id, font);
	          });
	          break;

	        case "FontPath":
	        case "Image":
	          this.commonObjs.resolve(id, exportedData);
	          break;

	        default:
	          throw new Error(`Got unknown common object type ${type}`);
	      }
	    });
	    messageHandler.on("obj", data => {
	      if (this.destroyed) {
	        return undefined;
	      }

	      const [id, pageIndex, type, imageData] = data;
	      const pageProxy = this.pageCache[pageIndex];

	      if (pageProxy.objs.has(id)) {
	        return undefined;
	      }

	      switch (type) {
	        case "Image":
	          pageProxy.objs.resolve(id, imageData);
	          const MAX_IMAGE_SIZE_TO_STORE = 8000000;

	          if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {
	            pageProxy.cleanupAfterRender = true;
	          }

	          break;

	        default:
	          throw new Error(`Got unknown object type ${type}`);
	      }

	      return undefined;
	    });
	    messageHandler.on("DocProgress", data => {
	      if (this.destroyed) {
	        return;
	      }

	      if (loadingTask.onProgress) {
	        loadingTask.onProgress({
	          loaded: data.loaded,
	          total: data.total
	        });
	      }
	    });
	    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
	    messageHandler.on("FetchBuiltInCMap", (data, sink) => {
	      if (this.destroyed) {
	        sink.error(new Error("Worker was destroyed"));
	        return;
	      }

	      let fetched = false;

	      sink.onPull = () => {
	        if (fetched) {
	          sink.close();
	          return;
	        }

	        fetched = true;
	        this.CMapReaderFactory.fetch(data).then(function (builtInCMap) {
	          sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
	        }).catch(function (reason) {
	          sink.error(reason);
	        });
	      };
	    });
	  }

	  _onUnsupportedFeature({
	    featureId
	  }) {
	    if (this.destroyed) {
	      return;
	    }

	    if (this.loadingTask.onUnsupportedFeature) {
	      this.loadingTask.onUnsupportedFeature(featureId);
	    }
	  }

	  getData() {
	    return this.messageHandler.sendWithPromise("GetData", null);
	  }

	  getPage(pageNumber) {
	    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
	      return Promise.reject(new Error("Invalid page request"));
	    }

	    const pageIndex = pageNumber - 1;

	    if (pageIndex in this.pagePromises) {
	      return this.pagePromises[pageIndex];
	    }

	    const promise = this.messageHandler.sendWithPromise("GetPage", {
	      pageIndex
	    }).then(pageInfo => {
	      if (this.destroyed) {
	        throw new Error("Transport destroyed");
	      }

	      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
	      this.pageCache[pageIndex] = page;
	      return page;
	    });
	    this.pagePromises[pageIndex] = promise;
	    return promise;
	  }

	  getPageIndex(ref) {
	    return this.messageHandler.sendWithPromise("GetPageIndex", {
	      ref
	    }).catch(function (reason) {
	      return Promise.reject(new Error(reason));
	    });
	  }

	  getAnnotations(pageIndex, intent) {
	    return this.messageHandler.sendWithPromise("GetAnnotations", {
	      pageIndex,
	      intent
	    });
	  }

	  saveDocument(annotationStorage) {
	    return this.messageHandler.sendWithPromise("SaveDocument", {
	      numPages: this._numPages,
	      annotationStorage: annotationStorage?.serializable || null,
	      filename: this._fullReader?.filename ?? null
	    }).finally(() => {
	      if (annotationStorage) {
	        annotationStorage.resetModified();
	      }
	    });
	  }

	  getFieldObjects() {
	    return this.messageHandler.sendWithPromise("GetFieldObjects", null);
	  }

	  hasJSActions() {
	    return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
	  }

	  getCalculationOrderIds() {
	    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
	  }

	  getDestinations() {
	    return this.messageHandler.sendWithPromise("GetDestinations", null);
	  }

	  getDestination(id) {
	    if (typeof id !== "string") {
	      return Promise.reject(new Error("Invalid destination request."));
	    }

	    return this.messageHandler.sendWithPromise("GetDestination", {
	      id
	    });
	  }

	  getPageLabels() {
	    return this.messageHandler.sendWithPromise("GetPageLabels", null);
	  }

	  getPageLayout() {
	    return this.messageHandler.sendWithPromise("GetPageLayout", null);
	  }

	  getPageMode() {
	    return this.messageHandler.sendWithPromise("GetPageMode", null);
	  }

	  getViewerPreferences() {
	    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
	  }

	  getOpenAction() {
	    return this.messageHandler.sendWithPromise("GetOpenAction", null);
	  }

	  getAttachments() {
	    return this.messageHandler.sendWithPromise("GetAttachments", null);
	  }

	  getJavaScript() {
	    return this.messageHandler.sendWithPromise("GetJavaScript", null);
	  }

	  getDocJSActions() {
	    return this.messageHandler.sendWithPromise("GetDocJSActions", null);
	  }

	  getPageJSActions(pageIndex) {
	    return this.messageHandler.sendWithPromise("GetPageJSActions", {
	      pageIndex
	    });
	  }

	  getOutline() {
	    return this.messageHandler.sendWithPromise("GetOutline", null);
	  }

	  getOptionalContentConfig() {
	    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
	      return new _optional_content_config.OptionalContentConfig(results);
	    });
	  }

	  getPermissions() {
	    return this.messageHandler.sendWithPromise("GetPermissions", null);
	  }

	  getMetadata() {
	    return this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
	      return {
	        info: results[0],
	        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
	        contentDispositionFilename: this._fullReader?.filename ?? null,
	        contentLength: this._fullReader?.contentLength ?? null
	      };
	    });
	  }

	  getMarkInfo() {
	    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
	  }

	  getStats() {
	    return this.messageHandler.sendWithPromise("GetStats", null);
	  }

	  startCleanup() {
	    return this.messageHandler.sendWithPromise("Cleanup", null).then(() => {
	      for (let i = 0, ii = this.pageCache.length; i < ii; i++) {
	        const page = this.pageCache[i];

	        if (page) {
	          const cleanupSuccessful = page.cleanup();

	          if (!cleanupSuccessful) {
	            throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);
	          }
	        }
	      }

	      this.commonObjs.clear();
	      this.fontLoader.clear();
	      this._hasJSActionsPromise = null;
	    });
	  }

	  get loadingParams() {
	    const params = this._params;
	    return (0, _util.shadow)(this, "loadingParams", {
	      disableAutoFetch: params.disableAutoFetch,
	      disableFontFace: params.disableFontFace
	    });
	  }

	}

	class PDFObjects {
	  constructor() {
	    this._objs = Object.create(null);
	  }

	  _ensureObj(objId) {
	    if (this._objs[objId]) {
	      return this._objs[objId];
	    }

	    return this._objs[objId] = {
	      capability: (0, _util.createPromiseCapability)(),
	      data: null,
	      resolved: false
	    };
	  }

	  get(objId, callback = null) {
	    if (callback) {
	      this._ensureObj(objId).capability.promise.then(callback);

	      return null;
	    }

	    const obj = this._objs[objId];

	    if (!obj || !obj.resolved) {
	      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
	    }

	    return obj.data;
	  }

	  has(objId) {
	    const obj = this._objs[objId];
	    return obj?.resolved || false;
	  }

	  resolve(objId, data) {
	    const obj = this._ensureObj(objId);

	    obj.resolved = true;
	    obj.data = data;
	    obj.capability.resolve(data);
	  }

	  clear() {
	    this._objs = Object.create(null);
	  }

	}

	class RenderTask {
	  constructor(internalRenderTask) {
	    this._internalRenderTask = internalRenderTask;
	    this.onContinue = null;
	  }

	  get promise() {
	    return this._internalRenderTask.capability.promise;
	  }

	  cancel() {
	    this._internalRenderTask.cancel();
	  }

	}

	const InternalRenderTask = function InternalRenderTaskClosure() {
	  const canvasInRendering = new WeakSet();

	  class InternalRenderTask {
	    constructor({
	      callback,
	      params,
	      objs,
	      commonObjs,
	      operatorList,
	      pageIndex,
	      canvasFactory,
	      webGLContext,
	      useRequestAnimationFrame = false,
	      pdfBug = false
	    }) {
	      this.callback = callback;
	      this.params = params;
	      this.objs = objs;
	      this.commonObjs = commonObjs;
	      this.operatorListIdx = null;
	      this.operatorList = operatorList;
	      this._pageIndex = pageIndex;
	      this.canvasFactory = canvasFactory;
	      this.webGLContext = webGLContext;
	      this._pdfBug = pdfBug;
	      this.running = false;
	      this.graphicsReadyCallback = null;
	      this.graphicsReady = false;
	      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
	      this.cancelled = false;
	      this.capability = (0, _util.createPromiseCapability)();
	      this.task = new RenderTask(this);
	      this._cancelBound = this.cancel.bind(this);
	      this._continueBound = this._continue.bind(this);
	      this._scheduleNextBound = this._scheduleNext.bind(this);
	      this._nextBound = this._next.bind(this);
	      this._canvas = params.canvasContext.canvas;
	    }

	    get completed() {
	      return this.capability.promise.catch(function () {});
	    }

	    initializeGraphics({
	      transparency = false,
	      optionalContentConfig
	    }) {
	      if (this.cancelled) {
	        return;
	      }

	      if (this._canvas) {
	        if (canvasInRendering.has(this._canvas)) {
	          throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
	        }

	        canvasInRendering.add(this._canvas);
	      }

	      if (this._pdfBug && globalThis.StepperManager?.enabled) {
	        this.stepper = globalThis.StepperManager.create(this._pageIndex);
	        this.stepper.init(this.operatorList);
	        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
	      }

	      const {
	        canvasContext,
	        viewport,
	        transform,
	        imageLayer,
	        background
	      } = this.params;
	      this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);
	      this.gfx.beginDrawing({
	        transform,
	        viewport,
	        transparency,
	        background
	      });
	      this.operatorListIdx = 0;
	      this.graphicsReady = true;

	      if (this.graphicsReadyCallback) {
	        this.graphicsReadyCallback();
	      }
	    }

	    cancel(error = null) {
	      this.running = false;
	      this.cancelled = true;

	      if (this.gfx) {
	        this.gfx.endDrawing();
	      }

	      if (this._canvas) {
	        canvasInRendering.delete(this._canvas);
	      }

	      this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
	    }

	    operatorListChanged() {
	      if (!this.graphicsReady) {
	        if (!this.graphicsReadyCallback) {
	          this.graphicsReadyCallback = this._continueBound;
	        }

	        return;
	      }

	      if (this.stepper) {
	        this.stepper.updateOperatorList(this.operatorList);
	      }

	      if (this.running) {
	        return;
	      }

	      this._continue();
	    }

	    _continue() {
	      this.running = true;

	      if (this.cancelled) {
	        return;
	      }

	      if (this.task.onContinue) {
	        this.task.onContinue(this._scheduleNextBound);
	      } else {
	        this._scheduleNext();
	      }
	    }

	    _scheduleNext() {
	      if (this._useRequestAnimationFrame) {
	        window.requestAnimationFrame(() => {
	          this._nextBound().catch(this._cancelBound);
	        });
	      } else {
	        Promise.resolve().then(this._nextBound).catch(this._cancelBound);
	      }
	    }

	    async _next() {
	      if (this.cancelled) {
	        return;
	      }

	      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

	      if (this.operatorListIdx === this.operatorList.argsArray.length) {
	        this.running = false;

	        if (this.operatorList.lastChunk) {
	          this.gfx.endDrawing();

	          if (this._canvas) {
	            canvasInRendering.delete(this._canvas);
	          }

	          this.callback();
	        }
	      }
	    }

	  }

	  return InternalRenderTask;
	}();

	const version = '2.8.188';
	exports.version = version;
	const build = '5e3af62d5';
	exports.build = build;

	/***/ }),
	/* 6 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.FontLoader = exports.FontFaceObject = void 0;

	var _util = __w_pdfjs_require__(2);

	class BaseFontLoader {
	  constructor({
	    docId,
	    onUnsupportedFeature,
	    ownerDocument = globalThis.document
	  }) {
	    if (this.constructor === BaseFontLoader) {
	      (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
	    }

	    this.docId = docId;
	    this._onUnsupportedFeature = onUnsupportedFeature;
	    this._document = ownerDocument;
	    this.nativeFontFaces = [];
	    this.styleElement = null;
	  }

	  addNativeFontFace(nativeFontFace) {
	    this.nativeFontFaces.push(nativeFontFace);

	    this._document.fonts.add(nativeFontFace);
	  }

	  insertRule(rule) {
	    let styleElement = this.styleElement;

	    if (!styleElement) {
	      styleElement = this.styleElement = this._document.createElement("style");
	      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;

	      this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
	    }

	    const styleSheet = styleElement.sheet;
	    styleSheet.insertRule(rule, styleSheet.cssRules.length);
	  }

	  clear() {
	    this.nativeFontFaces.forEach(nativeFontFace => {
	      this._document.fonts.delete(nativeFontFace);
	    });
	    this.nativeFontFaces.length = 0;

	    if (this.styleElement) {
	      this.styleElement.remove();
	      this.styleElement = null;
	    }
	  }

	  async bind(font) {
	    if (font.attached || font.missingFile) {
	      return;
	    }

	    font.attached = true;

	    if (this.isFontLoadingAPISupported) {
	      const nativeFontFace = font.createNativeFontFace();

	      if (nativeFontFace) {
	        this.addNativeFontFace(nativeFontFace);

	        try {
	          await nativeFontFace.loaded;
	        } catch (ex) {
	          this._onUnsupportedFeature({
	            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
	          });

	          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
	          font.disableFontFace = true;
	          throw ex;
	        }
	      }

	      return;
	    }

	    const rule = font.createFontFaceRule();

	    if (rule) {
	      this.insertRule(rule);

	      if (this.isSyncFontLoadingSupported) {
	        return;
	      }

	      await new Promise(resolve => {
	        const request = this._queueLoadingCallback(resolve);

	        this._prepareFontLoadEvent([rule], [font], request);
	      });
	    }
	  }

	  _queueLoadingCallback(callback) {
	    (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
	  }

	  get isFontLoadingAPISupported() {
	    return (0, _util.shadow)(this, "isFontLoadingAPISupported", !!this._document?.fonts);
	  }

	  get isSyncFontLoadingSupported() {
	    (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
	  }

	  get _loadTestFont() {
	    (0, _util.unreachable)("Abstract method `_loadTestFont`.");
	  }

	  _prepareFontLoadEvent(rules, fontsToLoad, request) {
	    (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
	  }

	}

	let FontLoader;
	exports.FontLoader = FontLoader;
	{
	  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
	    constructor(params) {
	      super(params);
	      this.loadingContext = {
	        requests: [],
	        nextRequestId: 0
	      };
	      this.loadTestFontId = 0;
	    }

	    get isSyncFontLoadingSupported() {
	      let supported = false;

	      if (typeof navigator === "undefined") {
	        supported = true;
	      } else {
	        const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

	        if (m?.[1] >= 14) {
	          supported = true;
	        }
	      }

	      return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
	    }

	    _queueLoadingCallback(callback) {
	      function completeRequest() {
	        (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
	        request.done = true;

	        while (context.requests.length > 0 && context.requests[0].done) {
	          const otherRequest = context.requests.shift();
	          setTimeout(otherRequest.callback, 0);
	        }
	      }

	      const context = this.loadingContext;
	      const request = {
	        id: `pdfjs-font-loading-${context.nextRequestId++}`,
	        done: false,
	        complete: completeRequest,
	        callback
	      };
	      context.requests.push(request);
	      return request;
	    }

	    get _loadTestFont() {
	      const getLoadTestFont = function () {
	        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
	      };

	      return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
	    }

	    _prepareFontLoadEvent(rules, fonts, request) {
	      function int32(data, offset) {
	        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
	      }

	      function spliceString(s, offset, remove, insert) {
	        const chunk1 = s.substring(0, offset);
	        const chunk2 = s.substring(offset + remove);
	        return chunk1 + insert + chunk2;
	      }

	      let i, ii;

	      const canvas = this._document.createElement("canvas");

	      canvas.width = 1;
	      canvas.height = 1;
	      const ctx = canvas.getContext("2d");
	      let called = 0;

	      function isFontReady(name, callback) {
	        called++;

	        if (called > 30) {
	          (0, _util.warn)("Load test font never loaded.");
	          callback();
	          return;
	        }

	        ctx.font = "30px " + name;
	        ctx.fillText(".", 0, 20);
	        const imageData = ctx.getImageData(0, 0, 1, 1);

	        if (imageData.data[3] > 0) {
	          callback();
	          return;
	        }

	        setTimeout(isFontReady.bind(null, name, callback));
	      }

	      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
	      let data = this._loadTestFont;
	      const COMMENT_OFFSET = 976;
	      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
	      const CFF_CHECKSUM_OFFSET = 16;
	      const XXXX_VALUE = 0x58585858;
	      let checksum = int32(data, CFF_CHECKSUM_OFFSET);

	      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
	        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
	      }

	      if (i < loadTestFontId.length) {
	        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
	      }

	      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
	      const url = `url(data:font/opentype;base64,${btoa(data)});`;
	      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
	      this.insertRule(rule);
	      const names = [];

	      for (i = 0, ii = fonts.length; i < ii; i++) {
	        names.push(fonts[i].loadedName);
	      }

	      names.push(loadTestFontId);

	      const div = this._document.createElement("div");

	      div.style.visibility = "hidden";
	      div.style.width = div.style.height = "10px";
	      div.style.position = "absolute";
	      div.style.top = div.style.left = "0px";

	      for (i = 0, ii = names.length; i < ii; ++i) {
	        const span = this._document.createElement("span");

	        span.textContent = "Hi";
	        span.style.fontFamily = names[i];
	        div.appendChild(span);
	      }

	      this._document.body.appendChild(div);

	      isFontReady(loadTestFontId, () => {
	        this._document.body.removeChild(div);

	        request.complete();
	      });
	    }

	  };
	}

	class FontFaceObject {
	  constructor(translatedData, {
	    isEvalSupported = true,
	    disableFontFace = false,
	    ignoreErrors = false,
	    onUnsupportedFeature,
	    fontRegistry = null
	  }) {
	    this.compiledGlyphs = Object.create(null);

	    for (const i in translatedData) {
	      this[i] = translatedData[i];
	    }

	    this.isEvalSupported = isEvalSupported !== false;
	    this.disableFontFace = disableFontFace === true;
	    this.ignoreErrors = ignoreErrors === true;
	    this._onUnsupportedFeature = onUnsupportedFeature;
	    this.fontRegistry = fontRegistry;
	  }

	  createNativeFontFace() {
	    if (!this.data || this.disableFontFace) {
	      return null;
	    }

	    const nativeFontFace = new FontFace(this.loadedName, this.data, {});

	    if (this.fontRegistry) {
	      this.fontRegistry.registerFont(this);
	    }

	    return nativeFontFace;
	  }

	  createFontFaceRule() {
	    if (!this.data || this.disableFontFace) {
	      return null;
	    }

	    const data = (0, _util.bytesToString)(new Uint8Array(this.data));
	    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
	    const rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;

	    if (this.fontRegistry) {
	      this.fontRegistry.registerFont(this, url);
	    }

	    return rule;
	  }

	  getPathGenerator(objs, character) {
	    if (this.compiledGlyphs[character] !== undefined) {
	      return this.compiledGlyphs[character];
	    }

	    let cmds, current;

	    try {
	      cmds = objs.get(this.loadedName + "_path_" + character);
	    } catch (ex) {
	      if (!this.ignoreErrors) {
	        throw ex;
	      }

	      this._onUnsupportedFeature({
	        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
	      });

	      (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
	      return this.compiledGlyphs[character] = function (c, size) {};
	    }

	    if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {
	      let args,
	          js = "";

	      for (let i = 0, ii = cmds.length; i < ii; i++) {
	        current = cmds[i];

	        if (current.args !== undefined) {
	          args = current.args.join(",");
	        } else {
	          args = "";
	        }

	        js += "c." + current.cmd + "(" + args + ");\n";
	      }

	      return this.compiledGlyphs[character] = new Function("c", "size", js);
	    }

	    return this.compiledGlyphs[character] = function (c, size) {
	      for (let i = 0, ii = cmds.length; i < ii; i++) {
	        current = cmds[i];

	        if (current.cmd === "scale") {
	          current.args = [size, -size];
	        }

	        c[current.cmd].apply(c, current.args);
	      }
	    };
	  }

	}

	exports.FontFaceObject = FontFaceObject;

	/***/ }),
	/* 7 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;

	var _display_utils = __w_pdfjs_require__(1);

	var _is_node = __w_pdfjs_require__(4);

	var _util = __w_pdfjs_require__(2);

	let NodeCanvasFactory = class {
	  constructor() {
	    (0, _util.unreachable)("Not implemented: NodeCanvasFactory");
	  }

	};
	exports.NodeCanvasFactory = NodeCanvasFactory;
	let NodeCMapReaderFactory = class {
	  constructor() {
	    (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory");
	  }

	};
	exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

	if (_is_node.isNodeJS) {
	  exports.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils.BaseCanvasFactory {
	    create(width, height) {
	      if (width <= 0 || height <= 0) {
	        throw new Error("Invalid canvas size");
	      }

	      const Canvas = require$$0__default['default'];

	      const canvas = Canvas.createCanvas(width, height);
	      return {
	        canvas,
	        context: canvas.getContext("2d")
	      };
	    }

	  };
	  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils.BaseCMapReaderFactory {
	    _fetchData(url, compressionType) {
	      return new Promise((resolve, reject) => {
	        const fs = require$$1__default['default'];

	        fs.readFile(url, (error, data) => {
	          if (error || !data) {
	            reject(new Error(error));
	            return;
	          }

	          resolve({
	            cMapData: new Uint8Array(data),
	            compressionType
	          });
	        });
	      });
	    }

	  };
	}

	/***/ }),
	/* 8 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.AnnotationStorage = void 0;

	var _display_utils = __w_pdfjs_require__(1);

	var _util = __w_pdfjs_require__(2);

	class AnnotationStorage {
	  constructor() {
	    this._storage = new Map();
	    this._modified = false;
	    this.onSetModified = null;
	    this.onResetModified = null;
	  }

	  getValue(key, defaultValue) {
	    if (this._storage.has(key)) {
	      return this._storage.get(key);
	    }

	    return defaultValue;
	  }

	  getOrCreateValue(key, defaultValue) {
	    (0, _display_utils.deprecated)("Use getValue instead.");

	    if (this._storage.has(key)) {
	      return this._storage.get(key);
	    }

	    this._storage.set(key, defaultValue);

	    return defaultValue;
	  }

	  setValue(key, value) {
	    const obj = this._storage.get(key);

	    let modified = false;

	    if (obj !== undefined) {
	      for (const [entry, val] of Object.entries(value)) {
	        if (obj[entry] !== val) {
	          modified = true;
	          obj[entry] = val;
	        }
	      }
	    } else {
	      this._storage.set(key, value);

	      modified = true;
	    }

	    if (modified) {
	      this._setModified();
	    }
	  }

	  getAll() {
	    return this._storage.size > 0 ? (0, _util.objectFromEntries)(this._storage) : null;
	  }

	  get size() {
	    return this._storage.size;
	  }

	  _setModified() {
	    if (!this._modified) {
	      this._modified = true;

	      if (typeof this.onSetModified === "function") {
	        this.onSetModified();
	      }
	    }
	  }

	  resetModified() {
	    if (this._modified) {
	      this._modified = false;

	      if (typeof this.onResetModified === "function") {
	        this.onResetModified();
	      }
	    }
	  }

	  get serializable() {
	    return this._storage.size > 0 ? this._storage : null;
	  }

	}

	exports.AnnotationStorage = AnnotationStorage;

	/***/ }),
	/* 9 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.apiCompatibilityParams = void 0;

	var _is_node = __w_pdfjs_require__(4);

	const compatibilityParams = Object.create(null);
	{
	  (function checkFontFace() {
	    if (_is_node.isNodeJS) {
	      compatibilityParams.disableFontFace = true;
	    }
	  })();
	}
	const apiCompatibilityParams = Object.freeze(compatibilityParams);
	exports.apiCompatibilityParams = apiCompatibilityParams;

	/***/ }),
	/* 10 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.CanvasGraphics = void 0;

	var _util = __w_pdfjs_require__(2);

	var _pattern_helper = __w_pdfjs_require__(11);

	const MIN_FONT_SIZE = 16;
	const MAX_FONT_SIZE = 100;
	const MAX_GROUP_SIZE = 4096;
	const MAX_SIZE_TO_COMPILE = 1000;
	const FULL_CHUNK_HEIGHT = 16;

	function addContextCurrentTransform(ctx) {
	  if (!ctx.mozCurrentTransform) {
	    ctx._originalSave = ctx.save;
	    ctx._originalRestore = ctx.restore;
	    ctx._originalRotate = ctx.rotate;
	    ctx._originalScale = ctx.scale;
	    ctx._originalTranslate = ctx.translate;
	    ctx._originalTransform = ctx.transform;
	    ctx._originalSetTransform = ctx.setTransform;
	    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
	    ctx._transformStack = [];
	    Object.defineProperty(ctx, "mozCurrentTransform", {
	      get: function getCurrentTransform() {
	        return this._transformMatrix;
	      }
	    });
	    Object.defineProperty(ctx, "mozCurrentTransformInverse", {
	      get: function getCurrentTransformInverse() {
	        const m = this._transformMatrix;
	        const a = m[0],
	              b = m[1],
	              c = m[2],
	              d = m[3],
	              e = m[4],
	              f = m[5];
	        const ad_bc = a * d - b * c;
	        const bc_ad = b * c - a * d;
	        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
	      }
	    });

	    ctx.save = function ctxSave() {
	      const old = this._transformMatrix;

	      this._transformStack.push(old);

	      this._transformMatrix = old.slice(0, 6);

	      this._originalSave();
	    };

	    ctx.restore = function ctxRestore() {
	      const prev = this._transformStack.pop();

	      if (prev) {
	        this._transformMatrix = prev;

	        this._originalRestore();
	      }
	    };

	    ctx.translate = function ctxTranslate(x, y) {
	      const m = this._transformMatrix;
	      m[4] = m[0] * x + m[2] * y + m[4];
	      m[5] = m[1] * x + m[3] * y + m[5];

	      this._originalTranslate(x, y);
	    };

	    ctx.scale = function ctxScale(x, y) {
	      const m = this._transformMatrix;
	      m[0] = m[0] * x;
	      m[1] = m[1] * x;
	      m[2] = m[2] * y;
	      m[3] = m[3] * y;

	      this._originalScale(x, y);
	    };

	    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
	      const m = this._transformMatrix;
	      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

	      ctx._originalTransform(a, b, c, d, e, f);
	    };

	    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
	      this._transformMatrix = [a, b, c, d, e, f];

	      ctx._originalSetTransform(a, b, c, d, e, f);
	    };

	    ctx.rotate = function ctxRotate(angle) {
	      const cosValue = Math.cos(angle);
	      const sinValue = Math.sin(angle);
	      const m = this._transformMatrix;
	      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

	      this._originalRotate(angle);
	    };
	  }
	}

	const CachedCanvases = function CachedCanvasesClosure() {
	  function CachedCanvases(canvasFactory) {
	    this.canvasFactory = canvasFactory;
	    this.cache = Object.create(null);
	  }

	  CachedCanvases.prototype = {
	    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
	      let canvasEntry;

	      if (this.cache[id] !== undefined) {
	        canvasEntry = this.cache[id];
	        this.canvasFactory.reset(canvasEntry, width, height);
	        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
	      } else {
	        canvasEntry = this.canvasFactory.create(width, height);
	        this.cache[id] = canvasEntry;
	      }

	      if (trackTransform) {
	        addContextCurrentTransform(canvasEntry.context);
	      }

	      return canvasEntry;
	    },

	    clear() {
	      for (const id in this.cache) {
	        const canvasEntry = this.cache[id];
	        this.canvasFactory.destroy(canvasEntry);
	        delete this.cache[id];
	      }
	    }

	  };
	  return CachedCanvases;
	}();

	function compileType3Glyph(imgData) {
	  const POINT_TO_PROCESS_LIMIT = 1000;
	  const width = imgData.width,
	        height = imgData.height,
	        width1 = width + 1;
	  let i, ii, j, j0;
	  const points = new Uint8Array(width1 * (height + 1));
	  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
	  const lineSize = width + 7 & ~7,
	        data0 = imgData.data;
	  const data = new Uint8Array(lineSize * height);
	  let pos = 0;

	  for (i = 0, ii = data0.length; i < ii; i++) {
	    const elem = data0[i];
	    let mask = 128;

	    while (mask > 0) {
	      data[pos++] = elem & mask ? 0 : 255;
	      mask >>= 1;
	    }
	  }

	  let count = 0;
	  pos = 0;

	  if (data[pos] !== 0) {
	    points[0] = 1;
	    ++count;
	  }

	  for (j = 1; j < width; j++) {
	    if (data[pos] !== data[pos + 1]) {
	      points[j] = data[pos] ? 2 : 1;
	      ++count;
	    }

	    pos++;
	  }

	  if (data[pos] !== 0) {
	    points[j] = 2;
	    ++count;
	  }

	  for (i = 1; i < height; i++) {
	    pos = i * lineSize;
	    j0 = i * width1;

	    if (data[pos - lineSize] !== data[pos]) {
	      points[j0] = data[pos] ? 1 : 8;
	      ++count;
	    }

	    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

	    for (j = 1; j < width; j++) {
	      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

	      if (POINT_TYPES[sum]) {
	        points[j0 + j] = POINT_TYPES[sum];
	        ++count;
	      }

	      pos++;
	    }

	    if (data[pos - lineSize] !== data[pos]) {
	      points[j0 + j] = data[pos] ? 2 : 4;
	      ++count;
	    }

	    if (count > POINT_TO_PROCESS_LIMIT) {
	      return null;
	    }
	  }

	  pos = lineSize * (height - 1);
	  j0 = i * width1;

	  if (data[pos] !== 0) {
	    points[j0] = 8;
	    ++count;
	  }

	  for (j = 1; j < width; j++) {
	    if (data[pos] !== data[pos + 1]) {
	      points[j0 + j] = data[pos] ? 4 : 8;
	      ++count;
	    }

	    pos++;
	  }

	  if (data[pos] !== 0) {
	    points[j0 + j] = 4;
	    ++count;
	  }

	  if (count > POINT_TO_PROCESS_LIMIT) {
	    return null;
	  }

	  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
	  const outlines = [];

	  for (i = 0; count && i <= height; i++) {
	    let p = i * width1;
	    const end = p + width;

	    while (p < end && !points[p]) {
	      p++;
	    }

	    if (p === end) {
	      continue;
	    }

	    const coords = [p % width1, i];
	    const p0 = p;
	    let type = points[p];

	    do {
	      const step = steps[type];

	      do {
	        p += step;
	      } while (!points[p]);

	      const pp = points[p];

	      if (pp !== 5 && pp !== 10) {
	        type = pp;
	        points[p] = 0;
	      } else {
	        type = pp & 0x33 * type >> 4;
	        points[p] &= type >> 2 | type << 2;
	      }

	      coords.push(p % width1);
	      coords.push(p / width1 | 0);

	      if (!points[p]) {
	        --count;
	      }
	    } while (p0 !== p);

	    outlines.push(coords);
	    --i;
	  }

	  const drawOutline = function (c) {
	    c.save();
	    c.scale(1 / width, -1 / height);
	    c.translate(0, -height);
	    c.beginPath();

	    for (let k = 0, kk = outlines.length; k < kk; k++) {
	      const o = outlines[k];
	      c.moveTo(o[0], o[1]);

	      for (let l = 2, ll = o.length; l < ll; l += 2) {
	        c.lineTo(o[l], o[l + 1]);
	      }
	    }

	    c.fill();
	    c.beginPath();
	    c.restore();
	  };

	  return drawOutline;
	}

	const CanvasExtraState = function CanvasExtraStateClosure() {
	  function CanvasExtraState() {
	    this.alphaIsShape = false;
	    this.fontSize = 0;
	    this.fontSizeScale = 1;
	    this.textMatrix = _util.IDENTITY_MATRIX;
	    this.textMatrixScale = 1;
	    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
	    this.leading = 0;
	    this.x = 0;
	    this.y = 0;
	    this.lineX = 0;
	    this.lineY = 0;
	    this.charSpacing = 0;
	    this.wordSpacing = 0;
	    this.textHScale = 1;
	    this.textRenderingMode = _util.TextRenderingMode.FILL;
	    this.textRise = 0;
	    this.fillColor = "#000000";
	    this.strokeColor = "#000000";
	    this.patternFill = false;
	    this.fillAlpha = 1;
	    this.strokeAlpha = 1;
	    this.lineWidth = 1;
	    this.activeSMask = null;
	    this.resumeSMaskCtx = null;
	    this.transferMaps = null;
	  }

	  CanvasExtraState.prototype = {
	    clone: function CanvasExtraState_clone() {
	      return Object.create(this);
	    },
	    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
	      this.x = x;
	      this.y = y;
	    }
	  };
	  return CanvasExtraState;
	}();

	const CanvasGraphics = function CanvasGraphicsClosure() {
	  const EXECUTION_TIME = 15;
	  const EXECUTION_STEPS = 10;

	  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {
	    this.ctx = canvasCtx;
	    this.current = new CanvasExtraState();
	    this.stateStack = [];
	    this.pendingClip = null;
	    this.pendingEOFill = false;
	    this.res = null;
	    this.xobjs = null;
	    this.commonObjs = commonObjs;
	    this.objs = objs;
	    this.canvasFactory = canvasFactory;
	    this.webGLContext = webGLContext;
	    this.imageLayer = imageLayer;
	    this.groupStack = [];
	    this.processingType3 = null;
	    this.baseTransform = null;
	    this.baseTransformStack = [];
	    this.groupLevel = 0;
	    this.smaskStack = [];
	    this.smaskCounter = 0;
	    this.tempSMask = null;
	    this.contentVisible = true;
	    this.markedContentStack = [];
	    this.optionalContentConfig = optionalContentConfig;
	    this.cachedCanvases = new CachedCanvases(this.canvasFactory);

	    if (canvasCtx) {
	      addContextCurrentTransform(canvasCtx);
	    }

	    this._cachedGetSinglePixelWidth = null;
	  }

	  function putBinaryImageData(ctx, imgData, transferMaps = null) {
	    if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
	      ctx.putImageData(imgData, 0, 0);
	      return;
	    }

	    const height = imgData.height,
	          width = imgData.width;
	    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
	    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
	    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
	    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
	    let srcPos = 0,
	        destPos;
	    const src = imgData.data;
	    const dest = chunkImgData.data;
	    let i, j, thisChunkHeight, elemsInThisChunk;
	    let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

	    if (transferMaps) {
	      switch (transferMaps.length) {
	        case 1:
	          transferMapRed = transferMaps[0];
	          transferMapGreen = transferMaps[0];
	          transferMapBlue = transferMaps[0];
	          transferMapGray = transferMaps[0];
	          break;

	        case 4:
	          transferMapRed = transferMaps[0];
	          transferMapGreen = transferMaps[1];
	          transferMapBlue = transferMaps[2];
	          transferMapGray = transferMaps[3];
	          break;
	      }
	    }

	    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
	      const srcLength = src.byteLength;
	      const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
	      const dest32DataLength = dest32.length;
	      const fullSrcDiff = width + 7 >> 3;
	      let white = 0xffffffff;
	      let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;

	      if (transferMapGray) {
	        if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
	          [white, black] = [black, white];
	        }
	      }

	      for (i = 0; i < totalChunks; i++) {
	        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
	        destPos = 0;

	        for (j = 0; j < thisChunkHeight; j++) {
	          const srcDiff = srcLength - srcPos;
	          let k = 0;
	          const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
	          const kEndUnrolled = kEnd & ~7;
	          let mask = 0;
	          let srcByte = 0;

	          for (; k < kEndUnrolled; k += 8) {
	            srcByte = src[srcPos++];
	            dest32[destPos++] = srcByte & 128 ? white : black;
	            dest32[destPos++] = srcByte & 64 ? white : black;
	            dest32[destPos++] = srcByte & 32 ? white : black;
	            dest32[destPos++] = srcByte & 16 ? white : black;
	            dest32[destPos++] = srcByte & 8 ? white : black;
	            dest32[destPos++] = srcByte & 4 ? white : black;
	            dest32[destPos++] = srcByte & 2 ? white : black;
	            dest32[destPos++] = srcByte & 1 ? white : black;
	          }

	          for (; k < kEnd; k++) {
	            if (mask === 0) {
	              srcByte = src[srcPos++];
	              mask = 128;
	            }

	            dest32[destPos++] = srcByte & mask ? white : black;
	            mask >>= 1;
	          }
	        }

	        while (destPos < dest32DataLength) {
	          dest32[destPos++] = 0;
	        }

	        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
	      }
	    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
	      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
	      j = 0;
	      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

	      for (i = 0; i < fullChunks; i++) {
	        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
	        srcPos += elemsInThisChunk;

	        if (hasTransferMaps) {
	          for (let k = 0; k < elemsInThisChunk; k += 4) {
	            if (transferMapRed) {
	              dest[k + 0] = transferMapRed[dest[k + 0]];
	            }

	            if (transferMapGreen) {
	              dest[k + 1] = transferMapGreen[dest[k + 1]];
	            }

	            if (transferMapBlue) {
	              dest[k + 2] = transferMapBlue[dest[k + 2]];
	            }
	          }
	        }

	        ctx.putImageData(chunkImgData, 0, j);
	        j += FULL_CHUNK_HEIGHT;
	      }

	      if (i < totalChunks) {
	        elemsInThisChunk = width * partialChunkHeight * 4;
	        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

	        if (hasTransferMaps) {
	          for (let k = 0; k < elemsInThisChunk; k += 4) {
	            if (transferMapRed) {
	              dest[k + 0] = transferMapRed[dest[k + 0]];
	            }

	            if (transferMapGreen) {
	              dest[k + 1] = transferMapGreen[dest[k + 1]];
	            }

	            if (transferMapBlue) {
	              dest[k + 2] = transferMapBlue[dest[k + 2]];
	            }
	          }
	        }

	        ctx.putImageData(chunkImgData, 0, j);
	      }
	    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
	      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
	      thisChunkHeight = FULL_CHUNK_HEIGHT;
	      elemsInThisChunk = width * thisChunkHeight;

	      for (i = 0; i < totalChunks; i++) {
	        if (i >= fullChunks) {
	          thisChunkHeight = partialChunkHeight;
	          elemsInThisChunk = width * thisChunkHeight;
	        }

	        destPos = 0;

	        for (j = elemsInThisChunk; j--;) {
	          dest[destPos++] = src[srcPos++];
	          dest[destPos++] = src[srcPos++];
	          dest[destPos++] = src[srcPos++];
	          dest[destPos++] = 255;
	        }

	        if (hasTransferMaps) {
	          for (let k = 0; k < destPos; k += 4) {
	            if (transferMapRed) {
	              dest[k + 0] = transferMapRed[dest[k + 0]];
	            }

	            if (transferMapGreen) {
	              dest[k + 1] = transferMapGreen[dest[k + 1]];
	            }

	            if (transferMapBlue) {
	              dest[k + 2] = transferMapBlue[dest[k + 2]];
	            }
	          }
	        }

	        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
	      }
	    } else {
	      throw new Error(`bad image kind: ${imgData.kind}`);
	    }
	  }

	  function putBinaryImageMask(ctx, imgData) {
	    const height = imgData.height,
	          width = imgData.width;
	    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
	    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
	    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
	    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
	    let srcPos = 0;
	    const src = imgData.data;
	    const dest = chunkImgData.data;

	    for (let i = 0; i < totalChunks; i++) {
	      const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
	      let destPos = 3;

	      for (let j = 0; j < thisChunkHeight; j++) {
	        let elem,
	            mask = 0;

	        for (let k = 0; k < width; k++) {
	          if (!mask) {
	            elem = src[srcPos++];
	            mask = 128;
	          }

	          dest[destPos] = elem & mask ? 0 : 255;
	          destPos += 4;
	          mask >>= 1;
	        }
	      }

	      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
	    }
	  }

	  function copyCtxState(sourceCtx, destCtx) {
	    const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

	    for (let i = 0, ii = properties.length; i < ii; i++) {
	      const property = properties[i];

	      if (sourceCtx[property] !== undefined) {
	        destCtx[property] = sourceCtx[property];
	      }
	    }

	    if (sourceCtx.setLineDash !== undefined) {
	      destCtx.setLineDash(sourceCtx.getLineDash());
	      destCtx.lineDashOffset = sourceCtx.lineDashOffset;
	    }
	  }

	  function resetCtxToDefault(ctx) {
	    ctx.strokeStyle = "#000000";
	    ctx.fillStyle = "#000000";
	    ctx.fillRule = "nonzero";
	    ctx.globalAlpha = 1;
	    ctx.lineWidth = 1;
	    ctx.lineCap = "butt";
	    ctx.lineJoin = "miter";
	    ctx.miterLimit = 10;
	    ctx.globalCompositeOperation = "source-over";
	    ctx.font = "10px sans-serif";

	    if (ctx.setLineDash !== undefined) {
	      ctx.setLineDash([]);
	      ctx.lineDashOffset = 0;
	    }
	  }

	  function composeSMaskBackdrop(bytes, r0, g0, b0) {
	    const length = bytes.length;

	    for (let i = 3; i < length; i += 4) {
	      const alpha = bytes[i];

	      if (alpha === 0) {
	        bytes[i - 3] = r0;
	        bytes[i - 2] = g0;
	        bytes[i - 1] = b0;
	      } else if (alpha < 255) {
	        const alpha_ = 255 - alpha;
	        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
	        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
	        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
	      }
	    }
	  }

	  function composeSMaskAlpha(maskData, layerData, transferMap) {
	    const length = maskData.length;
	    const scale = 1 / 255;

	    for (let i = 3; i < length; i += 4) {
	      const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
	      layerData[i] = layerData[i] * alpha * scale | 0;
	    }
	  }

	  function composeSMaskLuminosity(maskData, layerData, transferMap) {
	    const length = maskData.length;

	    for (let i = 3; i < length; i += 4) {
	      const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
	      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
	    }
	  }

	  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
	    const hasBackdrop = !!backdrop;
	    const r0 = hasBackdrop ? backdrop[0] : 0;
	    const g0 = hasBackdrop ? backdrop[1] : 0;
	    const b0 = hasBackdrop ? backdrop[2] : 0;
	    let composeFn;

	    if (subtype === "Luminosity") {
	      composeFn = composeSMaskLuminosity;
	    } else {
	      composeFn = composeSMaskAlpha;
	    }

	    const PIXELS_TO_PROCESS = 1048576;
	    const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

	    for (let row = 0; row < height; row += chunkSize) {
	      const chunkHeight = Math.min(chunkSize, height - row);
	      const maskData = maskCtx.getImageData(0, row, width, chunkHeight);
	      const layerData = layerCtx.getImageData(0, row, width, chunkHeight);

	      if (hasBackdrop) {
	        composeSMaskBackdrop(maskData.data, r0, g0, b0);
	      }

	      composeFn(maskData.data, layerData.data, transferMap);
	      maskCtx.putImageData(layerData, 0, row);
	    }
	  }

	  function composeSMask(ctx, smask, layerCtx, webGLContext) {
	    const mask = smask.canvas;
	    const maskCtx = smask.context;
	    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
	    const backdrop = smask.backdrop || null;

	    if (!smask.transferMap && webGLContext.isEnabled) {
	      const composed = webGLContext.composeSMask({
	        layer: layerCtx.canvas,
	        mask,
	        properties: {
	          subtype: smask.subtype,
	          backdrop
	        }
	      });
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.drawImage(composed, smask.offsetX, smask.offsetY);
	      return;
	    }

	    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
	    ctx.drawImage(mask, 0, 0);
	  }

	  const LINE_CAP_STYLES = ["butt", "round", "square"];
	  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
	  const NORMAL_CLIP = {};
	  const EO_CLIP = {};
	  CanvasGraphics.prototype = {
	    beginDrawing({
	      transform,
	      viewport,
	      transparency = false,
	      background = null
	    }) {
	      const width = this.ctx.canvas.width;
	      const height = this.ctx.canvas.height;
	      this.ctx.save();
	      this.ctx.fillStyle = background || "rgb(255, 255, 255)";
	      this.ctx.fillRect(0, 0, width, height);
	      this.ctx.restore();

	      if (transparency) {
	        const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
	        this.compositeCtx = this.ctx;
	        this.transparentCanvas = transparentCanvas.canvas;
	        this.ctx = transparentCanvas.context;
	        this.ctx.save();
	        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
	      }

	      this.ctx.save();
	      resetCtxToDefault(this.ctx);

	      if (transform) {
	        this.ctx.transform.apply(this.ctx, transform);
	      }

	      this.ctx.transform.apply(this.ctx, viewport.transform);
	      this.baseTransform = this.ctx.mozCurrentTransform.slice();
	      this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);

	      if (this.imageLayer) {
	        this.imageLayer.beginLayout();
	      }
	    },

	    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
	      const argsArray = operatorList.argsArray;
	      const fnArray = operatorList.fnArray;
	      let i = executionStartIdx || 0;
	      const argsArrayLen = argsArray.length;

	      if (argsArrayLen === i) {
	        return i;
	      }

	      const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
	      const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
	      let steps = 0;
	      const commonObjs = this.commonObjs;
	      const objs = this.objs;
	      let fnId;

	      while (true) {
	        if (stepper !== undefined && i === stepper.nextBreakPoint) {
	          stepper.breakIt(i, continueCallback);
	          return i;
	        }

	        fnId = fnArray[i];

	        if (fnId !== _util.OPS.dependency) {
	          this[fnId].apply(this, argsArray[i]);
	        } else {
	          for (const depObjId of argsArray[i]) {
	            const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

	            if (!objsPool.has(depObjId)) {
	              objsPool.get(depObjId, continueCallback);
	              return i;
	            }
	          }
	        }

	        i++;

	        if (i === argsArrayLen) {
	          return i;
	        }

	        if (chunkOperations && ++steps > EXECUTION_STEPS) {
	          if (Date.now() > endTime) {
	            continueCallback();
	            return i;
	          }

	          steps = 0;
	        }
	      }
	    },
	    endDrawing: function CanvasGraphics_endDrawing() {
	      while (this.stateStack.length || this.current.activeSMask !== null) {
	        this.restore();
	      }

	      this.ctx.restore();

	      if (this.transparentCanvas) {
	        this.ctx = this.compositeCtx;
	        this.ctx.save();
	        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
	        this.ctx.drawImage(this.transparentCanvas, 0, 0);
	        this.ctx.restore();
	        this.transparentCanvas = null;
	      }

	      this.cachedCanvases.clear();
	      this.webGLContext.clear();

	      if (this.imageLayer) {
	        this.imageLayer.endLayout();
	      }
	    },
	    setLineWidth: function CanvasGraphics_setLineWidth(width) {
	      this.current.lineWidth = width;
	      this.ctx.lineWidth = width;
	    },
	    setLineCap: function CanvasGraphics_setLineCap(style) {
	      this.ctx.lineCap = LINE_CAP_STYLES[style];
	    },
	    setLineJoin: function CanvasGraphics_setLineJoin(style) {
	      this.ctx.lineJoin = LINE_JOIN_STYLES[style];
	    },
	    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
	      this.ctx.miterLimit = limit;
	    },
	    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
	      const ctx = this.ctx;

	      if (ctx.setLineDash !== undefined) {
	        ctx.setLineDash(dashArray);
	        ctx.lineDashOffset = dashPhase;
	      }
	    },

	    setRenderingIntent(intent) {},

	    setFlatness(flatness) {},

	    setGState: function CanvasGraphics_setGState(states) {
	      for (let i = 0, ii = states.length; i < ii; i++) {
	        const state = states[i];
	        const key = state[0];
	        const value = state[1];

	        switch (key) {
	          case "LW":
	            this.setLineWidth(value);
	            break;

	          case "LC":
	            this.setLineCap(value);
	            break;

	          case "LJ":
	            this.setLineJoin(value);
	            break;

	          case "ML":
	            this.setMiterLimit(value);
	            break;

	          case "D":
	            this.setDash(value[0], value[1]);
	            break;

	          case "RI":
	            this.setRenderingIntent(value);
	            break;

	          case "FL":
	            this.setFlatness(value);
	            break;

	          case "Font":
	            this.setFont(value[0], value[1]);
	            break;

	          case "CA":
	            this.current.strokeAlpha = state[1];
	            break;

	          case "ca":
	            this.current.fillAlpha = state[1];
	            this.ctx.globalAlpha = state[1];
	            break;

	          case "BM":
	            this.ctx.globalCompositeOperation = value;
	            break;

	          case "SMask":
	            if (this.current.activeSMask) {
	              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
	                this.suspendSMaskGroup();
	              } else {
	                this.endSMaskGroup();
	              }
	            }

	            this.current.activeSMask = value ? this.tempSMask : null;

	            if (this.current.activeSMask) {
	              this.beginSMaskGroup();
	            }

	            this.tempSMask = null;
	            break;

	          case "TR":
	            this.current.transferMaps = value;
	        }
	      }
	    },
	    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
	      const activeSMask = this.current.activeSMask;
	      const drawnWidth = activeSMask.canvas.width;
	      const drawnHeight = activeSMask.canvas.height;
	      const cacheId = "smaskGroupAt" + this.groupLevel;
	      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
	      const currentCtx = this.ctx;
	      const currentTransform = currentCtx.mozCurrentTransform;
	      this.ctx.save();
	      const groupCtx = scratchCanvas.context;
	      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
	      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
	      groupCtx.transform.apply(groupCtx, currentTransform);
	      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
	      copyCtxState(currentCtx, groupCtx);
	      this.ctx = groupCtx;
	      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
	      this.groupStack.push(currentCtx);
	      this.groupLevel++;
	    },
	    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
	      const groupCtx = this.ctx;
	      this.groupLevel--;
	      this.ctx = this.groupStack.pop();
	      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
	      this.ctx.restore();
	      this.ctx.save();
	      copyCtxState(groupCtx, this.ctx);
	      this.current.resumeSMaskCtx = groupCtx;

	      const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

	      this.ctx.transform.apply(this.ctx, deltaTransform);
	      groupCtx.save();
	      groupCtx.setTransform(1, 0, 0, 1, 0, 0);
	      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
	      groupCtx.restore();
	    },
	    resumeSMaskGroup: function CanvasGraphics_resumeSMaskGroup() {
	      const groupCtx = this.current.resumeSMaskCtx;
	      const currentCtx = this.ctx;
	      this.ctx = groupCtx;
	      this.groupStack.push(currentCtx);
	      this.groupLevel++;
	    },
	    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
	      const groupCtx = this.ctx;
	      this.groupLevel--;
	      this.ctx = this.groupStack.pop();
	      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
	      this.ctx.restore();
	      copyCtxState(groupCtx, this.ctx);

	      const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

	      this.ctx.transform.apply(this.ctx, deltaTransform);
	    },
	    save: function CanvasGraphics_save() {
	      this.ctx.save();
	      const old = this.current;
	      this.stateStack.push(old);
	      this.current = old.clone();
	      this.current.resumeSMaskCtx = null;
	    },
	    restore: function CanvasGraphics_restore() {
	      if (this.current.resumeSMaskCtx) {
	        this.resumeSMaskGroup();
	      }

	      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
	        this.endSMaskGroup();
	      }

	      if (this.stateStack.length !== 0) {
	        this.current = this.stateStack.pop();
	        this.ctx.restore();
	        this.pendingClip = null;
	        this._cachedGetSinglePixelWidth = null;
	      } else {
	        this.current.activeSMask = null;
	      }
	    },
	    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
	      this.ctx.transform(a, b, c, d, e, f);
	      this._cachedGetSinglePixelWidth = null;
	    },
	    constructPath: function CanvasGraphics_constructPath(ops, args) {
	      const ctx = this.ctx;
	      const current = this.current;
	      let x = current.x,
	          y = current.y;

	      for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
	        switch (ops[i] | 0) {
	          case _util.OPS.rectangle:
	            x = args[j++];
	            y = args[j++];
	            const width = args[j++];
	            const height = args[j++];
	            const xw = x + width;
	            const yh = y + height;
	            ctx.moveTo(x, y);

	            if (width === 0 || height === 0) {
	              ctx.lineTo(xw, yh);
	            } else {
	              ctx.lineTo(xw, y);
	              ctx.lineTo(xw, yh);
	              ctx.lineTo(x, yh);
	            }

	            ctx.closePath();
	            break;

	          case _util.OPS.moveTo:
	            x = args[j++];
	            y = args[j++];
	            ctx.moveTo(x, y);
	            break;

	          case _util.OPS.lineTo:
	            x = args[j++];
	            y = args[j++];
	            ctx.lineTo(x, y);
	            break;

	          case _util.OPS.curveTo:
	            x = args[j + 4];
	            y = args[j + 5];
	            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
	            j += 6;
	            break;

	          case _util.OPS.curveTo2:
	            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
	            x = args[j + 2];
	            y = args[j + 3];
	            j += 4;
	            break;

	          case _util.OPS.curveTo3:
	            x = args[j + 2];
	            y = args[j + 3];
	            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
	            j += 4;
	            break;

	          case _util.OPS.closePath:
	            ctx.closePath();
	            break;
	        }
	      }

	      current.setCurrentPoint(x, y);
	    },
	    closePath: function CanvasGraphics_closePath() {
	      this.ctx.closePath();
	    },
	    stroke: function CanvasGraphics_stroke(consumePath) {
	      consumePath = typeof consumePath !== "undefined" ? consumePath : true;
	      const ctx = this.ctx;
	      const strokeColor = this.current.strokeColor;
	      ctx.globalAlpha = this.current.strokeAlpha;

	      if (this.contentVisible) {
	        if (typeof strokeColor === "object" && strokeColor?.getPattern) {
	          ctx.save();
	          const transform = ctx.mozCurrentTransform;

	          const scale = _util.Util.singularValueDecompose2dScale(transform)[0];

	          ctx.strokeStyle = strokeColor.getPattern(ctx, this);
	          const lineWidth = this.getSinglePixelWidth();
	          const scaledLineWidth = this.current.lineWidth * scale;

	          if (lineWidth < 0 && -lineWidth >= scaledLineWidth) {
	            ctx.resetTransform();
	            ctx.lineWidth = Math.round(this._combinedScaleFactor);
	          } else {
	            ctx.lineWidth = Math.max(lineWidth, scaledLineWidth);
	          }

	          ctx.stroke();
	          ctx.restore();
	        } else {
	          const lineWidth = this.getSinglePixelWidth();

	          if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {
	            ctx.save();
	            ctx.resetTransform();
	            ctx.lineWidth = Math.round(this._combinedScaleFactor);
	            ctx.stroke();
	            ctx.restore();
	          } else {
	            ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
	            ctx.stroke();
	          }
	        }
	      }

	      if (consumePath) {
	        this.consumePath();
	      }

	      ctx.globalAlpha = this.current.fillAlpha;
	    },
	    closeStroke: function CanvasGraphics_closeStroke() {
	      this.closePath();
	      this.stroke();
	    },
	    fill: function CanvasGraphics_fill(consumePath) {
	      consumePath = typeof consumePath !== "undefined" ? consumePath : true;
	      const ctx = this.ctx;
	      const fillColor = this.current.fillColor;
	      const isPatternFill = this.current.patternFill;
	      let needRestore = false;

	      if (isPatternFill) {
	        ctx.save();

	        if (this.baseTransform) {
	          ctx.setTransform.apply(ctx, this.baseTransform);
	        }

	        ctx.fillStyle = fillColor.getPattern(ctx, this);
	        needRestore = true;
	      }

	      if (this.contentVisible) {
	        if (this.pendingEOFill) {
	          ctx.fill("evenodd");
	          this.pendingEOFill = false;
	        } else {
	          ctx.fill();
	        }
	      }

	      if (needRestore) {
	        ctx.restore();
	      }

	      if (consumePath) {
	        this.consumePath();
	      }
	    },
	    eoFill: function CanvasGraphics_eoFill() {
	      this.pendingEOFill = true;
	      this.fill();
	    },
	    fillStroke: function CanvasGraphics_fillStroke() {
	      this.fill(false);
	      this.stroke(false);
	      this.consumePath();
	    },
	    eoFillStroke: function CanvasGraphics_eoFillStroke() {
	      this.pendingEOFill = true;
	      this.fillStroke();
	    },
	    closeFillStroke: function CanvasGraphics_closeFillStroke() {
	      this.closePath();
	      this.fillStroke();
	    },
	    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
	      this.pendingEOFill = true;
	      this.closePath();
	      this.fillStroke();
	    },
	    endPath: function CanvasGraphics_endPath() {
	      this.consumePath();
	    },
	    clip: function CanvasGraphics_clip() {
	      this.pendingClip = NORMAL_CLIP;
	    },
	    eoClip: function CanvasGraphics_eoClip() {
	      this.pendingClip = EO_CLIP;
	    },
	    beginText: function CanvasGraphics_beginText() {
	      this.current.textMatrix = _util.IDENTITY_MATRIX;
	      this.current.textMatrixScale = 1;
	      this.current.x = this.current.lineX = 0;
	      this.current.y = this.current.lineY = 0;
	    },
	    endText: function CanvasGraphics_endText() {
	      const paths = this.pendingTextPaths;
	      const ctx = this.ctx;

	      if (paths === undefined) {
	        ctx.beginPath();
	        return;
	      }

	      ctx.save();
	      ctx.beginPath();

	      for (let i = 0; i < paths.length; i++) {
	        const path = paths[i];
	        ctx.setTransform.apply(ctx, path.transform);
	        ctx.translate(path.x, path.y);
	        path.addToPath(ctx, path.fontSize);
	      }

	      ctx.restore();
	      ctx.clip();
	      ctx.beginPath();
	      delete this.pendingTextPaths;
	    },
	    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
	      this.current.charSpacing = spacing;
	    },
	    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
	      this.current.wordSpacing = spacing;
	    },
	    setHScale: function CanvasGraphics_setHScale(scale) {
	      this.current.textHScale = scale / 100;
	    },
	    setLeading: function CanvasGraphics_setLeading(leading) {
	      this.current.leading = -leading;
	    },
	    setFont: function CanvasGraphics_setFont(fontRefName, size) {
	      const fontObj = this.commonObjs.get(fontRefName);
	      const current = this.current;

	      if (!fontObj) {
	        throw new Error(`Can't find font for ${fontRefName}`);
	      }

	      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

	      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
	        (0, _util.warn)("Invalid font matrix for font " + fontRefName);
	      }

	      if (size < 0) {
	        size = -size;
	        current.fontDirection = -1;
	      } else {
	        current.fontDirection = 1;
	      }

	      this.current.font = fontObj;
	      this.current.fontSize = size;

	      if (fontObj.isType3Font) {
	        return;
	      }

	      const name = fontObj.loadedName || "sans-serif";
	      let bold = "normal";

	      if (fontObj.black) {
	        bold = "900";
	      } else if (fontObj.bold) {
	        bold = "bold";
	      }

	      const italic = fontObj.italic ? "italic" : "normal";
	      const typeface = `"${name}", ${fontObj.fallbackName}`;
	      let browserFontSize = size;

	      if (size < MIN_FONT_SIZE) {
	        browserFontSize = MIN_FONT_SIZE;
	      } else if (size > MAX_FONT_SIZE) {
	        browserFontSize = MAX_FONT_SIZE;
	      }

	      this.current.fontSizeScale = size / browserFontSize;
	      this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
	    },
	    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
	      this.current.textRenderingMode = mode;
	    },
	    setTextRise: function CanvasGraphics_setTextRise(rise) {
	      this.current.textRise = rise;
	    },
	    moveText: function CanvasGraphics_moveText(x, y) {
	      this.current.x = this.current.lineX += x;
	      this.current.y = this.current.lineY += y;
	    },
	    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
	      this.setLeading(-y);
	      this.moveText(x, y);
	    },
	    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
	      this.current.textMatrix = [a, b, c, d, e, f];
	      this.current.textMatrixScale = Math.hypot(a, b);
	      this.current.x = this.current.lineX = 0;
	      this.current.y = this.current.lineY = 0;
	    },
	    nextLine: function CanvasGraphics_nextLine() {
	      this.moveText(0, this.current.leading);
	    },

	    paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
	      const ctx = this.ctx;
	      const current = this.current;
	      const font = current.font;
	      const textRenderingMode = current.textRenderingMode;
	      const fontSize = current.fontSize / current.fontSizeScale;
	      const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
	      const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
	      const patternFill = current.patternFill && !font.missingFile;
	      let addToPath;

	      if (font.disableFontFace || isAddToPathSet || patternFill) {
	        addToPath = font.getPathGenerator(this.commonObjs, character);
	      }

	      if (font.disableFontFace || patternFill) {
	        ctx.save();
	        ctx.translate(x, y);
	        ctx.beginPath();
	        addToPath(ctx, fontSize);

	        if (patternTransform) {
	          ctx.setTransform.apply(ctx, patternTransform);
	        }

	        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          ctx.fill();
	        }

	        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          if (resetLineWidthToOne) {
	            ctx.resetTransform();
	            ctx.lineWidth = Math.round(this._combinedScaleFactor);
	          }

	          ctx.stroke();
	        }

	        ctx.restore();
	      } else {
	        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          ctx.fillText(character, x, y);
	        }

	        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          if (resetLineWidthToOne) {
	            ctx.save();
	            ctx.moveTo(x, y);
	            ctx.resetTransform();
	            ctx.lineWidth = Math.round(this._combinedScaleFactor);
	            ctx.strokeText(character, 0, 0);
	            ctx.restore();
	          } else {
	            ctx.strokeText(character, x, y);
	          }
	        }
	      }

	      if (isAddToPathSet) {
	        const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
	        paths.push({
	          transform: ctx.mozCurrentTransform,
	          x,
	          y,
	          fontSize,
	          addToPath
	        });
	      }
	    },

	    get isFontSubpixelAAEnabled() {
	      const {
	        context: ctx
	      } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
	      ctx.scale(1.5, 1);
	      ctx.fillText("I", 0, 10);
	      const data = ctx.getImageData(0, 0, 10, 10).data;
	      let enabled = false;

	      for (let i = 3; i < data.length; i += 4) {
	        if (data[i] > 0 && data[i] < 255) {
	          enabled = true;
	          break;
	        }
	      }

	      return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
	    },

	    showText: function CanvasGraphics_showText(glyphs) {
	      const current = this.current;
	      const font = current.font;

	      if (font.isType3Font) {
	        return this.showType3Text(glyphs);
	      }

	      const fontSize = current.fontSize;

	      if (fontSize === 0) {
	        return undefined;
	      }

	      const ctx = this.ctx;
	      const fontSizeScale = current.fontSizeScale;
	      const charSpacing = current.charSpacing;
	      const wordSpacing = current.wordSpacing;
	      const fontDirection = current.fontDirection;
	      const textHScale = current.textHScale * fontDirection;
	      const glyphsLength = glyphs.length;
	      const vertical = font.vertical;
	      const spacingDir = vertical ? 1 : -1;
	      const defaultVMetrics = font.defaultVMetrics;
	      const widthAdvanceScale = fontSize * current.fontMatrix[0];
	      const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
	      ctx.save();
	      let patternTransform;

	      if (current.patternFill) {
	        ctx.save();
	        const pattern = current.fillColor.getPattern(ctx, this);
	        patternTransform = ctx.mozCurrentTransform;
	        ctx.restore();
	        ctx.fillStyle = pattern;
	      }

	      ctx.transform.apply(ctx, current.textMatrix);
	      ctx.translate(current.x, current.y + current.textRise);

	      if (fontDirection > 0) {
	        ctx.scale(textHScale, -1);
	      } else {
	        ctx.scale(textHScale, 1);
	      }

	      let lineWidth = current.lineWidth;
	      let resetLineWidthToOne = false;
	      const scale = current.textMatrixScale;

	      if (scale === 0 || lineWidth === 0) {
	        const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

	        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          this._cachedGetSinglePixelWidth = null;
	          lineWidth = this.getSinglePixelWidth();
	          resetLineWidthToOne = lineWidth < 0;
	        }
	      } else {
	        lineWidth /= scale;
	      }

	      if (fontSizeScale !== 1.0) {
	        ctx.scale(fontSizeScale, fontSizeScale);
	        lineWidth /= fontSizeScale;
	      }

	      ctx.lineWidth = lineWidth;
	      let x = 0,
	          i;

	      for (i = 0; i < glyphsLength; ++i) {
	        const glyph = glyphs[i];

	        if ((0, _util.isNum)(glyph)) {
	          x += spacingDir * glyph * fontSize / 1000;
	          continue;
	        }

	        let restoreNeeded = false;
	        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
	        const character = glyph.fontChar;
	        const accent = glyph.accent;
	        let scaledX, scaledY;
	        let width = glyph.width;

	        if (vertical) {
	          const vmetric = glyph.vmetric || defaultVMetrics;
	          const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
	          const vy = vmetric[2] * widthAdvanceScale;
	          width = vmetric ? -vmetric[0] : width;
	          scaledX = vx / fontSizeScale;
	          scaledY = (x + vy) / fontSizeScale;
	        } else {
	          scaledX = x / fontSizeScale;
	          scaledY = 0;
	        }

	        if (font.remeasure && width > 0) {
	          const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

	          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
	            const characterScaleX = width / measuredWidth;
	            restoreNeeded = true;
	            ctx.save();
	            ctx.scale(characterScaleX, 1);
	            scaledX /= characterScaleX;
	          } else if (width !== measuredWidth) {
	            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
	          }
	        }

	        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
	          if (simpleFillText && !accent) {
	            ctx.fillText(character, scaledX, scaledY);
	          } else {
	            this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);

	            if (accent) {
	              const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
	              const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
	              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
	            }
	          }
	        }

	        let charWidth;

	        if (vertical) {
	          charWidth = width * widthAdvanceScale - spacing * fontDirection;
	        } else {
	          charWidth = width * widthAdvanceScale + spacing * fontDirection;
	        }

	        x += charWidth;

	        if (restoreNeeded) {
	          ctx.restore();
	        }
	      }

	      if (vertical) {
	        current.y -= x;
	      } else {
	        current.x += x * textHScale;
	      }

	      ctx.restore();
	    },
	    showType3Text: function CanvasGraphics_showType3Text(glyphs) {
	      const ctx = this.ctx;
	      const current = this.current;
	      const font = current.font;
	      const fontSize = current.fontSize;
	      const fontDirection = current.fontDirection;
	      const spacingDir = font.vertical ? 1 : -1;
	      const charSpacing = current.charSpacing;
	      const wordSpacing = current.wordSpacing;
	      const textHScale = current.textHScale * fontDirection;
	      const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
	      const glyphsLength = glyphs.length;
	      const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
	      let i, glyph, width, spacingLength;

	      if (isTextInvisible || fontSize === 0) {
	        return;
	      }

	      this._cachedGetSinglePixelWidth = null;
	      ctx.save();
	      ctx.transform.apply(ctx, current.textMatrix);
	      ctx.translate(current.x, current.y);
	      ctx.scale(textHScale, fontDirection);

	      for (i = 0; i < glyphsLength; ++i) {
	        glyph = glyphs[i];

	        if ((0, _util.isNum)(glyph)) {
	          spacingLength = spacingDir * glyph * fontSize / 1000;
	          this.ctx.translate(spacingLength, 0);
	          current.x += spacingLength * textHScale;
	          continue;
	        }

	        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
	        const operatorList = font.charProcOperatorList[glyph.operatorListId];

	        if (!operatorList) {
	          (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
	          continue;
	        }

	        if (this.contentVisible) {
	          this.processingType3 = glyph;
	          this.save();
	          ctx.scale(fontSize, fontSize);
	          ctx.transform.apply(ctx, fontMatrix);
	          this.executeOperatorList(operatorList);
	          this.restore();
	        }

	        const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

	        width = transformed[0] * fontSize + spacing;
	        ctx.translate(width, 0);
	        current.x += width * textHScale;
	      }

	      ctx.restore();
	      this.processingType3 = null;
	    },
	    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},
	    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
	      this.ctx.rect(llx, lly, urx - llx, ury - lly);
	      this.clip();
	      this.endPath();
	    },
	    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
	      let pattern;

	      if (IR[0] === "TilingPattern") {
	        const color = IR[1];
	        const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
	        const canvasGraphicsFactory = {
	          createCanvasGraphics: ctx => {
	            return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);
	          }
	        };
	        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
	      } else {
	        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
	      }

	      return pattern;
	    },
	    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
	      this.current.strokeColor = this.getColorN_Pattern(arguments);
	    },
	    setFillColorN: function CanvasGraphics_setFillColorN() {
	      this.current.fillColor = this.getColorN_Pattern(arguments);
	      this.current.patternFill = true;
	    },
	    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
	      const color = _util.Util.makeHexColor(r, g, b);

	      this.ctx.strokeStyle = color;
	      this.current.strokeColor = color;
	    },
	    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
	      const color = _util.Util.makeHexColor(r, g, b);

	      this.ctx.fillStyle = color;
	      this.current.fillColor = color;
	      this.current.patternFill = false;
	    },
	    shadingFill: function CanvasGraphics_shadingFill(patternIR) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const ctx = this.ctx;
	      this.save();
	      const pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
	      ctx.fillStyle = pattern.getPattern(ctx, this, true);
	      const inv = ctx.mozCurrentTransformInverse;

	      if (inv) {
	        const canvas = ctx.canvas;
	        const width = canvas.width;
	        const height = canvas.height;

	        const bl = _util.Util.applyTransform([0, 0], inv);

	        const br = _util.Util.applyTransform([0, height], inv);

	        const ul = _util.Util.applyTransform([width, 0], inv);

	        const ur = _util.Util.applyTransform([width, height], inv);

	        const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
	        const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
	        const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
	        const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
	        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
	      } else {
	        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
	      }

	      this.restore();
	    },
	    beginInlineImage: function CanvasGraphics_beginInlineImage() {
	      (0, _util.unreachable)("Should not call beginInlineImage");
	    },
	    beginImageData: function CanvasGraphics_beginImageData() {
	      (0, _util.unreachable)("Should not call beginImageData");
	    },
	    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.save();
	      this.baseTransformStack.push(this.baseTransform);

	      if (Array.isArray(matrix) && matrix.length === 6) {
	        this.transform.apply(this, matrix);
	      }

	      this.baseTransform = this.ctx.mozCurrentTransform;

	      if (bbox) {
	        const width = bbox[2] - bbox[0];
	        const height = bbox[3] - bbox[1];
	        this.ctx.rect(bbox[0], bbox[1], width, height);
	        this.clip();
	        this.endPath();
	      }
	    },
	    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.restore();
	      this.baseTransform = this.baseTransformStack.pop();
	    },
	    beginGroup: function CanvasGraphics_beginGroup(group) {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.save();
	      const currentCtx = this.ctx;

	      if (!group.isolated) {
	        (0, _util.info)("TODO: Support non-isolated groups.");
	      }

	      if (group.knockout) {
	        (0, _util.warn)("Knockout groups not supported.");
	      }

	      const currentTransform = currentCtx.mozCurrentTransform;

	      if (group.matrix) {
	        currentCtx.transform.apply(currentCtx, group.matrix);
	      }

	      if (!group.bbox) {
	        throw new Error("Bounding box is required.");
	      }

	      let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

	      const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
	      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
	      const offsetX = Math.floor(bounds[0]);
	      const offsetY = Math.floor(bounds[1]);
	      let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
	      let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
	      let scaleX = 1,
	          scaleY = 1;

	      if (drawnWidth > MAX_GROUP_SIZE) {
	        scaleX = drawnWidth / MAX_GROUP_SIZE;
	        drawnWidth = MAX_GROUP_SIZE;
	      }

	      if (drawnHeight > MAX_GROUP_SIZE) {
	        scaleY = drawnHeight / MAX_GROUP_SIZE;
	        drawnHeight = MAX_GROUP_SIZE;
	      }

	      let cacheId = "groupAt" + this.groupLevel;

	      if (group.smask) {
	        cacheId += "_smask_" + this.smaskCounter++ % 2;
	      }

	      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
	      const groupCtx = scratchCanvas.context;
	      groupCtx.scale(1 / scaleX, 1 / scaleY);
	      groupCtx.translate(-offsetX, -offsetY);
	      groupCtx.transform.apply(groupCtx, currentTransform);

	      if (group.smask) {
	        this.smaskStack.push({
	          canvas: scratchCanvas.canvas,
	          context: groupCtx,
	          offsetX,
	          offsetY,
	          scaleX,
	          scaleY,
	          subtype: group.smask.subtype,
	          backdrop: group.smask.backdrop,
	          transferMap: group.smask.transferMap || null,
	          startTransformInverse: null
	        });
	      } else {
	        currentCtx.setTransform(1, 0, 0, 1, 0, 0);
	        currentCtx.translate(offsetX, offsetY);
	        currentCtx.scale(scaleX, scaleY);
	      }

	      copyCtxState(currentCtx, groupCtx);
	      this.ctx = groupCtx;
	      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
	      this.groupStack.push(currentCtx);
	      this.groupLevel++;
	      this.current.activeSMask = null;
	    },
	    endGroup: function CanvasGraphics_endGroup(group) {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.groupLevel--;
	      const groupCtx = this.ctx;
	      this.ctx = this.groupStack.pop();

	      if (this.ctx.imageSmoothingEnabled !== undefined) {
	        this.ctx.imageSmoothingEnabled = false;
	      } else {
	        this.ctx.mozImageSmoothingEnabled = false;
	      }

	      if (group.smask) {
	        this.tempSMask = this.smaskStack.pop();
	      } else {
	        this.ctx.drawImage(groupCtx.canvas, 0, 0);
	      }

	      this.restore();
	    },
	    beginAnnotations: function CanvasGraphics_beginAnnotations() {
	      this.save();

	      if (this.baseTransform) {
	        this.ctx.setTransform.apply(this.ctx, this.baseTransform);
	      }
	    },
	    endAnnotations: function CanvasGraphics_endAnnotations() {
	      this.restore();
	    },
	    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
	      this.save();
	      resetCtxToDefault(this.ctx);
	      this.current = new CanvasExtraState();

	      if (Array.isArray(rect) && rect.length === 4) {
	        const width = rect[2] - rect[0];
	        const height = rect[3] - rect[1];
	        this.ctx.rect(rect[0], rect[1], width, height);
	        this.clip();
	        this.endPath();
	      }

	      this.transform.apply(this, transform);
	      this.transform.apply(this, matrix);
	    },
	    endAnnotation: function CanvasGraphics_endAnnotation() {
	      this.restore();
	    },
	    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const ctx = this.ctx;
	      const width = img.width,
	            height = img.height;
	      const fillColor = this.current.fillColor;
	      const isPatternFill = this.current.patternFill;
	      const glyph = this.processingType3;

	      if (glyph && glyph.compiled === undefined) {
	        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
	          glyph.compiled = compileType3Glyph({
	            data: img.data,
	            width,
	            height
	          });
	        } else {
	          glyph.compiled = null;
	        }
	      }

	      if (glyph?.compiled) {
	        glyph.compiled(ctx);
	        return;
	      }

	      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
	      const maskCtx = maskCanvas.context;
	      maskCtx.save();
	      putBinaryImageMask(maskCtx, img);
	      maskCtx.globalCompositeOperation = "source-in";
	      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
	      maskCtx.fillRect(0, 0, width, height);
	      maskCtx.restore();
	      this.paintInlineImageXObject(maskCanvas.canvas);
	    },

	    paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const width = imgData.width;
	      const height = imgData.height;
	      const fillColor = this.current.fillColor;
	      const isPatternFill = this.current.patternFill;
	      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
	      const maskCtx = maskCanvas.context;
	      maskCtx.save();
	      putBinaryImageMask(maskCtx, imgData);
	      maskCtx.globalCompositeOperation = "source-in";
	      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
	      maskCtx.fillRect(0, 0, width, height);
	      maskCtx.restore();
	      const ctx = this.ctx;

	      for (let i = 0, ii = positions.length; i < ii; i += 2) {
	        ctx.save();
	        ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);
	        ctx.scale(1, -1);
	        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
	        ctx.restore();
	      }
	    },

	    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const ctx = this.ctx;
	      const fillColor = this.current.fillColor;
	      const isPatternFill = this.current.patternFill;

	      for (let i = 0, ii = images.length; i < ii; i++) {
	        const image = images[i];
	        const width = image.width,
	              height = image.height;
	        const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
	        const maskCtx = maskCanvas.context;
	        maskCtx.save();
	        putBinaryImageMask(maskCtx, image);
	        maskCtx.globalCompositeOperation = "source-in";
	        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
	        maskCtx.fillRect(0, 0, width, height);
	        maskCtx.restore();
	        ctx.save();
	        ctx.transform.apply(ctx, image.transform);
	        ctx.scale(1, -1);
	        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
	        ctx.restore();
	      }
	    },
	    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

	      if (!imgData) {
	        (0, _util.warn)("Dependent image isn't ready yet");
	        return;
	      }

	      this.paintInlineImageXObject(imgData);
	    },
	    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

	      if (!imgData) {
	        (0, _util.warn)("Dependent image isn't ready yet");
	        return;
	      }

	      const width = imgData.width;
	      const height = imgData.height;
	      const map = [];

	      for (let i = 0, ii = positions.length; i < ii; i += 2) {
	        map.push({
	          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
	          x: 0,
	          y: 0,
	          w: width,
	          h: height
	        });
	      }

	      this.paintInlineImageXObjectGroup(imgData, map);
	    },
	    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const width = imgData.width;
	      const height = imgData.height;
	      const ctx = this.ctx;
	      this.save();
	      ctx.scale(1 / width, -1 / height);
	      const currentTransform = ctx.mozCurrentTransformInverse;
	      let widthScale = Math.max(Math.hypot(currentTransform[0], currentTransform[1]), 1);
	      let heightScale = Math.max(Math.hypot(currentTransform[2], currentTransform[3]), 1);
	      let imgToPaint, tmpCanvas, tmpCtx;

	      if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
	        imgToPaint = imgData;
	      } else {
	        tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
	        tmpCtx = tmpCanvas.context;
	        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
	        imgToPaint = tmpCanvas.canvas;
	      }

	      let paintWidth = width,
	          paintHeight = height;
	      let tmpCanvasId = "prescale1";

	      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
	        let newWidth = paintWidth,
	            newHeight = paintHeight;

	        if (widthScale > 2 && paintWidth > 1) {
	          newWidth = Math.ceil(paintWidth / 2);
	          widthScale /= paintWidth / newWidth;
	        }

	        if (heightScale > 2 && paintHeight > 1) {
	          newHeight = Math.ceil(paintHeight / 2);
	          heightScale /= paintHeight / newHeight;
	        }

	        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
	        tmpCtx = tmpCanvas.context;
	        tmpCtx.clearRect(0, 0, newWidth, newHeight);
	        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
	        imgToPaint = tmpCanvas.canvas;
	        paintWidth = newWidth;
	        paintHeight = newHeight;
	        tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
	      }

	      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);

	      if (this.imageLayer) {
	        const position = this.getCanvasPosition(0, -height);
	        this.imageLayer.appendImage({
	          imgData,
	          left: position[0],
	          top: position[1],
	          width: width / currentTransform[0],
	          height: height / currentTransform[3]
	        });
	      }

	      this.restore();
	    },
	    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
	      if (!this.contentVisible) {
	        return;
	      }

	      const ctx = this.ctx;
	      const w = imgData.width;
	      const h = imgData.height;
	      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
	      const tmpCtx = tmpCanvas.context;
	      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

	      for (let i = 0, ii = map.length; i < ii; i++) {
	        const entry = map[i];
	        ctx.save();
	        ctx.transform.apply(ctx, entry.transform);
	        ctx.scale(1, -1);
	        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

	        if (this.imageLayer) {
	          const position = this.getCanvasPosition(entry.x, entry.y);
	          this.imageLayer.appendImage({
	            imgData,
	            left: position[0],
	            top: position[1],
	            width: w,
	            height: h
	          });
	        }

	        ctx.restore();
	      }
	    },
	    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.ctx.fillRect(0, 0, 1, 1);
	    },
	    markPoint: function CanvasGraphics_markPoint(tag) {},
	    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},
	    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
	      this.markedContentStack.push({
	        visible: true
	      });
	    },
	    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
	      if (tag === "OC") {
	        this.markedContentStack.push({
	          visible: this.optionalContentConfig.isVisible(properties)
	        });
	      } else {
	        this.markedContentStack.push({
	          visible: true
	        });
	      }

	      this.contentVisible = this.isContentVisible();
	    },
	    endMarkedContent: function CanvasGraphics_endMarkedContent() {
	      this.markedContentStack.pop();
	      this.contentVisible = this.isContentVisible();
	    },
	    beginCompat: function CanvasGraphics_beginCompat() {},
	    endCompat: function CanvasGraphics_endCompat() {},
	    consumePath: function CanvasGraphics_consumePath() {
	      const ctx = this.ctx;

	      if (this.pendingClip) {
	        if (this.pendingClip === EO_CLIP) {
	          ctx.clip("evenodd");
	        } else {
	          ctx.clip();
	        }

	        this.pendingClip = null;
	      }

	      ctx.beginPath();
	    },

	    getSinglePixelWidth() {
	      if (this._cachedGetSinglePixelWidth === null) {
	        const m = this.ctx.mozCurrentTransform;
	        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
	        const sqNorm1 = m[0] ** 2 + m[2] ** 2;
	        const sqNorm2 = m[1] ** 2 + m[3] ** 2;
	        const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;

	        if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
	          this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
	        } else if (absDet > Number.EPSILON) {
	          this._cachedGetSinglePixelWidth = pixelHeight * 1.0000001;
	        } else {
	          this._cachedGetSinglePixelWidth = 1;
	        }
	      }

	      return this._cachedGetSinglePixelWidth;
	    },

	    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
	      const transform = this.ctx.mozCurrentTransform;
	      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
	    },
	    isContentVisible: function CanvasGraphics_isContentVisible() {
	      for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
	        if (!this.markedContentStack[i].visible) {
	          return false;
	        }
	      }

	      return true;
	    }
	  };

	  for (const op in _util.OPS) {
	    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
	  }

	  return CanvasGraphics;
	}();

	exports.CanvasGraphics = CanvasGraphics;

	/***/ }),
	/* 11 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.getShadingPatternFromIR = getShadingPatternFromIR;
	exports.TilingPattern = void 0;

	var _util = __w_pdfjs_require__(2);

	const ShadingIRs = {};

	function applyBoundingBox(ctx, bbox) {
	  if (!bbox || typeof Path2D === "undefined") {
	    return;
	  }

	  const width = bbox[2] - bbox[0];
	  const height = bbox[3] - bbox[1];
	  const region = new Path2D();
	  region.rect(bbox[0], bbox[1], width, height);
	  ctx.clip(region);
	}

	ShadingIRs.RadialAxial = {
	  fromIR: function RadialAxial_fromIR(raw) {
	    const type = raw[1];
	    const bbox = raw[2];
	    const colorStops = raw[3];
	    const p0 = raw[4];
	    const p1 = raw[5];
	    const r0 = raw[6];
	    const r1 = raw[7];
	    return {
	      getPattern: function RadialAxial_getPattern(ctx) {
	        applyBoundingBox(ctx, bbox);
	        let grad;

	        if (type === "axial") {
	          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
	        } else if (type === "radial") {
	          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
	        }

	        for (let i = 0, ii = colorStops.length; i < ii; ++i) {
	          const c = colorStops[i];
	          grad.addColorStop(c[0], c[1]);
	        }

	        return grad;
	      }
	    };
	  }
	};

	const createMeshCanvas = function createMeshCanvasClosure() {
	  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
	    const coords = context.coords,
	          colors = context.colors;
	    const bytes = data.data,
	          rowSize = data.width * 4;
	    let tmp;

	    if (coords[p1 + 1] > coords[p2 + 1]) {
	      tmp = p1;
	      p1 = p2;
	      p2 = tmp;
	      tmp = c1;
	      c1 = c2;
	      c2 = tmp;
	    }

	    if (coords[p2 + 1] > coords[p3 + 1]) {
	      tmp = p2;
	      p2 = p3;
	      p3 = tmp;
	      tmp = c2;
	      c2 = c3;
	      c3 = tmp;
	    }

	    if (coords[p1 + 1] > coords[p2 + 1]) {
	      tmp = p1;
	      p1 = p2;
	      p2 = tmp;
	      tmp = c1;
	      c1 = c2;
	      c2 = tmp;
	    }

	    const x1 = (coords[p1] + context.offsetX) * context.scaleX;
	    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
	    const x2 = (coords[p2] + context.offsetX) * context.scaleX;
	    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
	    const x3 = (coords[p3] + context.offsetX) * context.scaleX;
	    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

	    if (y1 >= y3) {
	      return;
	    }

	    const c1r = colors[c1],
	          c1g = colors[c1 + 1],
	          c1b = colors[c1 + 2];
	    const c2r = colors[c2],
	          c2g = colors[c2 + 1],
	          c2b = colors[c2 + 2];
	    const c3r = colors[c3],
	          c3g = colors[c3 + 1],
	          c3b = colors[c3 + 2];
	    const minY = Math.round(y1),
	          maxY = Math.round(y3);
	    let xa, car, cag, cab;
	    let xb, cbr, cbg, cbb;

	    for (let y = minY; y <= maxY; y++) {
	      if (y < y2) {
	        let k;

	        if (y < y1) {
	          k = 0;
	        } else if (y1 === y2) {
	          k = 1;
	        } else {
	          k = (y1 - y) / (y1 - y2);
	        }

	        xa = x1 - (x1 - x2) * k;
	        car = c1r - (c1r - c2r) * k;
	        cag = c1g - (c1g - c2g) * k;
	        cab = c1b - (c1b - c2b) * k;
	      } else {
	        let k;

	        if (y > y3) {
	          k = 1;
	        } else if (y2 === y3) {
	          k = 0;
	        } else {
	          k = (y2 - y) / (y2 - y3);
	        }

	        xa = x2 - (x2 - x3) * k;
	        car = c2r - (c2r - c3r) * k;
	        cag = c2g - (c2g - c3g) * k;
	        cab = c2b - (c2b - c3b) * k;
	      }

	      let k;

	      if (y < y1) {
	        k = 0;
	      } else if (y > y3) {
	        k = 1;
	      } else {
	        k = (y1 - y) / (y1 - y3);
	      }

	      xb = x1 - (x1 - x3) * k;
	      cbr = c1r - (c1r - c3r) * k;
	      cbg = c1g - (c1g - c3g) * k;
	      cbb = c1b - (c1b - c3b) * k;
	      const x1_ = Math.round(Math.min(xa, xb));
	      const x2_ = Math.round(Math.max(xa, xb));
	      let j = rowSize * y + x1_ * 4;

	      for (let x = x1_; x <= x2_; x++) {
	        k = (xa - x) / (xa - xb);

	        if (k < 0) {
	          k = 0;
	        } else if (k > 1) {
	          k = 1;
	        }

	        bytes[j++] = car - (car - cbr) * k | 0;
	        bytes[j++] = cag - (cag - cbg) * k | 0;
	        bytes[j++] = cab - (cab - cbb) * k | 0;
	        bytes[j++] = 255;
	      }
	    }
	  }

	  function drawFigure(data, figure, context) {
	    const ps = figure.coords;
	    const cs = figure.colors;
	    let i, ii;

	    switch (figure.type) {
	      case "lattice":
	        const verticesPerRow = figure.verticesPerRow;
	        const rows = Math.floor(ps.length / verticesPerRow) - 1;
	        const cols = verticesPerRow - 1;

	        for (i = 0; i < rows; i++) {
	          let q = i * verticesPerRow;

	          for (let j = 0; j < cols; j++, q++) {
	            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
	            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
	          }
	        }

	        break;

	      case "triangles":
	        for (i = 0, ii = ps.length; i < ii; i += 3) {
	          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
	        }

	        break;

	      default:
	        throw new Error("illegal figure");
	    }
	  }

	  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
	    const EXPECTED_SCALE = 1.1;
	    const MAX_PATTERN_SIZE = 3000;
	    const BORDER_SIZE = 2;
	    const offsetX = Math.floor(bounds[0]);
	    const offsetY = Math.floor(bounds[1]);
	    const boundsWidth = Math.ceil(bounds[2]) - offsetX;
	    const boundsHeight = Math.ceil(bounds[3]) - offsetY;
	    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
	    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
	    const scaleX = boundsWidth / width;
	    const scaleY = boundsHeight / height;
	    const context = {
	      coords,
	      colors,
	      offsetX: -offsetX,
	      offsetY: -offsetY,
	      scaleX: 1 / scaleX,
	      scaleY: 1 / scaleY
	    };
	    const paddedWidth = width + BORDER_SIZE * 2;
	    const paddedHeight = height + BORDER_SIZE * 2;
	    let canvas, tmpCanvas, i, ii;

	    if (webGLContext.isEnabled) {
	      canvas = webGLContext.drawFigures({
	        width,
	        height,
	        backgroundColor,
	        figures,
	        context
	      });
	      tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
	      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
	      canvas = tmpCanvas.canvas;
	    } else {
	      tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
	      const tmpCtx = tmpCanvas.context;
	      const data = tmpCtx.createImageData(width, height);

	      if (backgroundColor) {
	        const bytes = data.data;

	        for (i = 0, ii = bytes.length; i < ii; i += 4) {
	          bytes[i] = backgroundColor[0];
	          bytes[i + 1] = backgroundColor[1];
	          bytes[i + 2] = backgroundColor[2];
	          bytes[i + 3] = 255;
	        }
	      }

	      for (i = 0; i < figures.length; i++) {
	        drawFigure(data, figures[i], context);
	      }

	      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
	      canvas = tmpCanvas.canvas;
	    }

	    return {
	      canvas,
	      offsetX: offsetX - BORDER_SIZE * scaleX,
	      offsetY: offsetY - BORDER_SIZE * scaleY,
	      scaleX,
	      scaleY
	    };
	  }

	  return createMeshCanvas;
	}();

	ShadingIRs.Mesh = {
	  fromIR: function Mesh_fromIR(raw) {
	    const coords = raw[2];
	    const colors = raw[3];
	    const figures = raw[4];
	    const bounds = raw[5];
	    const matrix = raw[6];
	    const bbox = raw[7];
	    const background = raw[8];
	    return {
	      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
	        applyBoundingBox(ctx, bbox);
	        let scale;

	        if (shadingFill) {
	          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
	        } else {
	          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

	          if (matrix) {
	            const matrixScale = _util.Util.singularValueDecompose2dScale(matrix);

	            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
	          }
	        }

	        const temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);

	        if (!shadingFill) {
	          ctx.setTransform.apply(ctx, owner.baseTransform);

	          if (matrix) {
	            ctx.transform.apply(ctx, matrix);
	          }
	        }

	        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
	        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
	        return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
	      }
	    };
	  }
	};
	ShadingIRs.Dummy = {
	  fromIR: function Dummy_fromIR() {
	    return {
	      getPattern: function Dummy_fromIR_getPattern() {
	        return "hotpink";
	      }
	    };
	  }
	};

	function getShadingPatternFromIR(raw) {
	  const shadingIR = ShadingIRs[raw[0]];

	  if (!shadingIR) {
	    throw new Error(`Unknown IR type: ${raw[0]}`);
	  }

	  return shadingIR.fromIR(raw);
	}

	const TilingPattern = function TilingPatternClosure() {
	  const PaintType = {
	    COLORED: 1,
	    UNCOLORED: 2
	  };
	  const MAX_PATTERN_SIZE = 3000;

	  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
	    this.operatorList = IR[2];
	    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
	    this.bbox = IR[4];
	    this.xstep = IR[5];
	    this.ystep = IR[6];
	    this.paintType = IR[7];
	    this.tilingType = IR[8];
	    this.color = color;
	    this.canvasGraphicsFactory = canvasGraphicsFactory;
	    this.baseTransform = baseTransform;
	    this.ctx = ctx;
	  }

	  TilingPattern.prototype = {
	    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
	      const operatorList = this.operatorList;
	      const bbox = this.bbox;
	      const xstep = this.xstep;
	      const ystep = this.ystep;
	      const paintType = this.paintType;
	      const tilingType = this.tilingType;
	      const color = this.color;
	      const canvasGraphicsFactory = this.canvasGraphicsFactory;
	      (0, _util.info)("TilingType: " + tilingType);
	      const x0 = bbox[0],
	            y0 = bbox[1],
	            x1 = bbox[2],
	            y1 = bbox[3];

	      const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

	      const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

	      const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
	      const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
	      const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
	      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
	      const tmpCtx = tmpCanvas.context;
	      const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
	      graphics.groupLevel = owner.groupLevel;
	      this.setFillAndStrokeStyleToContext(graphics, paintType, color);
	      graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
	      graphics.transform(1, 0, 0, 1, -x0, -y0);
	      this.clipBbox(graphics, bbox, x0, y0, x1, y1);
	      graphics.executeOperatorList(operatorList);
	      this.ctx.transform(1, 0, 0, 1, x0, y0);
	      this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
	      return tmpCanvas.canvas;
	    },
	    getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
	      step = Math.abs(step);
	      const maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
	      let size = Math.ceil(step * scale);

	      if (size >= maxSize) {
	        size = maxSize;
	      } else {
	        scale = size / step;
	      }

	      return {
	        scale,
	        size
	      };
	    },
	    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
	      if (Array.isArray(bbox) && bbox.length === 4) {
	        const bboxWidth = x1 - x0;
	        const bboxHeight = y1 - y0;
	        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
	        graphics.clip();
	        graphics.endPath();
	      }
	    },
	    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
	      const context = graphics.ctx,
	            current = graphics.current;

	      switch (paintType) {
	        case PaintType.COLORED:
	          const ctx = this.ctx;
	          context.fillStyle = ctx.fillStyle;
	          context.strokeStyle = ctx.strokeStyle;
	          current.fillColor = ctx.fillStyle;
	          current.strokeColor = ctx.strokeStyle;
	          break;

	        case PaintType.UNCOLORED:
	          const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

	          context.fillStyle = cssColor;
	          context.strokeStyle = cssColor;
	          current.fillColor = cssColor;
	          current.strokeColor = cssColor;
	          break;

	        default:
	          throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
	      }
	    },
	    getPattern: function TilingPattern_getPattern(ctx, owner) {
	      ctx = this.ctx;
	      ctx.setTransform.apply(ctx, this.baseTransform);
	      ctx.transform.apply(ctx, this.matrix);
	      const temporaryPatternCanvas = this.createPatternCanvas(owner);
	      return ctx.createPattern(temporaryPatternCanvas, "repeat");
	    }
	  };
	  return TilingPattern;
	}();

	exports.TilingPattern = TilingPattern;

	/***/ }),
	/* 12 */
	/***/ ((__unused_webpack_module, exports) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.GlobalWorkerOptions = void 0;
	const GlobalWorkerOptions = Object.create(null);
	exports.GlobalWorkerOptions = GlobalWorkerOptions;
	GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
	GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

	/***/ }),
	/* 13 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.MessageHandler = void 0;

	var _util = __w_pdfjs_require__(2);

	const CallbackKind = {
	  UNKNOWN: 0,
	  DATA: 1,
	  ERROR: 2
	};
	const StreamKind = {
	  UNKNOWN: 0,
	  CANCEL: 1,
	  CANCEL_COMPLETE: 2,
	  CLOSE: 3,
	  ENQUEUE: 4,
	  ERROR: 5,
	  PULL: 6,
	  PULL_COMPLETE: 7,
	  START_COMPLETE: 8
	};

	function wrapReason(reason) {
	  if (typeof reason !== "object" || reason === null) {
	    return reason;
	  }

	  switch (reason.name) {
	    case "AbortException":
	      return new _util.AbortException(reason.message);

	    case "MissingPDFException":
	      return new _util.MissingPDFException(reason.message);

	    case "UnexpectedResponseException":
	      return new _util.UnexpectedResponseException(reason.message, reason.status);

	    case "UnknownErrorException":
	      return new _util.UnknownErrorException(reason.message, reason.details);

	    default:
	      return new _util.UnknownErrorException(reason.message, reason.toString());
	  }
	}

	class MessageHandler {
	  constructor(sourceName, targetName, comObj) {
	    this.sourceName = sourceName;
	    this.targetName = targetName;
	    this.comObj = comObj;
	    this.callbackId = 1;
	    this.streamId = 1;
	    this.postMessageTransfers = true;
	    this.streamSinks = Object.create(null);
	    this.streamControllers = Object.create(null);
	    this.callbackCapabilities = Object.create(null);
	    this.actionHandler = Object.create(null);

	    this._onComObjOnMessage = event => {
	      const data = event.data;

	      if (data.targetName !== this.sourceName) {
	        return;
	      }

	      if (data.stream) {
	        this._processStreamMessage(data);

	        return;
	      }

	      if (data.callback) {
	        const callbackId = data.callbackId;
	        const capability = this.callbackCapabilities[callbackId];

	        if (!capability) {
	          throw new Error(`Cannot resolve callback ${callbackId}`);
	        }

	        delete this.callbackCapabilities[callbackId];

	        if (data.callback === CallbackKind.DATA) {
	          capability.resolve(data.data);
	        } else if (data.callback === CallbackKind.ERROR) {
	          capability.reject(wrapReason(data.reason));
	        } else {
	          throw new Error("Unexpected callback case");
	        }

	        return;
	      }

	      const action = this.actionHandler[data.action];

	      if (!action) {
	        throw new Error(`Unknown action from worker: ${data.action}`);
	      }

	      if (data.callbackId) {
	        const cbSourceName = this.sourceName;
	        const cbTargetName = data.sourceName;
	        new Promise(function (resolve) {
	          resolve(action(data.data));
	        }).then(function (result) {
	          comObj.postMessage({
	            sourceName: cbSourceName,
	            targetName: cbTargetName,
	            callback: CallbackKind.DATA,
	            callbackId: data.callbackId,
	            data: result
	          });
	        }, function (reason) {
	          comObj.postMessage({
	            sourceName: cbSourceName,
	            targetName: cbTargetName,
	            callback: CallbackKind.ERROR,
	            callbackId: data.callbackId,
	            reason: wrapReason(reason)
	          });
	        });
	        return;
	      }

	      if (data.streamId) {
	        this._createStreamSink(data);

	        return;
	      }

	      action(data.data);
	    };

	    comObj.addEventListener("message", this._onComObjOnMessage);
	  }

	  on(actionName, handler) {
	    const ah = this.actionHandler;

	    if (ah[actionName]) {
	      throw new Error(`There is already an actionName called "${actionName}"`);
	    }

	    ah[actionName] = handler;
	  }

	  send(actionName, data, transfers) {
	    this._postMessage({
	      sourceName: this.sourceName,
	      targetName: this.targetName,
	      action: actionName,
	      data
	    }, transfers);
	  }

	  sendWithPromise(actionName, data, transfers) {
	    const callbackId = this.callbackId++;
	    const capability = (0, _util.createPromiseCapability)();
	    this.callbackCapabilities[callbackId] = capability;

	    try {
	      this._postMessage({
	        sourceName: this.sourceName,
	        targetName: this.targetName,
	        action: actionName,
	        callbackId,
	        data
	      }, transfers);
	    } catch (ex) {
	      capability.reject(ex);
	    }

	    return capability.promise;
	  }

	  sendWithStream(actionName, data, queueingStrategy, transfers) {
	    const streamId = this.streamId++;
	    const sourceName = this.sourceName;
	    const targetName = this.targetName;
	    const comObj = this.comObj;
	    return new ReadableStream({
	      start: controller => {
	        const startCapability = (0, _util.createPromiseCapability)();
	        this.streamControllers[streamId] = {
	          controller,
	          startCall: startCapability,
	          pullCall: null,
	          cancelCall: null,
	          isClosed: false
	        };

	        this._postMessage({
	          sourceName,
	          targetName,
	          action: actionName,
	          streamId,
	          data,
	          desiredSize: controller.desiredSize
	        }, transfers);

	        return startCapability.promise;
	      },
	      pull: controller => {
	        const pullCapability = (0, _util.createPromiseCapability)();
	        this.streamControllers[streamId].pullCall = pullCapability;
	        comObj.postMessage({
	          sourceName,
	          targetName,
	          stream: StreamKind.PULL,
	          streamId,
	          desiredSize: controller.desiredSize
	        });
	        return pullCapability.promise;
	      },
	      cancel: reason => {
	        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
	        const cancelCapability = (0, _util.createPromiseCapability)();
	        this.streamControllers[streamId].cancelCall = cancelCapability;
	        this.streamControllers[streamId].isClosed = true;
	        comObj.postMessage({
	          sourceName,
	          targetName,
	          stream: StreamKind.CANCEL,
	          streamId,
	          reason: wrapReason(reason)
	        });
	        return cancelCapability.promise;
	      }
	    }, queueingStrategy);
	  }

	  _createStreamSink(data) {
	    const self = this;
	    const action = this.actionHandler[data.action];
	    const streamId = data.streamId;
	    const sourceName = this.sourceName;
	    const targetName = data.sourceName;
	    const comObj = this.comObj;
	    const streamSink = {
	      enqueue(chunk, size = 1, transfers) {
	        if (this.isCancelled) {
	          return;
	        }

	        const lastDesiredSize = this.desiredSize;
	        this.desiredSize -= size;

	        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
	          this.sinkCapability = (0, _util.createPromiseCapability)();
	          this.ready = this.sinkCapability.promise;
	        }

	        self._postMessage({
	          sourceName,
	          targetName,
	          stream: StreamKind.ENQUEUE,
	          streamId,
	          chunk
	        }, transfers);
	      },

	      close() {
	        if (this.isCancelled) {
	          return;
	        }

	        this.isCancelled = true;
	        comObj.postMessage({
	          sourceName,
	          targetName,
	          stream: StreamKind.CLOSE,
	          streamId
	        });
	        delete self.streamSinks[streamId];
	      },

	      error(reason) {
	        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

	        if (this.isCancelled) {
	          return;
	        }

	        this.isCancelled = true;
	        comObj.postMessage({
	          sourceName,
	          targetName,
	          stream: StreamKind.ERROR,
	          streamId,
	          reason: wrapReason(reason)
	        });
	      },

	      sinkCapability: (0, _util.createPromiseCapability)(),
	      onPull: null,
	      onCancel: null,
	      isCancelled: false,
	      desiredSize: data.desiredSize,
	      ready: null
	    };
	    streamSink.sinkCapability.resolve();
	    streamSink.ready = streamSink.sinkCapability.promise;
	    this.streamSinks[streamId] = streamSink;
	    new Promise(function (resolve) {
	      resolve(action(data.data, streamSink));
	    }).then(function () {
	      comObj.postMessage({
	        sourceName,
	        targetName,
	        stream: StreamKind.START_COMPLETE,
	        streamId,
	        success: true
	      });
	    }, function (reason) {
	      comObj.postMessage({
	        sourceName,
	        targetName,
	        stream: StreamKind.START_COMPLETE,
	        streamId,
	        reason: wrapReason(reason)
	      });
	    });
	  }

	  _processStreamMessage(data) {
	    const streamId = data.streamId;
	    const sourceName = this.sourceName;
	    const targetName = data.sourceName;
	    const comObj = this.comObj;

	    switch (data.stream) {
	      case StreamKind.START_COMPLETE:
	        if (data.success) {
	          this.streamControllers[streamId].startCall.resolve();
	        } else {
	          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
	        }

	        break;

	      case StreamKind.PULL_COMPLETE:
	        if (data.success) {
	          this.streamControllers[streamId].pullCall.resolve();
	        } else {
	          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
	        }

	        break;

	      case StreamKind.PULL:
	        if (!this.streamSinks[streamId]) {
	          comObj.postMessage({
	            sourceName,
	            targetName,
	            stream: StreamKind.PULL_COMPLETE,
	            streamId,
	            success: true
	          });
	          break;
	        }

	        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
	          this.streamSinks[streamId].sinkCapability.resolve();
	        }

	        this.streamSinks[streamId].desiredSize = data.desiredSize;
	        const {
	          onPull
	        } = this.streamSinks[data.streamId];
	        new Promise(function (resolve) {
	          resolve(onPull && onPull());
	        }).then(function () {
	          comObj.postMessage({
	            sourceName,
	            targetName,
	            stream: StreamKind.PULL_COMPLETE,
	            streamId,
	            success: true
	          });
	        }, function (reason) {
	          comObj.postMessage({
	            sourceName,
	            targetName,
	            stream: StreamKind.PULL_COMPLETE,
	            streamId,
	            reason: wrapReason(reason)
	          });
	        });
	        break;

	      case StreamKind.ENQUEUE:
	        (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller");

	        if (this.streamControllers[streamId].isClosed) {
	          break;
	        }

	        this.streamControllers[streamId].controller.enqueue(data.chunk);
	        break;

	      case StreamKind.CLOSE:
	        (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller");

	        if (this.streamControllers[streamId].isClosed) {
	          break;
	        }

	        this.streamControllers[streamId].isClosed = true;
	        this.streamControllers[streamId].controller.close();

	        this._deleteStreamController(streamId);

	        break;

	      case StreamKind.ERROR:
	        (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller");
	        this.streamControllers[streamId].controller.error(wrapReason(data.reason));

	        this._deleteStreamController(streamId);

	        break;

	      case StreamKind.CANCEL_COMPLETE:
	        if (data.success) {
	          this.streamControllers[streamId].cancelCall.resolve();
	        } else {
	          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
	        }

	        this._deleteStreamController(streamId);

	        break;

	      case StreamKind.CANCEL:
	        if (!this.streamSinks[streamId]) {
	          break;
	        }

	        const {
	          onCancel
	        } = this.streamSinks[data.streamId];
	        new Promise(function (resolve) {
	          resolve(onCancel && onCancel(wrapReason(data.reason)));
	        }).then(function () {
	          comObj.postMessage({
	            sourceName,
	            targetName,
	            stream: StreamKind.CANCEL_COMPLETE,
	            streamId,
	            success: true
	          });
	        }, function (reason) {
	          comObj.postMessage({
	            sourceName,
	            targetName,
	            stream: StreamKind.CANCEL_COMPLETE,
	            streamId,
	            reason: wrapReason(reason)
	          });
	        });
	        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
	        this.streamSinks[streamId].isCancelled = true;
	        delete this.streamSinks[streamId];
	        break;

	      default:
	        throw new Error("Unexpected stream case");
	    }
	  }

	  async _deleteStreamController(streamId) {
	    await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {
	      return capability && capability.promise;
	    }));
	    delete this.streamControllers[streamId];
	  }

	  _postMessage(message, transfers) {
	    if (transfers && this.postMessageTransfers) {
	      this.comObj.postMessage(message, transfers);
	    } else {
	      this.comObj.postMessage(message);
	    }
	  }

	  destroy() {
	    this.comObj.removeEventListener("message", this._onComObjOnMessage);
	  }

	}

	exports.MessageHandler = MessageHandler;

	/***/ }),
	/* 14 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.Metadata = void 0;

	var _util = __w_pdfjs_require__(2);

	class Metadata {
	  constructor({
	    parsedData,
	    rawData
	  }) {
	    this._metadataMap = parsedData;
	    this._data = rawData;
	  }

	  getRaw() {
	    return this._data;
	  }

	  get(name) {
	    return this._metadataMap.get(name) ?? null;
	  }

	  getAll() {
	    return (0, _util.objectFromEntries)(this._metadataMap);
	  }

	  has(name) {
	    return this._metadataMap.has(name);
	  }

	}

	exports.Metadata = Metadata;

	/***/ }),
	/* 15 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.OptionalContentConfig = void 0;

	var _util = __w_pdfjs_require__(2);

	class OptionalContentGroup {
	  constructor(name, intent) {
	    this.visible = true;
	    this.name = name;
	    this.intent = intent;
	  }

	}

	class OptionalContentConfig {
	  constructor(data) {
	    this.name = null;
	    this.creator = null;
	    this._order = null;
	    this._groups = new Map();

	    if (data === null) {
	      return;
	    }

	    this.name = data.name;
	    this.creator = data.creator;
	    this._order = data.order;

	    for (const group of data.groups) {
	      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
	    }

	    if (data.baseState === "OFF") {
	      for (const group of this._groups) {
	        group.visible = false;
	      }
	    }

	    for (const on of data.on) {
	      this._groups.get(on).visible = true;
	    }

	    for (const off of data.off) {
	      this._groups.get(off).visible = false;
	    }
	  }

	  isVisible(group) {
	    if (group.type === "OCG") {
	      if (!this._groups.has(group.id)) {
	        (0, _util.warn)(`Optional content group not found: ${group.id}`);
	        return true;
	      }

	      return this._groups.get(group.id).visible;
	    } else if (group.type === "OCMD") {
	      if (group.expression) {
	        (0, _util.warn)("Visibility expression not supported yet.");
	      }

	      if (!group.policy || group.policy === "AnyOn") {
	        for (const id of group.ids) {
	          if (!this._groups.has(id)) {
	            (0, _util.warn)(`Optional content group not found: ${id}`);
	            return true;
	          }

	          if (this._groups.get(id).visible) {
	            return true;
	          }
	        }

	        return false;
	      } else if (group.policy === "AllOn") {
	        for (const id of group.ids) {
	          if (!this._groups.has(id)) {
	            (0, _util.warn)(`Optional content group not found: ${id}`);
	            return true;
	          }

	          if (!this._groups.get(id).visible) {
	            return false;
	          }
	        }

	        return true;
	      } else if (group.policy === "AnyOff") {
	        for (const id of group.ids) {
	          if (!this._groups.has(id)) {
	            (0, _util.warn)(`Optional content group not found: ${id}`);
	            return true;
	          }

	          if (!this._groups.get(id).visible) {
	            return true;
	          }
	        }

	        return false;
	      } else if (group.policy === "AllOff") {
	        for (const id of group.ids) {
	          if (!this._groups.has(id)) {
	            (0, _util.warn)(`Optional content group not found: ${id}`);
	            return true;
	          }

	          if (this._groups.get(id).visible) {
	            return false;
	          }
	        }

	        return true;
	      }

	      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
	      return true;
	    }

	    (0, _util.warn)(`Unknown group type ${group.type}.`);
	    return true;
	  }

	  setVisibility(id, visible = true) {
	    if (!this._groups.has(id)) {
	      (0, _util.warn)(`Optional content group not found: ${id}`);
	      return;
	    }

	    this._groups.get(id).visible = !!visible;
	  }

	  getOrder() {
	    if (!this._groups.size) {
	      return null;
	    }

	    if (this._order) {
	      return this._order.slice();
	    }

	    return Array.from(this._groups.keys());
	  }

	  getGroups() {
	    if (!this._groups.size) {
	      return null;
	    }

	    return (0, _util.objectFromEntries)(this._groups);
	  }

	  getGroup(id) {
	    return this._groups.get(id) || null;
	  }

	}

	exports.OptionalContentConfig = OptionalContentConfig;

	/***/ }),
	/* 16 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFDataTransportStream = void 0;

	var _util = __w_pdfjs_require__(2);

	var _display_utils = __w_pdfjs_require__(1);

	class PDFDataTransportStream {
	  constructor(params, pdfDataRangeTransport) {
	    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
	    this._queuedChunks = [];
	    this._progressiveDone = params.progressiveDone || false;
	    this._contentDispositionFilename = params.contentDispositionFilename || null;
	    const initialData = params.initialData;

	    if (initialData?.length > 0) {
	      const buffer = new Uint8Array(initialData).buffer;

	      this._queuedChunks.push(buffer);
	    }

	    this._pdfDataRangeTransport = pdfDataRangeTransport;
	    this._isStreamingSupported = !params.disableStream;
	    this._isRangeSupported = !params.disableRange;
	    this._contentLength = params.length;
	    this._fullRequestReader = null;
	    this._rangeReaders = [];

	    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
	      this._onReceiveData({
	        begin,
	        chunk
	      });
	    });

	    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
	      this._onProgress({
	        loaded,
	        total
	      });
	    });

	    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
	      this._onReceiveData({
	        chunk
	      });
	    });

	    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
	      this._onProgressiveDone();
	    });

	    this._pdfDataRangeTransport.transportReady();
	  }

	  _onReceiveData(args) {
	    const buffer = new Uint8Array(args.chunk).buffer;

	    if (args.begin === undefined) {
	      if (this._fullRequestReader) {
	        this._fullRequestReader._enqueue(buffer);
	      } else {
	        this._queuedChunks.push(buffer);
	      }
	    } else {
	      const found = this._rangeReaders.some(function (rangeReader) {
	        if (rangeReader._begin !== args.begin) {
	          return false;
	        }

	        rangeReader._enqueue(buffer);

	        return true;
	      });

	      (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
	    }
	  }

	  get _progressiveDataLength() {
	    return this._fullRequestReader?._loaded ?? 0;
	  }

	  _onProgress(evt) {
	    if (evt.total === undefined) {
	      const firstReader = this._rangeReaders[0];

	      if (firstReader?.onProgress) {
	        firstReader.onProgress({
	          loaded: evt.loaded
	        });
	      }
	    } else {
	      const fullReader = this._fullRequestReader;

	      if (fullReader?.onProgress) {
	        fullReader.onProgress({
	          loaded: evt.loaded,
	          total: evt.total
	        });
	      }
	    }
	  }

	  _onProgressiveDone() {
	    if (this._fullRequestReader) {
	      this._fullRequestReader.progressiveDone();
	    }

	    this._progressiveDone = true;
	  }

	  _removeRangeReader(reader) {
	    const i = this._rangeReaders.indexOf(reader);

	    if (i >= 0) {
	      this._rangeReaders.splice(i, 1);
	    }
	  }

	  getFullReader() {
	    (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
	    const queuedChunks = this._queuedChunks;
	    this._queuedChunks = null;
	    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
	  }

	  getRangeReader(begin, end) {
	    if (end <= this._progressiveDataLength) {
	      return null;
	    }

	    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);

	    this._pdfDataRangeTransport.requestDataRange(begin, end);

	    this._rangeReaders.push(reader);

	    return reader;
	  }

	  cancelAllRequests(reason) {
	    if (this._fullRequestReader) {
	      this._fullRequestReader.cancel(reason);
	    }

	    const readers = this._rangeReaders.slice(0);

	    readers.forEach(function (rangeReader) {
	      rangeReader.cancel(reason);
	    });

	    this._pdfDataRangeTransport.abort();
	  }

	}

	exports.PDFDataTransportStream = PDFDataTransportStream;

	class PDFDataTransportStreamReader {
	  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
	    this._stream = stream;
	    this._done = progressiveDone || false;
	    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
	    this._queuedChunks = queuedChunks || [];
	    this._loaded = 0;

	    for (const chunk of this._queuedChunks) {
	      this._loaded += chunk.byteLength;
	    }

	    this._requests = [];
	    this._headersReady = Promise.resolve();
	    stream._fullRequestReader = this;
	    this.onProgress = null;
	  }

	  _enqueue(chunk) {
	    if (this._done) {
	      return;
	    }

	    if (this._requests.length > 0) {
	      const requestCapability = this._requests.shift();

	      requestCapability.resolve({
	        value: chunk,
	        done: false
	      });
	    } else {
	      this._queuedChunks.push(chunk);
	    }

	    this._loaded += chunk.byteLength;
	  }

	  get headersReady() {
	    return this._headersReady;
	  }

	  get filename() {
	    return this._filename;
	  }

	  get isRangeSupported() {
	    return this._stream._isRangeSupported;
	  }

	  get isStreamingSupported() {
	    return this._stream._isStreamingSupported;
	  }

	  get contentLength() {
	    return this._stream._contentLength;
	  }

	  async read() {
	    if (this._queuedChunks.length > 0) {
	      const chunk = this._queuedChunks.shift();

	      return {
	        value: chunk,
	        done: false
	      };
	    }

	    if (this._done) {
	      return {
	        value: undefined,
	        done: true
	      };
	    }

	    const requestCapability = (0, _util.createPromiseCapability)();

	    this._requests.push(requestCapability);

	    return requestCapability.promise;
	  }

	  cancel(reason) {
	    this._done = true;

	    this._requests.forEach(function (requestCapability) {
	      requestCapability.resolve({
	        value: undefined,
	        done: true
	      });
	    });

	    this._requests = [];
	  }

	  progressiveDone() {
	    if (this._done) {
	      return;
	    }

	    this._done = true;
	  }

	}

	class PDFDataTransportStreamRangeReader {
	  constructor(stream, begin, end) {
	    this._stream = stream;
	    this._begin = begin;
	    this._end = end;
	    this._queuedChunk = null;
	    this._requests = [];
	    this._done = false;
	    this.onProgress = null;
	  }

	  _enqueue(chunk) {
	    if (this._done) {
	      return;
	    }

	    if (this._requests.length === 0) {
	      this._queuedChunk = chunk;
	    } else {
	      const requestsCapability = this._requests.shift();

	      requestsCapability.resolve({
	        value: chunk,
	        done: false
	      });

	      this._requests.forEach(function (requestCapability) {
	        requestCapability.resolve({
	          value: undefined,
	          done: true
	        });
	      });

	      this._requests = [];
	    }

	    this._done = true;

	    this._stream._removeRangeReader(this);
	  }

	  get isStreamingSupported() {
	    return false;
	  }

	  async read() {
	    if (this._queuedChunk) {
	      const chunk = this._queuedChunk;
	      this._queuedChunk = null;
	      return {
	        value: chunk,
	        done: false
	      };
	    }

	    if (this._done) {
	      return {
	        value: undefined,
	        done: true
	      };
	    }

	    const requestCapability = (0, _util.createPromiseCapability)();

	    this._requests.push(requestCapability);

	    return requestCapability.promise;
	  }

	  cancel(reason) {
	    this._done = true;

	    this._requests.forEach(function (requestCapability) {
	      requestCapability.resolve({
	        value: undefined,
	        done: true
	      });
	    });

	    this._requests = [];

	    this._stream._removeRangeReader(this);
	  }

	}

	/***/ }),
	/* 17 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.WebGLContext = void 0;

	var _util = __w_pdfjs_require__(2);

	class WebGLContext {
	  constructor({
	    enable = false
	  }) {
	    this._enabled = enable === true;
	  }

	  get isEnabled() {
	    let enabled = this._enabled;

	    if (enabled) {
	      enabled = WebGLUtils.tryInitGL();
	    }

	    return (0, _util.shadow)(this, "isEnabled", enabled);
	  }

	  composeSMask({
	    layer,
	    mask,
	    properties
	  }) {
	    return WebGLUtils.composeSMask(layer, mask, properties);
	  }

	  drawFigures({
	    width,
	    height,
	    backgroundColor,
	    figures,
	    context
	  }) {
	    return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
	  }

	  clear() {
	    WebGLUtils.cleanup();
	  }

	}

	exports.WebGLContext = WebGLContext;

	const WebGLUtils = function WebGLUtilsClosure() {
	  function loadShader(gl, code, shaderType) {
	    const shader = gl.createShader(shaderType);
	    gl.shaderSource(shader, code);
	    gl.compileShader(shader);
	    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

	    if (!compiled) {
	      const errorMsg = gl.getShaderInfoLog(shader);
	      throw new Error("Error during shader compilation: " + errorMsg);
	    }

	    return shader;
	  }

	  function createVertexShader(gl, code) {
	    return loadShader(gl, code, gl.VERTEX_SHADER);
	  }

	  function createFragmentShader(gl, code) {
	    return loadShader(gl, code, gl.FRAGMENT_SHADER);
	  }

	  function createProgram(gl, shaders) {
	    const program = gl.createProgram();

	    for (let i = 0, ii = shaders.length; i < ii; ++i) {
	      gl.attachShader(program, shaders[i]);
	    }

	    gl.linkProgram(program);
	    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);

	    if (!linked) {
	      const errorMsg = gl.getProgramInfoLog(program);
	      throw new Error("Error during program linking: " + errorMsg);
	    }

	    return program;
	  }

	  function createTexture(gl, image, textureId) {
	    gl.activeTexture(textureId);
	    const texture = gl.createTexture();
	    gl.bindTexture(gl.TEXTURE_2D, texture);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	    return texture;
	  }

	  let currentGL, currentCanvas;

	  function generateGL() {
	    if (currentGL) {
	      return;
	    }

	    currentCanvas = document.createElement("canvas");
	    currentGL = currentCanvas.getContext("webgl", {
	      premultipliedalpha: false
	    });
	  }

	  const smaskVertexShaderCode = "\
  attribute vec2 a_position;                                    \
  attribute vec2 a_texCoord;                                    \
                                                                \
  uniform vec2 u_resolution;                                    \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_texCoord = a_texCoord;                                    \
  }                                                             ";
	  const smaskFragmentShaderCode = "\
  precision mediump float;                                      \
                                                                \
  uniform vec4 u_backdrop;                                      \
  uniform int u_subtype;                                        \
  uniform sampler2D u_image;                                    \
  uniform sampler2D u_mask;                                     \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec4 imageColor = texture2D(u_image, v_texCoord);           \
    vec4 maskColor = texture2D(u_mask, v_texCoord);             \
    if (u_backdrop.a > 0.0) {                                   \
      maskColor.rgb = maskColor.rgb * maskColor.a +             \
                      u_backdrop.rgb * (1.0 - maskColor.a);     \
    }                                                           \
    float lum;                                                  \
    if (u_subtype == 0) {                                       \
      lum = maskColor.a;                                        \
    } else {                                                    \
      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
            maskColor.b * 0.11;                                 \
    }                                                           \
    imageColor.a *= lum;                                        \
    imageColor.rgb *= imageColor.a;                             \
    gl_FragColor = imageColor;                                  \
  }                                                             ";
	  let smaskCache = null;

	  function initSmaskGL() {
	    generateGL();
	    const canvas = currentCanvas;
	    currentCanvas = null;
	    const gl = currentGL;
	    currentGL = null;
	    const vertexShader = createVertexShader(gl, smaskVertexShaderCode);
	    const fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
	    const program = createProgram(gl, [vertexShader, fragmentShader]);
	    gl.useProgram(program);
	    const cache = {};
	    cache.gl = gl;
	    cache.canvas = canvas;
	    cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
	    cache.positionLocation = gl.getAttribLocation(program, "a_position");
	    cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
	    cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
	    const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
	    const texLayerLocation = gl.getUniformLocation(program, "u_image");
	    const texMaskLocation = gl.getUniformLocation(program, "u_mask");
	    const texCoordBuffer = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
	    gl.enableVertexAttribArray(texCoordLocation);
	    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
	    gl.uniform1i(texLayerLocation, 0);
	    gl.uniform1i(texMaskLocation, 1);
	    smaskCache = cache;
	  }

	  function composeSMask(layer, mask, properties) {
	    const width = layer.width,
	          height = layer.height;

	    if (!smaskCache) {
	      initSmaskGL();
	    }

	    const cache = smaskCache,
	          canvas = cache.canvas,
	          gl = cache.gl;
	    canvas.width = width;
	    canvas.height = height;
	    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    gl.uniform2f(cache.resolutionLocation, width, height);

	    if (properties.backdrop) {
	      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
	    } else {
	      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
	    }

	    gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
	    const texture = createTexture(gl, layer, gl.TEXTURE0);
	    const maskTexture = createTexture(gl, mask, gl.TEXTURE1);
	    const buffer = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
	    gl.enableVertexAttribArray(cache.positionLocation);
	    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
	    gl.clearColor(0, 0, 0, 0);
	    gl.enable(gl.BLEND);
	    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	    gl.clear(gl.COLOR_BUFFER_BIT);
	    gl.drawArrays(gl.TRIANGLES, 0, 6);
	    gl.flush();
	    gl.deleteTexture(texture);
	    gl.deleteTexture(maskTexture);
	    gl.deleteBuffer(buffer);
	    return canvas;
	  }

	  const figuresVertexShaderCode = "\
  attribute vec2 a_position;                                    \
  attribute vec3 a_color;                                       \
                                                                \
  uniform vec2 u_resolution;                                    \
  uniform vec2 u_scale;                                         \
  uniform vec2 u_offset;                                        \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    vec2 position = (a_position + u_offset) * u_scale;          \
    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_color = vec4(a_color / 255.0, 1.0);                       \
  }                                                             ";
	  const figuresFragmentShaderCode = "\
  precision mediump float;                                      \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    gl_FragColor = v_color;                                     \
  }                                                             ";
	  let figuresCache = null;

	  function initFiguresGL() {
	    generateGL();
	    const canvas = currentCanvas;
	    currentCanvas = null;
	    const gl = currentGL;
	    currentGL = null;
	    const vertexShader = createVertexShader(gl, figuresVertexShaderCode);
	    const fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
	    const program = createProgram(gl, [vertexShader, fragmentShader]);
	    gl.useProgram(program);
	    const cache = {};
	    cache.gl = gl;
	    cache.canvas = canvas;
	    cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
	    cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
	    cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
	    cache.positionLocation = gl.getAttribLocation(program, "a_position");
	    cache.colorLocation = gl.getAttribLocation(program, "a_color");
	    figuresCache = cache;
	  }

	  function drawFigures(width, height, backgroundColor, figures, context) {
	    if (!figuresCache) {
	      initFiguresGL();
	    }

	    const cache = figuresCache,
	          canvas = cache.canvas,
	          gl = cache.gl;
	    canvas.width = width;
	    canvas.height = height;
	    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    gl.uniform2f(cache.resolutionLocation, width, height);
	    let count = 0;

	    for (let i = 0, ii = figures.length; i < ii; i++) {
	      switch (figures[i].type) {
	        case "lattice":
	          const rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
	          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
	          break;

	        case "triangles":
	          count += figures[i].coords.length;
	          break;
	      }
	    }

	    const coords = new Float32Array(count * 2);
	    const colors = new Uint8Array(count * 3);
	    const coordsMap = context.coords,
	          colorsMap = context.colors;
	    let pIndex = 0,
	        cIndex = 0;

	    for (let i = 0, ii = figures.length; i < ii; i++) {
	      const figure = figures[i],
	            ps = figure.coords,
	            cs = figure.colors;

	      switch (figure.type) {
	        case "lattice":
	          const cols = figure.verticesPerRow;
	          const rows = ps.length / cols | 0;

	          for (let row = 1; row < rows; row++) {
	            let offset = row * cols + 1;

	            for (let col = 1; col < cols; col++, offset++) {
	              coords[pIndex] = coordsMap[ps[offset - cols - 1]];
	              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
	              coords[pIndex + 2] = coordsMap[ps[offset - cols]];
	              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
	              coords[pIndex + 4] = coordsMap[ps[offset - 1]];
	              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
	              colors[cIndex] = colorsMap[cs[offset - cols - 1]];
	              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
	              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
	              colors[cIndex + 3] = colorsMap[cs[offset - cols]];
	              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
	              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
	              colors[cIndex + 6] = colorsMap[cs[offset - 1]];
	              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
	              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
	              coords[pIndex + 6] = coords[pIndex + 2];
	              coords[pIndex + 7] = coords[pIndex + 3];
	              coords[pIndex + 8] = coords[pIndex + 4];
	              coords[pIndex + 9] = coords[pIndex + 5];
	              coords[pIndex + 10] = coordsMap[ps[offset]];
	              coords[pIndex + 11] = coordsMap[ps[offset] + 1];
	              colors[cIndex + 9] = colors[cIndex + 3];
	              colors[cIndex + 10] = colors[cIndex + 4];
	              colors[cIndex + 11] = colors[cIndex + 5];
	              colors[cIndex + 12] = colors[cIndex + 6];
	              colors[cIndex + 13] = colors[cIndex + 7];
	              colors[cIndex + 14] = colors[cIndex + 8];
	              colors[cIndex + 15] = colorsMap[cs[offset]];
	              colors[cIndex + 16] = colorsMap[cs[offset] + 1];
	              colors[cIndex + 17] = colorsMap[cs[offset] + 2];
	              pIndex += 12;
	              cIndex += 18;
	            }
	          }

	          break;

	        case "triangles":
	          for (let j = 0, jj = ps.length; j < jj; j++) {
	            coords[pIndex] = coordsMap[ps[j]];
	            coords[pIndex + 1] = coordsMap[ps[j] + 1];
	            colors[cIndex] = colorsMap[cs[j]];
	            colors[cIndex + 1] = colorsMap[cs[j] + 1];
	            colors[cIndex + 2] = colorsMap[cs[j] + 2];
	            pIndex += 2;
	            cIndex += 3;
	          }

	          break;
	      }
	    }

	    if (backgroundColor) {
	      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);
	    } else {
	      gl.clearColor(0, 0, 0, 0);
	    }

	    gl.clear(gl.COLOR_BUFFER_BIT);
	    const coordsBuffer = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
	    gl.enableVertexAttribArray(cache.positionLocation);
	    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
	    const colorsBuffer = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
	    gl.enableVertexAttribArray(cache.colorLocation);
	    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
	    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
	    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
	    gl.drawArrays(gl.TRIANGLES, 0, count);
	    gl.flush();
	    gl.deleteBuffer(coordsBuffer);
	    gl.deleteBuffer(colorsBuffer);
	    return canvas;
	  }

	  return {
	    tryInitGL() {
	      try {
	        generateGL();
	        return !!currentGL;
	      } catch (ex) {}

	      return false;
	    },

	    composeSMask,
	    drawFigures,

	    cleanup() {
	      if (smaskCache?.canvas) {
	        smaskCache.canvas.width = 0;
	        smaskCache.canvas.height = 0;
	      }

	      if (figuresCache?.canvas) {
	        figuresCache.canvas.width = 0;
	        figuresCache.canvas.height = 0;
	      }

	      smaskCache = null;
	      figuresCache = null;
	    }

	  };
	}();

	/***/ }),
	/* 18 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.AnnotationLayer = void 0;

	var _display_utils = __w_pdfjs_require__(1);

	var _util = __w_pdfjs_require__(2);

	var _annotation_storage = __w_pdfjs_require__(8);

	var _scripting_utils = __w_pdfjs_require__(19);

	class AnnotationElementFactory {
	  static create(parameters) {
	    const subtype = parameters.data.annotationType;

	    switch (subtype) {
	      case _util.AnnotationType.LINK:
	        return new LinkAnnotationElement(parameters);

	      case _util.AnnotationType.TEXT:
	        return new TextAnnotationElement(parameters);

	      case _util.AnnotationType.WIDGET:
	        const fieldType = parameters.data.fieldType;

	        switch (fieldType) {
	          case "Tx":
	            return new TextWidgetAnnotationElement(parameters);

	          case "Btn":
	            if (parameters.data.radioButton) {
	              return new RadioButtonWidgetAnnotationElement(parameters);
	            } else if (parameters.data.checkBox) {
	              return new CheckboxWidgetAnnotationElement(parameters);
	            }

	            return new PushButtonWidgetAnnotationElement(parameters);

	          case "Ch":
	            return new ChoiceWidgetAnnotationElement(parameters);
	        }

	        return new WidgetAnnotationElement(parameters);

	      case _util.AnnotationType.POPUP:
	        return new PopupAnnotationElement(parameters);

	      case _util.AnnotationType.FREETEXT:
	        return new FreeTextAnnotationElement(parameters);

	      case _util.AnnotationType.LINE:
	        return new LineAnnotationElement(parameters);

	      case _util.AnnotationType.SQUARE:
	        return new SquareAnnotationElement(parameters);

	      case _util.AnnotationType.CIRCLE:
	        return new CircleAnnotationElement(parameters);

	      case _util.AnnotationType.POLYLINE:
	        return new PolylineAnnotationElement(parameters);

	      case _util.AnnotationType.CARET:
	        return new CaretAnnotationElement(parameters);

	      case _util.AnnotationType.INK:
	        return new InkAnnotationElement(parameters);

	      case _util.AnnotationType.POLYGON:
	        return new PolygonAnnotationElement(parameters);

	      case _util.AnnotationType.HIGHLIGHT:
	        return new HighlightAnnotationElement(parameters);

	      case _util.AnnotationType.UNDERLINE:
	        return new UnderlineAnnotationElement(parameters);

	      case _util.AnnotationType.SQUIGGLY:
	        return new SquigglyAnnotationElement(parameters);

	      case _util.AnnotationType.STRIKEOUT:
	        return new StrikeOutAnnotationElement(parameters);

	      case _util.AnnotationType.STAMP:
	        return new StampAnnotationElement(parameters);

	      case _util.AnnotationType.FILEATTACHMENT:
	        return new FileAttachmentAnnotationElement(parameters);

	      default:
	        return new AnnotationElement(parameters);
	    }
	  }

	}

	class AnnotationElement {
	  constructor(parameters, {
	    isRenderable = false,
	    ignoreBorder = false,
	    createQuadrilaterals = false
	  } = {}) {
	    this.isRenderable = isRenderable;
	    this.data = parameters.data;
	    this.layer = parameters.layer;
	    this.page = parameters.page;
	    this.viewport = parameters.viewport;
	    this.linkService = parameters.linkService;
	    this.downloadManager = parameters.downloadManager;
	    this.imageResourcesPath = parameters.imageResourcesPath;
	    this.renderInteractiveForms = parameters.renderInteractiveForms;
	    this.svgFactory = parameters.svgFactory;
	    this.annotationStorage = parameters.annotationStorage;
	    this.enableScripting = parameters.enableScripting;
	    this.hasJSActions = parameters.hasJSActions;
	    this._mouseState = parameters.mouseState;

	    if (isRenderable) {
	      this.container = this._createContainer(ignoreBorder);
	    }

	    if (createQuadrilaterals) {
	      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
	    }
	  }

	  _createContainer(ignoreBorder = false) {
	    const data = this.data,
	          page = this.page,
	          viewport = this.viewport;
	    const container = document.createElement("section");
	    let width = data.rect[2] - data.rect[0];
	    let height = data.rect[3] - data.rect[1];
	    container.setAttribute("data-annotation-id", data.id);

	    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

	    container.style.transform = `matrix(${viewport.transform.join(",")})`;
	    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;

	    if (!ignoreBorder && data.borderStyle.width > 0) {
	      container.style.borderWidth = `${data.borderStyle.width}px`;

	      if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
	        width = width - 2 * data.borderStyle.width;
	        height = height - 2 * data.borderStyle.width;
	      }

	      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
	      const verticalRadius = data.borderStyle.verticalCornerRadius;

	      if (horizontalRadius > 0 || verticalRadius > 0) {
	        const radius = `${horizontalRadius}px / ${verticalRadius}px`;
	        container.style.borderRadius = radius;
	      }

	      switch (data.borderStyle.style) {
	        case _util.AnnotationBorderStyleType.SOLID:
	          container.style.borderStyle = "solid";
	          break;

	        case _util.AnnotationBorderStyleType.DASHED:
	          container.style.borderStyle = "dashed";
	          break;

	        case _util.AnnotationBorderStyleType.BEVELED:
	          (0, _util.warn)("Unimplemented border style: beveled");
	          break;

	        case _util.AnnotationBorderStyleType.INSET:
	          (0, _util.warn)("Unimplemented border style: inset");
	          break;

	        case _util.AnnotationBorderStyleType.UNDERLINE:
	          container.style.borderBottomStyle = "solid";
	          break;
	      }

	      if (data.color) {
	        container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
	      } else {
	        container.style.borderWidth = 0;
	      }
	    }

	    container.style.left = `${rect[0]}px`;
	    container.style.top = `${rect[1]}px`;
	    container.style.width = `${width}px`;
	    container.style.height = `${height}px`;
	    return container;
	  }

	  _createQuadrilaterals(ignoreBorder = false) {
	    if (!this.data.quadPoints) {
	      return null;
	    }

	    const quadrilaterals = [];
	    const savedRect = this.data.rect;

	    for (const quadPoint of this.data.quadPoints) {
	      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
	      quadrilaterals.push(this._createContainer(ignoreBorder));
	    }

	    this.data.rect = savedRect;
	    return quadrilaterals;
	  }

	  _createPopup(trigger, data) {
	    let container = this.container;

	    if (this.quadrilaterals) {
	      trigger = trigger || this.quadrilaterals;
	      container = this.quadrilaterals[0];
	    }

	    if (!trigger) {
	      trigger = document.createElement("div");
	      trigger.style.height = container.style.height;
	      trigger.style.width = container.style.width;
	      container.appendChild(trigger);
	    }

	    const popupElement = new PopupElement({
	      container,
	      trigger,
	      color: data.color,
	      title: data.title,
	      modificationDate: data.modificationDate,
	      contents: data.contents,
	      hideWrapper: true
	    });
	    const popup = popupElement.render();
	    popup.style.left = container.style.width;
	    container.appendChild(popup);
	  }

	  _renderQuadrilaterals(className) {
	    this.quadrilaterals.forEach(quadrilateral => {
	      quadrilateral.className = className;
	    });
	    return this.quadrilaterals;
	  }

	  render() {
	    (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
	  }

	}

	class LinkAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
	    super(parameters, {
	      isRenderable,
	      createQuadrilaterals: true
	    });
	  }

	  render() {
	    const {
	      data,
	      linkService
	    } = this;
	    const link = document.createElement("a");

	    if (data.url) {
	      (0, _display_utils.addLinkAttributes)(link, {
	        url: data.url,
	        target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,
	        rel: linkService.externalLinkRel,
	        enabled: linkService.externalLinkEnabled
	      });
	    } else if (data.action) {
	      this._bindNamedAction(link, data.action);
	    } else if (data.dest) {
	      this._bindLink(link, data.dest);
	    } else if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
	      this._bindJSAction(link, data);
	    } else {
	      this._bindLink(link, "");
	    }

	    if (this.quadrilaterals) {
	      return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
	        const linkElement = index === 0 ? link : link.cloneNode();
	        quadrilateral.appendChild(linkElement);
	        return quadrilateral;
	      });
	    }

	    this.container.className = "linkAnnotation";
	    this.container.appendChild(link);
	    return this.container;
	  }

	  _bindLink(link, destination) {
	    link.href = this.linkService.getDestinationHash(destination);

	    link.onclick = () => {
	      if (destination) {
	        this.linkService.goToDestination(destination);
	      }

	      return false;
	    };

	    if (destination || destination === "") {
	      link.className = "internalLink";
	    }
	  }

	  _bindNamedAction(link, action) {
	    link.href = this.linkService.getAnchorUrl("");

	    link.onclick = () => {
	      this.linkService.executeNamedAction(action);
	      return false;
	    };

	    link.className = "internalLink";
	  }

	  _bindJSAction(link, data) {
	    link.href = this.linkService.getAnchorUrl("");
	    const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

	    for (const name of Object.keys(data.actions)) {
	      const jsName = map.get(name);

	      if (!jsName) {
	        continue;
	      }

	      link[jsName] = () => {
	        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
	          source: this,
	          detail: {
	            id: data.id,
	            name
	          }
	        });
	        return false;
	      };
	    }

	    link.className = "internalLink";
	  }

	}

	class TextAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable
	    });
	  }

	  render() {
	    this.container.className = "textAnnotation";
	    const image = document.createElement("img");
	    image.style.height = this.container.style.height;
	    image.style.width = this.container.style.width;
	    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
	    image.alt = "[{{type}} Annotation]";
	    image.dataset.l10nId = "text_annotation_type";
	    image.dataset.l10nArgs = JSON.stringify({
	      type: this.data.name
	    });

	    if (!this.data.hasPopup) {
	      this._createPopup(image, this.data);
	    }

	    this.container.appendChild(image);
	    return this.container;
	  }

	}

	class WidgetAnnotationElement extends AnnotationElement {
	  render() {
	    if (this.data.alternativeText) {
	      this.container.title = this.data.alternativeText;
	    }

	    return this.container;
	  }

	  _getKeyModifier(event) {
	    return navigator.platform.includes("Win") && event.ctrlKey || navigator.platform.includes("Mac") && event.metaKey;
	  }

	  _setEventListener(element, baseName, eventName, valueGetter) {
	    if (baseName.includes("mouse")) {
	      element.addEventListener(baseName, event => {
	        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
	          source: this,
	          detail: {
	            id: this.data.id,
	            name: eventName,
	            value: valueGetter(event),
	            shift: event.shiftKey,
	            modifier: this._getKeyModifier(event)
	          }
	        });
	      });
	    } else {
	      element.addEventListener(baseName, event => {
	        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
	          source: this,
	          detail: {
	            id: this.data.id,
	            name: eventName,
	            value: event.target.checked
	          }
	        });
	      });
	    }
	  }

	  _setEventListeners(element, names, getter) {
	    for (const [baseName, eventName] of names) {
	      if (eventName === "Action" || this.data.actions?.[eventName]) {
	        this._setEventListener(element, baseName, eventName, getter);
	      }
	    }
	  }

	  _setColor(event) {
	    const {
	      detail,
	      target
	    } = event;
	    const {
	      style
	    } = target;

	    for (const name of ["bgColor", "fillColor", "fgColor", "textColor", "borderColor", "strokeColor"]) {
	      let color = detail[name];

	      if (!color) {
	        continue;
	      }

	      color = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));

	      switch (name) {
	        case "bgColor":
	        case "fillColor":
	          style.backgroundColor = color;
	          break;

	        case "fgColor":
	        case "textColor":
	          style.color = color;
	          break;

	        case "borderColor":
	        case "strokeColor":
	          style.borderColor = color;
	          break;
	      }
	    }
	  }

	}

	class TextWidgetAnnotationElement extends WidgetAnnotationElement {
	  constructor(parameters) {
	    const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
	    super(parameters, {
	      isRenderable
	    });
	  }

	  render() {
	    const storage = this.annotationStorage;
	    const id = this.data.id;
	    this.container.className = "textWidgetAnnotation";
	    let element = null;

	    if (this.renderInteractiveForms) {
	      const textContent = storage.getValue(id, {
	        value: this.data.fieldValue
	      }).value;
	      const elementData = {
	        userValue: null,
	        formattedValue: null,
	        beforeInputSelectionRange: null,
	        beforeInputValue: null
	      };

	      if (this.data.multiLine) {
	        element = document.createElement("textarea");
	        element.textContent = textContent;
	      } else {
	        element = document.createElement("input");
	        element.type = "text";
	        element.setAttribute("value", textContent);
	      }

	      elementData.userValue = textContent;
	      element.setAttribute("id", id);
	      element.addEventListener("input", function (event) {
	        storage.setValue(id, {
	          value: event.target.value
	        });
	      });

	      let blurListener = event => {
	        if (elementData.formattedValue) {
	          event.target.value = elementData.formattedValue;
	        }

	        event.target.setSelectionRange(0, 0);
	        elementData.beforeInputSelectionRange = null;
	      };

	      if (this.enableScripting && this.hasJSActions) {
	        element.addEventListener("focus", event => {
	          if (elementData.userValue) {
	            event.target.value = elementData.userValue;
	          }
	        });
	        element.addEventListener("updatefromsandbox", event => {
	          const {
	            detail
	          } = event;
	          const actions = {
	            value() {
	              elementData.userValue = detail.value || "";
	              storage.setValue(id, {
	                value: elementData.userValue.toString()
	              });

	              if (!elementData.formattedValue) {
	                event.target.value = elementData.userValue;
	              }
	            },

	            valueAsString() {
	              elementData.formattedValue = detail.valueAsString || "";

	              if (event.target !== document.activeElement) {
	                event.target.value = elementData.formattedValue;
	              }

	              storage.setValue(id, {
	                formattedValue: elementData.formattedValue
	              });
	            },

	            focus() {
	              setTimeout(() => event.target.focus({
	                preventScroll: false
	              }), 0);
	            },

	            userName() {
	              event.target.title = detail.userName;
	            },

	            hidden() {
	              event.target.style.visibility = detail.hidden ? "hidden" : "visible";
	              storage.setValue(id, {
	                hidden: detail.hidden
	              });
	            },

	            editable() {
	              event.target.disabled = !detail.editable;
	            },

	            selRange() {
	              const [selStart, selEnd] = detail.selRange;

	              if (selStart >= 0 && selEnd < event.target.value.length) {
	                event.target.setSelectionRange(selStart, selEnd);
	              }
	            }

	          };
	          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());

	          this._setColor(event);
	        });
	        element.addEventListener("keydown", event => {
	          elementData.beforeInputValue = event.target.value;
	          let commitKey = -1;

	          if (event.key === "Escape") {
	            commitKey = 0;
	          } else if (event.key === "Enter") {
	            commitKey = 2;
	          } else if (event.key === "Tab") {
	            commitKey = 3;
	          }

	          if (commitKey === -1) {
	            return;
	          }

	          elementData.userValue = event.target.value;
	          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
	            source: this,
	            detail: {
	              id,
	              name: "Keystroke",
	              value: event.target.value,
	              willCommit: true,
	              commitKey,
	              selStart: event.target.selectionStart,
	              selEnd: event.target.selectionEnd
	            }
	          });
	        });
	        const _blurListener = blurListener;
	        blurListener = null;
	        element.addEventListener("blur", event => {
	          if (this._mouseState.isDown) {
	            elementData.userValue = event.target.value;
	            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
	              source: this,
	              detail: {
	                id,
	                name: "Keystroke",
	                value: event.target.value,
	                willCommit: true,
	                commitKey: 1,
	                selStart: event.target.selectionStart,
	                selEnd: event.target.selectionEnd
	              }
	            });
	          }

	          _blurListener(event);
	        });
	        element.addEventListener("mousedown", event => {
	          elementData.beforeInputValue = event.target.value;
	          elementData.beforeInputSelectionRange = null;
	        });
	        element.addEventListener("keyup", event => {
	          if (event.target.selectionStart === event.target.selectionEnd) {
	            elementData.beforeInputSelectionRange = null;
	          }
	        });
	        element.addEventListener("select", event => {
	          elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
	        });

	        if (this.data.actions?.Keystroke) {
	          element.addEventListener("input", event => {
	            let selStart = -1;
	            let selEnd = -1;

	            if (elementData.beforeInputSelectionRange) {
	              [selStart, selEnd] = elementData.beforeInputSelectionRange;
	            }

	            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
	              source: this,
	              detail: {
	                id,
	                name: "Keystroke",
	                value: elementData.beforeInputValue,
	                change: event.data,
	                willCommit: false,
	                selStart,
	                selEnd
	              }
	            });
	          });
	        }

	        this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
	      }

	      if (blurListener) {
	        element.addEventListener("blur", blurListener);
	      }

	      element.disabled = this.data.readOnly;
	      element.name = this.data.fieldName;

	      if (this.data.maxLen !== null) {
	        element.maxLength = this.data.maxLen;
	      }

	      if (this.data.comb) {
	        const fieldWidth = this.data.rect[2] - this.data.rect[0];
	        const combWidth = fieldWidth / this.data.maxLen;
	        element.classList.add("comb");
	        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
	      }
	    } else {
	      element = document.createElement("div");
	      element.textContent = this.data.fieldValue;
	      element.style.verticalAlign = "middle";
	      element.style.display = "table-cell";
	    }

	    this._setTextStyle(element);

	    this.container.appendChild(element);
	    return this.container;
	  }

	  _setTextStyle(element) {
	    const TEXT_ALIGNMENT = ["left", "center", "right"];
	    const {
	      fontSize,
	      fontColor
	    } = this.data.defaultAppearanceData;
	    const style = element.style;

	    if (fontSize) {
	      style.fontSize = `${fontSize}px`;
	    }

	    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

	    if (this.data.textAlignment !== null) {
	      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
	    }
	  }

	}

	class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
	  constructor(parameters) {
	    super(parameters, {
	      isRenderable: parameters.renderInteractiveForms
	    });
	  }

	  render() {
	    const storage = this.annotationStorage;
	    const data = this.data;
	    const id = data.id;
	    const value = storage.getValue(id, {
	      value: data.fieldValue && (data.exportValue && data.exportValue === data.fieldValue || !data.exportValue && data.fieldValue !== "Off")
	    }).value;
	    this.container.className = "buttonWidgetAnnotation checkBox";
	    const element = document.createElement("input");
	    element.disabled = data.readOnly;
	    element.type = "checkbox";
	    element.name = this.data.fieldName;

	    if (value) {
	      element.setAttribute("checked", true);
	    }

	    element.setAttribute("id", id);
	    element.addEventListener("change", function (event) {
	      const name = event.target.name;

	      for (const checkbox of document.getElementsByName(name)) {
	        if (checkbox !== event.target) {
	          checkbox.checked = false;
	          storage.setValue(checkbox.parentNode.getAttribute("data-annotation-id"), {
	            value: false
	          });
	        }
	      }

	      storage.setValue(id, {
	        value: event.target.checked
	      });
	    });

	    if (this.enableScripting && this.hasJSActions) {
	      element.addEventListener("updatefromsandbox", event => {
	        const {
	          detail
	        } = event;
	        const actions = {
	          value() {
	            event.target.checked = detail.value !== "Off";
	            storage.setValue(id, {
	              value: event.target.checked
	            });
	          },

	          focus() {
	            setTimeout(() => event.target.focus({
	              preventScroll: false
	            }), 0);
	          },

	          hidden() {
	            event.target.style.visibility = detail.hidden ? "hidden" : "visible";
	            storage.setValue(id, {
	              hidden: detail.hidden
	            });
	          },

	          editable() {
	            event.target.disabled = !detail.editable;
	          }

	        };
	        Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());

	        this._setColor(event);
	      });

	      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
	    }

	    this.container.appendChild(element);
	    return this.container;
	  }

	}

	class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
	  constructor(parameters) {
	    super(parameters, {
	      isRenderable: parameters.renderInteractiveForms
	    });
	  }

	  render() {
	    this.container.className = "buttonWidgetAnnotation radioButton";
	    const storage = this.annotationStorage;
	    const data = this.data;
	    const id = data.id;
	    const value = storage.getValue(id, {
	      value: data.fieldValue === data.buttonValue
	    }).value;
	    const element = document.createElement("input");
	    element.disabled = data.readOnly;
	    element.type = "radio";
	    element.name = data.fieldName;

	    if (value) {
	      element.setAttribute("checked", true);
	    }

	    element.setAttribute("id", id);
	    element.addEventListener("change", function (event) {
	      const {
	        target
	      } = event;

	      for (const radio of document.getElementsByName(target.name)) {
	        if (radio !== target) {
	          storage.setValue(radio.getAttribute("id"), {
	            value: false
	          });
	        }
	      }

	      storage.setValue(id, {
	        value: target.checked
	      });
	    });

	    if (this.enableScripting && this.hasJSActions) {
	      const pdfButtonValue = data.buttonValue;
	      element.addEventListener("updatefromsandbox", event => {
	        const {
	          detail
	        } = event;
	        const actions = {
	          value() {
	            const checked = pdfButtonValue === detail.value;

	            for (const radio of document.getElementsByName(event.target.name)) {
	              const radioId = radio.getAttribute("id");
	              radio.checked = radioId === id && checked;
	              storage.setValue(radioId, {
	                value: radio.checked
	              });
	            }
	          },

	          focus() {
	            setTimeout(() => event.target.focus({
	              preventScroll: false
	            }), 0);
	          },

	          hidden() {
	            event.target.style.visibility = detail.hidden ? "hidden" : "visible";
	            storage.setValue(id, {
	              hidden: detail.hidden
	            });
	          },

	          editable() {
	            event.target.disabled = !detail.editable;
	          }

	        };
	        Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());

	        this._setColor(event);
	      });

	      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
	    }

	    this.container.appendChild(element);
	    return this.container;
	  }

	}

	class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
	  render() {
	    const container = super.render();
	    container.className = "buttonWidgetAnnotation pushButton";

	    if (this.data.alternativeText) {
	      container.title = this.data.alternativeText;
	    }

	    return container;
	  }

	}

	class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
	  constructor(parameters) {
	    super(parameters, {
	      isRenderable: parameters.renderInteractiveForms
	    });
	  }

	  render() {
	    this.container.className = "choiceWidgetAnnotation";
	    const storage = this.annotationStorage;
	    const id = this.data.id;
	    storage.getValue(id, {
	      value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined
	    });
	    const selectElement = document.createElement("select");
	    selectElement.disabled = this.data.readOnly;
	    selectElement.name = this.data.fieldName;
	    selectElement.setAttribute("id", id);

	    if (!this.data.combo) {
	      selectElement.size = this.data.options.length;

	      if (this.data.multiSelect) {
	        selectElement.multiple = true;
	      }
	    }

	    for (const option of this.data.options) {
	      const optionElement = document.createElement("option");
	      optionElement.textContent = option.displayValue;
	      optionElement.value = option.exportValue;

	      if (this.data.fieldValue.includes(option.exportValue)) {
	        optionElement.setAttribute("selected", true);
	      }

	      selectElement.appendChild(optionElement);
	    }

	    const getValue = (event, isExport) => {
	      const name = isExport ? "value" : "textContent";
	      const options = event.target.options;

	      if (!event.target.multiple) {
	        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
	      }

	      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
	    };

	    const getItems = event => {
	      const options = event.target.options;
	      return Array.prototype.map.call(options, option => {
	        return {
	          displayValue: option.textContent,
	          exportValue: option.value
	        };
	      });
	    };

	    if (this.enableScripting && this.hasJSActions) {
	      selectElement.addEventListener("updatefromsandbox", event => {
	        const {
	          detail
	        } = event;
	        const actions = {
	          value() {
	            const options = selectElement.options;
	            const value = detail.value;
	            const values = new Set(Array.isArray(value) ? value : [value]);
	            Array.prototype.forEach.call(options, option => {
	              option.selected = values.has(option.value);
	            });
	            storage.setValue(id, {
	              value: getValue(event, true)
	            });
	          },

	          multipleSelection() {
	            selectElement.multiple = true;
	          },

	          remove() {
	            const options = selectElement.options;
	            const index = detail.remove;
	            options[index].selected = false;
	            selectElement.remove(index);

	            if (options.length > 0) {
	              const i = Array.prototype.findIndex.call(options, option => option.selected);

	              if (i === -1) {
	                options[0].selected = true;
	              }
	            }

	            storage.setValue(id, {
	              value: getValue(event, true),
	              items: getItems(event)
	            });
	          },

	          clear() {
	            while (selectElement.length !== 0) {
	              selectElement.remove(0);
	            }

	            storage.setValue(id, {
	              value: null,
	              items: []
	            });
	          },

	          insert() {
	            const {
	              index,
	              displayValue,
	              exportValue
	            } = detail.insert;
	            const optionElement = document.createElement("option");
	            optionElement.textContent = displayValue;
	            optionElement.value = exportValue;
	            selectElement.insertBefore(optionElement, selectElement.children[index]);
	            storage.setValue(id, {
	              value: getValue(event, true),
	              items: getItems(event)
	            });
	          },

	          items() {
	            const {
	              items
	            } = detail;

	            while (selectElement.length !== 0) {
	              selectElement.remove(0);
	            }

	            for (const item of items) {
	              const {
	                displayValue,
	                exportValue
	              } = item;
	              const optionElement = document.createElement("option");
	              optionElement.textContent = displayValue;
	              optionElement.value = exportValue;
	              selectElement.appendChild(optionElement);
	            }

	            if (selectElement.options.length > 0) {
	              selectElement.options[0].selected = true;
	            }

	            storage.setValue(id, {
	              value: getValue(event, true),
	              items: getItems(event)
	            });
	          },

	          indices() {
	            const indices = new Set(detail.indices);
	            const options = event.target.options;
	            Array.prototype.forEach.call(options, (option, i) => {
	              option.selected = indices.has(i);
	            });
	            storage.setValue(id, {
	              value: getValue(event, true)
	            });
	          },

	          focus() {
	            setTimeout(() => event.target.focus({
	              preventScroll: false
	            }), 0);
	          },

	          hidden() {
	            event.target.style.visibility = detail.hidden ? "hidden" : "visible";
	            storage.setValue(id, {
	              hidden: detail.hidden
	            });
	          },

	          editable() {
	            event.target.disabled = !detail.editable;
	          }

	        };
	        Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());

	        this._setColor(event);
	      });
	      selectElement.addEventListener("input", event => {
	        const exportValue = getValue(event, true);
	        const value = getValue(event, false);
	        storage.setValue(id, {
	          value: exportValue
	        });
	        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
	          source: this,
	          detail: {
	            id,
	            name: "Keystroke",
	            value,
	            changeEx: exportValue,
	            willCommit: true,
	            commitKey: 1,
	            keyDown: false
	          }
	        });
	      });

	      this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], event => event.target.checked);
	    } else {
	      selectElement.addEventListener("input", function (event) {
	        storage.setValue(id, {
	          value: getValue(event)
	        });
	      });
	    }

	    this.container.appendChild(selectElement);
	    return this.container;
	  }

	}

	class PopupAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable
	    });
	  }

	  render() {
	    const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
	    this.container.className = "popupAnnotation";

	    if (IGNORE_TYPES.includes(this.data.parentType)) {
	      return this.container;
	    }

	    const selector = `[data-annotation-id="${this.data.parentId}"]`;
	    const parentElements = this.layer.querySelectorAll(selector);

	    if (parentElements.length === 0) {
	      return this.container;
	    }

	    const popup = new PopupElement({
	      container: this.container,
	      trigger: Array.from(parentElements),
	      color: this.data.color,
	      title: this.data.title,
	      modificationDate: this.data.modificationDate,
	      contents: this.data.contents
	    });
	    const page = this.page;

	    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

	    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
	    const popupTop = rect[1];
	    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;
	    this.container.style.left = `${popupLeft}px`;
	    this.container.style.top = `${popupTop}px`;
	    this.container.appendChild(popup.render());
	    return this.container;
	  }

	}

	class PopupElement {
	  constructor(parameters) {
	    this.container = parameters.container;
	    this.trigger = parameters.trigger;
	    this.color = parameters.color;
	    this.title = parameters.title;
	    this.modificationDate = parameters.modificationDate;
	    this.contents = parameters.contents;
	    this.hideWrapper = parameters.hideWrapper || false;
	    this.pinned = false;
	  }

	  render() {
	    const BACKGROUND_ENLIGHT = 0.7;
	    const wrapper = document.createElement("div");
	    wrapper.className = "popupWrapper";
	    this.hideElement = this.hideWrapper ? wrapper : this.container;
	    this.hideElement.hidden = true;
	    const popup = document.createElement("div");
	    popup.className = "popup";
	    const color = this.color;

	    if (color) {
	      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
	      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
	      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
	      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
	    }

	    const title = document.createElement("h1");
	    title.textContent = this.title;
	    popup.appendChild(title);

	    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

	    if (dateObject) {
	      const modificationDate = document.createElement("span");
	      modificationDate.textContent = "{{date}}, {{time}}";
	      modificationDate.dataset.l10nId = "annotation_date_string";
	      modificationDate.dataset.l10nArgs = JSON.stringify({
	        date: dateObject.toLocaleDateString(),
	        time: dateObject.toLocaleTimeString()
	      });
	      popup.appendChild(modificationDate);
	    }

	    const contents = this._formatContents(this.contents);

	    popup.appendChild(contents);

	    if (!Array.isArray(this.trigger)) {
	      this.trigger = [this.trigger];
	    }

	    this.trigger.forEach(element => {
	      element.addEventListener("click", this._toggle.bind(this));
	      element.addEventListener("mouseover", this._show.bind(this, false));
	      element.addEventListener("mouseout", this._hide.bind(this, false));
	    });
	    popup.addEventListener("click", this._hide.bind(this, true));
	    wrapper.appendChild(popup);
	    return wrapper;
	  }

	  _formatContents(contents) {
	    const p = document.createElement("p");
	    const lines = contents.split(/(?:\r\n?|\n)/);

	    for (let i = 0, ii = lines.length; i < ii; ++i) {
	      const line = lines[i];
	      p.appendChild(document.createTextNode(line));

	      if (i < ii - 1) {
	        p.appendChild(document.createElement("br"));
	      }
	    }

	    return p;
	  }

	  _toggle() {
	    if (this.pinned) {
	      this._hide(true);
	    } else {
	      this._show(true);
	    }
	  }

	  _show(pin = false) {
	    if (pin) {
	      this.pinned = true;
	    }

	    if (this.hideElement.hidden) {
	      this.hideElement.hidden = false;
	      this.container.style.zIndex += 1;
	    }
	  }

	  _hide(unpin = true) {
	    if (unpin) {
	      this.pinned = false;
	    }

	    if (!this.hideElement.hidden && !this.pinned) {
	      this.hideElement.hidden = true;
	      this.container.style.zIndex -= 1;
	    }
	  }

	}

	class FreeTextAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	  }

	  render() {
	    this.container.className = "freeTextAnnotation";

	    if (!this.data.hasPopup) {
	      this._createPopup(null, this.data);
	    }

	    return this.container;
	  }

	}

	class LineAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	  }

	  render() {
	    this.container.className = "lineAnnotation";
	    const data = this.data;
	    const width = data.rect[2] - data.rect[0];
	    const height = data.rect[3] - data.rect[1];
	    const svg = this.svgFactory.create(width, height);
	    const line = this.svgFactory.createElement("svg:line");
	    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
	    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
	    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
	    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
	    line.setAttribute("stroke-width", data.borderStyle.width || 1);
	    line.setAttribute("stroke", "transparent");
	    svg.appendChild(line);
	    this.container.append(svg);

	    this._createPopup(line, data);

	    return this.container;
	  }

	}

	class SquareAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	  }

	  render() {
	    this.container.className = "squareAnnotation";
	    const data = this.data;
	    const width = data.rect[2] - data.rect[0];
	    const height = data.rect[3] - data.rect[1];
	    const svg = this.svgFactory.create(width, height);
	    const borderWidth = data.borderStyle.width;
	    const square = this.svgFactory.createElement("svg:rect");
	    square.setAttribute("x", borderWidth / 2);
	    square.setAttribute("y", borderWidth / 2);
	    square.setAttribute("width", width - borderWidth);
	    square.setAttribute("height", height - borderWidth);
	    square.setAttribute("stroke-width", borderWidth || 1);
	    square.setAttribute("stroke", "transparent");
	    square.setAttribute("fill", "none");
	    svg.appendChild(square);
	    this.container.append(svg);

	    this._createPopup(square, data);

	    return this.container;
	  }

	}

	class CircleAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	  }

	  render() {
	    this.container.className = "circleAnnotation";
	    const data = this.data;
	    const width = data.rect[2] - data.rect[0];
	    const height = data.rect[3] - data.rect[1];
	    const svg = this.svgFactory.create(width, height);
	    const borderWidth = data.borderStyle.width;
	    const circle = this.svgFactory.createElement("svg:ellipse");
	    circle.setAttribute("cx", width / 2);
	    circle.setAttribute("cy", height / 2);
	    circle.setAttribute("rx", width / 2 - borderWidth / 2);
	    circle.setAttribute("ry", height / 2 - borderWidth / 2);
	    circle.setAttribute("stroke-width", borderWidth || 1);
	    circle.setAttribute("stroke", "transparent");
	    circle.setAttribute("fill", "none");
	    svg.appendChild(circle);
	    this.container.append(svg);

	    this._createPopup(circle, data);

	    return this.container;
	  }

	}

	class PolylineAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	    this.containerClassName = "polylineAnnotation";
	    this.svgElementName = "svg:polyline";
	  }

	  render() {
	    this.container.className = this.containerClassName;
	    const data = this.data;
	    const width = data.rect[2] - data.rect[0];
	    const height = data.rect[3] - data.rect[1];
	    const svg = this.svgFactory.create(width, height);
	    let points = [];

	    for (const coordinate of data.vertices) {
	      const x = coordinate.x - data.rect[0];
	      const y = data.rect[3] - coordinate.y;
	      points.push(x + "," + y);
	    }

	    points = points.join(" ");
	    const polyline = this.svgFactory.createElement(this.svgElementName);
	    polyline.setAttribute("points", points);
	    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
	    polyline.setAttribute("stroke", "transparent");
	    polyline.setAttribute("fill", "none");
	    svg.appendChild(polyline);
	    this.container.append(svg);

	    this._createPopup(polyline, data);

	    return this.container;
	  }

	}

	class PolygonAnnotationElement extends PolylineAnnotationElement {
	  constructor(parameters) {
	    super(parameters);
	    this.containerClassName = "polygonAnnotation";
	    this.svgElementName = "svg:polygon";
	  }

	}

	class CaretAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	  }

	  render() {
	    this.container.className = "caretAnnotation";

	    if (!this.data.hasPopup) {
	      this._createPopup(null, this.data);
	    }

	    return this.container;
	  }

	}

	class InkAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	    this.containerClassName = "inkAnnotation";
	    this.svgElementName = "svg:polyline";
	  }

	  render() {
	    this.container.className = this.containerClassName;
	    const data = this.data;
	    const width = data.rect[2] - data.rect[0];
	    const height = data.rect[3] - data.rect[1];
	    const svg = this.svgFactory.create(width, height);

	    for (const inkList of data.inkLists) {
	      let points = [];

	      for (const coordinate of inkList) {
	        const x = coordinate.x - data.rect[0];
	        const y = data.rect[3] - coordinate.y;
	        points.push(`${x},${y}`);
	      }

	      points = points.join(" ");
	      const polyline = this.svgFactory.createElement(this.svgElementName);
	      polyline.setAttribute("points", points);
	      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
	      polyline.setAttribute("stroke", "transparent");
	      polyline.setAttribute("fill", "none");

	      this._createPopup(polyline, data);

	      svg.appendChild(polyline);
	    }

	    this.container.append(svg);
	    return this.container;
	  }

	}

	class HighlightAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  render() {
	    if (!this.data.hasPopup) {
	      this._createPopup(null, this.data);
	    }

	    if (this.quadrilaterals) {
	      return this._renderQuadrilaterals("highlightAnnotation");
	    }

	    this.container.className = "highlightAnnotation";
	    return this.container;
	  }

	}

	class UnderlineAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  render() {
	    if (!this.data.hasPopup) {
	      this._createPopup(null, this.data);
	    }

	    if (this.quadrilaterals) {
	      return this._renderQuadrilaterals("underlineAnnotation");
	    }

	    this.container.className = "underlineAnnotation";
	    return this.container;
	  }

	}

	class SquigglyAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  render() {
	    if (!this.data.hasPopup) {
	      this._createPopup(null, this.data);
	    }

	    if (this.quadrilaterals) {
	      return this._renderQuadrilaterals("squigglyAnnotation");
	    }

	    this.container.className = "squigglyAnnotation";
	    return this.container;
	  }

	}

	class StrikeOutAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  render() {
	    if (!this.data.hasPopup) {
	      this._createPopup(null, this.data);
	    }

	    if (this.quadrilaterals) {
	      return this._renderQuadrilaterals("strikeoutAnnotation");
	    }

	    this.container.className = "strikeoutAnnotation";
	    return this.container;
	  }

	}

	class StampAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
	    super(parameters, {
	      isRenderable,
	      ignoreBorder: true
	    });
	  }

	  render() {
	    this.container.className = "stampAnnotation";

	    if (!this.data.hasPopup) {
	      this._createPopup(null, this.data);
	    }

	    return this.container;
	  }

	}

	class FileAttachmentAnnotationElement extends AnnotationElement {
	  constructor(parameters) {
	    super(parameters, {
	      isRenderable: true
	    });
	    const {
	      filename,
	      content
	    } = this.data.file;
	    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
	    this.content = content;
	    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
	      source: this,
	      id: (0, _util.stringToPDFString)(filename),
	      filename,
	      content
	    });
	  }

	  render() {
	    this.container.className = "fileAttachmentAnnotation";
	    const trigger = document.createElement("div");
	    trigger.style.height = this.container.style.height;
	    trigger.style.width = this.container.style.width;
	    trigger.addEventListener("dblclick", this._download.bind(this));

	    if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
	      this._createPopup(trigger, this.data);
	    }

	    this.container.appendChild(trigger);
	    return this.container;
	  }

	  _download() {
	    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
	  }

	}

	class AnnotationLayer {
	  static render(parameters) {
	    const sortedAnnotations = [],
	          popupAnnotations = [];

	    for (const data of parameters.annotations) {
	      if (!data) {
	        continue;
	      }

	      if (data.annotationType === _util.AnnotationType.POPUP) {
	        popupAnnotations.push(data);
	        continue;
	      }

	      sortedAnnotations.push(data);
	    }

	    if (popupAnnotations.length) {
	      sortedAnnotations.push(...popupAnnotations);
	    }

	    for (const data of sortedAnnotations) {
	      const element = AnnotationElementFactory.create({
	        data,
	        layer: parameters.div,
	        page: parameters.page,
	        viewport: parameters.viewport,
	        linkService: parameters.linkService,
	        downloadManager: parameters.downloadManager,
	        imageResourcesPath: parameters.imageResourcesPath || "",
	        renderInteractiveForms: parameters.renderInteractiveForms !== false,
	        svgFactory: new _display_utils.DOMSVGFactory(),
	        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
	        enableScripting: parameters.enableScripting,
	        hasJSActions: parameters.hasJSActions,
	        mouseState: parameters.mouseState || {
	          isDown: false
	        }
	      });

	      if (element.isRenderable) {
	        const rendered = element.render();

	        if (data.hidden) {
	          rendered.style.visibility = "hidden";
	        }

	        if (Array.isArray(rendered)) {
	          for (const renderedElement of rendered) {
	            parameters.div.appendChild(renderedElement);
	          }
	        } else {
	          if (element instanceof PopupAnnotationElement) {
	            parameters.div.prepend(rendered);
	          } else {
	            parameters.div.appendChild(rendered);
	          }
	        }
	      }
	    }
	  }

	  static update(parameters) {
	    const transform = `matrix(${parameters.viewport.transform.join(",")})`;

	    for (const data of parameters.annotations) {
	      const elements = parameters.div.querySelectorAll(`[data-annotation-id="${data.id}"]`);

	      if (elements) {
	        elements.forEach(element => {
	          element.style.transform = transform;
	        });
	      }
	    }

	    parameters.div.hidden = false;
	  }

	}

	exports.AnnotationLayer = AnnotationLayer;

	/***/ }),
	/* 19 */
	/***/ ((__unused_webpack_module, exports) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.ColorConverters = void 0;

	function makeColorComp(n) {
	  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
	}

	class ColorConverters {
	  static CMYK_G([c, y, m, k]) {
	    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
	  }

	  static G_CMYK([g]) {
	    return ["CMYK", 0, 0, 0, 1 - g];
	  }

	  static G_RGB([g]) {
	    return ["RGB", g, g, g];
	  }

	  static G_HTML([g]) {
	    const G = makeColorComp(g);
	    return `#${G}${G}${G}`;
	  }

	  static RGB_G([r, g, b]) {
	    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
	  }

	  static RGB_HTML([r, g, b]) {
	    const R = makeColorComp(r);
	    const G = makeColorComp(g);
	    const B = makeColorComp(b);
	    return `#${R}${G}${B}`;
	  }

	  static T_HTML() {
	    return "#00000000";
	  }

	  static CMYK_RGB([c, y, m, k]) {
	    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
	  }

	  static CMYK_HTML(components) {
	    return this.RGB_HTML(this.CMYK_RGB(components));
	  }

	  static RGB_CMYK([r, g, b]) {
	    const c = 1 - r;
	    const m = 1 - g;
	    const y = 1 - b;
	    const k = Math.min(c, m, y);
	    return ["CMYK", c, m, y, k];
	  }

	}

	exports.ColorConverters = ColorConverters;

	/***/ }),
	/* 20 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.renderTextLayer = void 0;

	var _util = __w_pdfjs_require__(2);

	const renderTextLayer = function renderTextLayerClosure() {
	  const MAX_TEXT_DIVS_TO_RENDER = 100000;
	  const DEFAULT_FONT_SIZE = 30;
	  const DEFAULT_FONT_ASCENT = 0.8;
	  const ascentCache = new Map();
	  const NonWhitespaceRegexp = /\S/;

	  function isAllWhitespace(str) {
	    return !NonWhitespaceRegexp.test(str);
	  }

	  function getAscent(fontFamily, ctx) {
	    const cachedAscent = ascentCache.get(fontFamily);

	    if (cachedAscent) {
	      return cachedAscent;
	    }

	    ctx.save();
	    ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
	    const metrics = ctx.measureText("");
	    let ascent = metrics.fontBoundingBoxAscent;
	    let descent = Math.abs(metrics.fontBoundingBoxDescent);

	    if (ascent) {
	      ctx.restore();
	      const ratio = ascent / (ascent + descent);
	      ascentCache.set(fontFamily, ratio);
	      return ratio;
	    }

	    ctx.strokeStyle = "red";
	    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
	    ctx.strokeText("g", 0, 0);
	    let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
	    descent = 0;

	    for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
	      if (pixels[i] > 0) {
	        descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
	        break;
	      }
	    }

	    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
	    ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
	    pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
	    ascent = 0;

	    for (let i = 0, ii = pixels.length; i < ii; i += 4) {
	      if (pixels[i] > 0) {
	        ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
	        break;
	      }
	    }

	    ctx.restore();

	    if (ascent) {
	      const ratio = ascent / (ascent + descent);
	      ascentCache.set(fontFamily, ratio);
	      return ratio;
	    }

	    ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
	    return DEFAULT_FONT_ASCENT;
	  }

	  function appendText(task, geom, styles, ctx) {
	    const textDiv = document.createElement("span");
	    const textDivProperties = {
	      angle: 0,
	      canvasWidth: 0,
	      isWhitespace: false,
	      originalTransform: null,
	      paddingBottom: 0,
	      paddingLeft: 0,
	      paddingRight: 0,
	      paddingTop: 0,
	      scale: 1
	    };

	    task._textDivs.push(textDiv);

	    if (isAllWhitespace(geom.str)) {
	      textDivProperties.isWhitespace = true;

	      task._textDivProperties.set(textDiv, textDivProperties);

	      return;
	    }

	    const tx = _util.Util.transform(task._viewport.transform, geom.transform);

	    let angle = Math.atan2(tx[1], tx[0]);
	    const style = styles[geom.fontName];

	    if (style.vertical) {
	      angle += Math.PI / 2;
	    }

	    const fontHeight = Math.hypot(tx[2], tx[3]);
	    const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
	    let left, top;

	    if (angle === 0) {
	      left = tx[4];
	      top = tx[5] - fontAscent;
	    } else {
	      left = tx[4] + fontAscent * Math.sin(angle);
	      top = tx[5] - fontAscent * Math.cos(angle);
	    }

	    textDiv.style.left = `${left}px`;
	    textDiv.style.top = `${top}px`;
	    textDiv.style.fontSize = `${fontHeight}px`;
	    textDiv.style.fontFamily = style.fontFamily;
	    textDiv.textContent = geom.str;
	    textDiv.dir = geom.dir;

	    if (task._fontInspectorEnabled) {
	      textDiv.dataset.fontName = geom.fontName;
	    }

	    if (angle !== 0) {
	      textDivProperties.angle = angle * (180 / Math.PI);
	    }

	    let shouldScaleText = false;

	    if (geom.str.length > 1) {
	      shouldScaleText = true;
	    } else if (geom.transform[0] !== geom.transform[3]) {
	      const absScaleX = Math.abs(geom.transform[0]),
	            absScaleY = Math.abs(geom.transform[3]);

	      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
	        shouldScaleText = true;
	      }
	    }

	    if (shouldScaleText) {
	      if (style.vertical) {
	        textDivProperties.canvasWidth = geom.height * task._viewport.scale;
	      } else {
	        textDivProperties.canvasWidth = geom.width * task._viewport.scale;
	      }
	    }

	    task._textDivProperties.set(textDiv, textDivProperties);

	    if (task._textContentStream) {
	      task._layoutText(textDiv);
	    }

	    if (task._enhanceTextSelection) {
	      let angleCos = 1,
	          angleSin = 0;

	      if (angle !== 0) {
	        angleCos = Math.cos(angle);
	        angleSin = Math.sin(angle);
	      }

	      const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
	      const divHeight = fontHeight;
	      let m, b;

	      if (angle !== 0) {
	        m = [angleCos, angleSin, -angleSin, angleCos, left, top];
	        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
	      } else {
	        b = [left, top, left + divWidth, top + divHeight];
	      }

	      task._bounds.push({
	        left: b[0],
	        top: b[1],
	        right: b[2],
	        bottom: b[3],
	        div: textDiv,
	        size: [divWidth, divHeight],
	        m
	      });
	    }
	  }

	  function render(task) {
	    if (task._canceled) {
	      return;
	    }

	    const textDivs = task._textDivs;
	    const capability = task._capability;
	    const textDivsLength = textDivs.length;

	    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
	      task._renderingDone = true;
	      capability.resolve();
	      return;
	    }

	    if (!task._textContentStream) {
	      for (let i = 0; i < textDivsLength; i++) {
	        task._layoutText(textDivs[i]);
	      }
	    }

	    task._renderingDone = true;
	    capability.resolve();
	  }

	  function findPositiveMin(ts, offset, count) {
	    let result = 0;

	    for (let i = 0; i < count; i++) {
	      const t = ts[offset++];

	      if (t > 0) {
	        result = result ? Math.min(t, result) : t;
	      }
	    }

	    return result;
	  }

	  function expand(task) {
	    const bounds = task._bounds;
	    const viewport = task._viewport;
	    const expanded = expandBounds(viewport.width, viewport.height, bounds);

	    for (let i = 0; i < expanded.length; i++) {
	      const div = bounds[i].div;

	      const divProperties = task._textDivProperties.get(div);

	      if (divProperties.angle === 0) {
	        divProperties.paddingLeft = bounds[i].left - expanded[i].left;
	        divProperties.paddingTop = bounds[i].top - expanded[i].top;
	        divProperties.paddingRight = expanded[i].right - bounds[i].right;
	        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

	        task._textDivProperties.set(div, divProperties);

	        continue;
	      }

	      const e = expanded[i],
	            b = bounds[i];
	      const m = b.m,
	            c = m[0],
	            s = m[1];
	      const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
	      const ts = new Float64Array(64);
	      points.forEach(function (p, j) {
	        const t = _util.Util.applyTransform(p, m);

	        ts[j + 0] = c && (e.left - t[0]) / c;
	        ts[j + 4] = s && (e.top - t[1]) / s;
	        ts[j + 8] = c && (e.right - t[0]) / c;
	        ts[j + 12] = s && (e.bottom - t[1]) / s;
	        ts[j + 16] = s && (e.left - t[0]) / -s;
	        ts[j + 20] = c && (e.top - t[1]) / c;
	        ts[j + 24] = s && (e.right - t[0]) / -s;
	        ts[j + 28] = c && (e.bottom - t[1]) / c;
	        ts[j + 32] = c && (e.left - t[0]) / -c;
	        ts[j + 36] = s && (e.top - t[1]) / -s;
	        ts[j + 40] = c && (e.right - t[0]) / -c;
	        ts[j + 44] = s && (e.bottom - t[1]) / -s;
	        ts[j + 48] = s && (e.left - t[0]) / s;
	        ts[j + 52] = c && (e.top - t[1]) / -c;
	        ts[j + 56] = s && (e.right - t[0]) / s;
	        ts[j + 60] = c && (e.bottom - t[1]) / -c;
	      });
	      const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
	      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
	      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
	      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
	      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

	      task._textDivProperties.set(div, divProperties);
	    }
	  }

	  function expandBounds(width, height, boxes) {
	    const bounds = boxes.map(function (box, i) {
	      return {
	        x1: box.left,
	        y1: box.top,
	        x2: box.right,
	        y2: box.bottom,
	        index: i,
	        x1New: undefined,
	        x2New: undefined
	      };
	    });
	    expandBoundsLTR(width, bounds);
	    const expanded = new Array(boxes.length);
	    bounds.forEach(function (b) {
	      const i = b.index;
	      expanded[i] = {
	        left: b.x1New,
	        top: 0,
	        right: b.x2New,
	        bottom: 0
	      };
	    });
	    boxes.map(function (box, i) {
	      const e = expanded[i],
	            b = bounds[i];
	      b.x1 = box.top;
	      b.y1 = width - e.right;
	      b.x2 = box.bottom;
	      b.y2 = width - e.left;
	      b.index = i;
	      b.x1New = undefined;
	      b.x2New = undefined;
	    });
	    expandBoundsLTR(height, bounds);
	    bounds.forEach(function (b) {
	      const i = b.index;
	      expanded[i].top = b.x1New;
	      expanded[i].bottom = b.x2New;
	    });
	    return expanded;
	  }

	  function expandBoundsLTR(width, bounds) {
	    bounds.sort(function (a, b) {
	      return a.x1 - b.x1 || a.index - b.index;
	    });
	    const fakeBoundary = {
	      x1: -Infinity,
	      y1: -Infinity,
	      x2: 0,
	      y2: Infinity,
	      index: -1,
	      x1New: 0,
	      x2New: 0
	    };
	    const horizon = [{
	      start: -Infinity,
	      end: Infinity,
	      boundary: fakeBoundary
	    }];
	    bounds.forEach(function (boundary) {
	      let i = 0;

	      while (i < horizon.length && horizon[i].end <= boundary.y1) {
	        i++;
	      }

	      let j = horizon.length - 1;

	      while (j >= 0 && horizon[j].start >= boundary.y2) {
	        j--;
	      }

	      let horizonPart, affectedBoundary;
	      let q,
	          k,
	          maxXNew = -Infinity;

	      for (q = i; q <= j; q++) {
	        horizonPart = horizon[q];
	        affectedBoundary = horizonPart.boundary;
	        let xNew;

	        if (affectedBoundary.x2 > boundary.x1) {
	          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
	        } else if (affectedBoundary.x2New === undefined) {
	          xNew = (affectedBoundary.x2 + boundary.x1) / 2;
	        } else {
	          xNew = affectedBoundary.x2New;
	        }

	        if (xNew > maxXNew) {
	          maxXNew = xNew;
	        }
	      }

	      boundary.x1New = maxXNew;

	      for (q = i; q <= j; q++) {
	        horizonPart = horizon[q];
	        affectedBoundary = horizonPart.boundary;

	        if (affectedBoundary.x2New === undefined) {
	          if (affectedBoundary.x2 > boundary.x1) {
	            if (affectedBoundary.index > boundary.index) {
	              affectedBoundary.x2New = affectedBoundary.x2;
	            }
	          } else {
	            affectedBoundary.x2New = maxXNew;
	          }
	        } else if (affectedBoundary.x2New > maxXNew) {
	          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
	        }
	      }

	      const changedHorizon = [];
	      let lastBoundary = null;

	      for (q = i; q <= j; q++) {
	        horizonPart = horizon[q];
	        affectedBoundary = horizonPart.boundary;
	        const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

	        if (lastBoundary === useBoundary) {
	          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
	        } else {
	          changedHorizon.push({
	            start: horizonPart.start,
	            end: horizonPart.end,
	            boundary: useBoundary
	          });
	          lastBoundary = useBoundary;
	        }
	      }

	      if (horizon[i].start < boundary.y1) {
	        changedHorizon[0].start = boundary.y1;
	        changedHorizon.unshift({
	          start: horizon[i].start,
	          end: boundary.y1,
	          boundary: horizon[i].boundary
	        });
	      }

	      if (boundary.y2 < horizon[j].end) {
	        changedHorizon[changedHorizon.length - 1].end = boundary.y2;
	        changedHorizon.push({
	          start: boundary.y2,
	          end: horizon[j].end,
	          boundary: horizon[j].boundary
	        });
	      }

	      for (q = i; q <= j; q++) {
	        horizonPart = horizon[q];
	        affectedBoundary = horizonPart.boundary;

	        if (affectedBoundary.x2New !== undefined) {
	          continue;
	        }

	        let used = false;

	        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
	          used = horizon[k].boundary === affectedBoundary;
	        }

	        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
	          used = horizon[k].boundary === affectedBoundary;
	        }

	        for (k = 0; !used && k < changedHorizon.length; k++) {
	          used = changedHorizon[k].boundary === affectedBoundary;
	        }

	        if (!used) {
	          affectedBoundary.x2New = maxXNew;
	        }
	      }

	      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
	    });
	    horizon.forEach(function (horizonPart) {
	      const affectedBoundary = horizonPart.boundary;

	      if (affectedBoundary.x2New === undefined) {
	        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
	      }
	    });
	  }

	  function TextLayerRenderTask({
	    textContent,
	    textContentStream,
	    container,
	    viewport,
	    textDivs,
	    textContentItemsStr,
	    enhanceTextSelection
	  }) {
	    this._textContent = textContent;
	    this._textContentStream = textContentStream;
	    this._container = container;
	    this._document = container.ownerDocument;
	    this._viewport = viewport;
	    this._textDivs = textDivs || [];
	    this._textContentItemsStr = textContentItemsStr || [];
	    this._enhanceTextSelection = !!enhanceTextSelection;
	    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
	    this._reader = null;
	    this._layoutTextLastFontSize = null;
	    this._layoutTextLastFontFamily = null;
	    this._layoutTextCtx = null;
	    this._textDivProperties = new WeakMap();
	    this._renderingDone = false;
	    this._canceled = false;
	    this._capability = (0, _util.createPromiseCapability)();
	    this._renderTimer = null;
	    this._bounds = [];

	    this._capability.promise.finally(() => {
	      if (this._layoutTextCtx) {
	        this._layoutTextCtx.canvas.width = 0;
	        this._layoutTextCtx.canvas.height = 0;
	        this._layoutTextCtx = null;
	      }
	    }).catch(() => {});
	  }

	  TextLayerRenderTask.prototype = {
	    get promise() {
	      return this._capability.promise;
	    },

	    cancel: function TextLayer_cancel() {
	      this._canceled = true;

	      if (this._reader) {
	        this._reader.cancel(new _util.AbortException("TextLayer task cancelled."));

	        this._reader = null;
	      }

	      if (this._renderTimer !== null) {
	        clearTimeout(this._renderTimer);
	        this._renderTimer = null;
	      }

	      this._capability.reject(new Error("TextLayer task cancelled."));
	    },

	    _processItems(items, styleCache) {
	      for (let i = 0, len = items.length; i < len; i++) {
	        this._textContentItemsStr.push(items[i].str);

	        appendText(this, items[i], styleCache, this._layoutTextCtx);
	      }
	    },

	    _layoutText(textDiv) {
	      const textDivProperties = this._textDivProperties.get(textDiv);

	      if (textDivProperties.isWhitespace) {
	        return;
	      }

	      let transform = "";

	      if (textDivProperties.canvasWidth !== 0) {
	        const {
	          fontSize,
	          fontFamily
	        } = textDiv.style;

	        if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
	          this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
	          this._layoutTextLastFontSize = fontSize;
	          this._layoutTextLastFontFamily = fontFamily;
	        }

	        const {
	          width
	        } = this._layoutTextCtx.measureText(textDiv.textContent);

	        if (width > 0) {
	          textDivProperties.scale = textDivProperties.canvasWidth / width;
	          transform = `scaleX(${textDivProperties.scale})`;
	        }
	      }

	      if (textDivProperties.angle !== 0) {
	        transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
	      }

	      if (transform.length > 0) {
	        if (this._enhanceTextSelection) {
	          textDivProperties.originalTransform = transform;
	        }

	        textDiv.style.transform = transform;
	      }

	      this._textDivProperties.set(textDiv, textDivProperties);

	      this._container.appendChild(textDiv);
	    },

	    _render: function TextLayer_render(timeout) {
	      const capability = (0, _util.createPromiseCapability)();
	      let styleCache = Object.create(null);

	      const canvas = this._document.createElement("canvas");

	      canvas.height = canvas.width = DEFAULT_FONT_SIZE;
	      canvas.mozOpaque = true;
	      this._layoutTextCtx = canvas.getContext("2d", {
	        alpha: false
	      });

	      if (this._textContent) {
	        const textItems = this._textContent.items;
	        const textStyles = this._textContent.styles;

	        this._processItems(textItems, textStyles);

	        capability.resolve();
	      } else if (this._textContentStream) {
	        const pump = () => {
	          this._reader.read().then(({
	            value,
	            done
	          }) => {
	            if (done) {
	              capability.resolve();
	              return;
	            }

	            Object.assign(styleCache, value.styles);

	            this._processItems(value.items, styleCache);

	            pump();
	          }, capability.reject);
	        };

	        this._reader = this._textContentStream.getReader();
	        pump();
	      } else {
	        throw new Error('Neither "textContent" nor "textContentStream"' + " parameters specified.");
	      }

	      capability.promise.then(() => {
	        styleCache = null;

	        if (!timeout) {
	          render(this);
	        } else {
	          this._renderTimer = setTimeout(() => {
	            render(this);
	            this._renderTimer = null;
	          }, timeout);
	        }
	      }, this._capability.reject);
	    },
	    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
	      if (!this._enhanceTextSelection || !this._renderingDone) {
	        return;
	      }

	      if (this._bounds !== null) {
	        expand(this);
	        this._bounds = null;
	      }

	      const transformBuf = [],
	            paddingBuf = [];

	      for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
	        const div = this._textDivs[i];

	        const divProps = this._textDivProperties.get(div);

	        if (divProps.isWhitespace) {
	          continue;
	        }

	        if (expandDivs) {
	          transformBuf.length = 0;
	          paddingBuf.length = 0;

	          if (divProps.originalTransform) {
	            transformBuf.push(divProps.originalTransform);
	          }

	          if (divProps.paddingTop > 0) {
	            paddingBuf.push(`${divProps.paddingTop}px`);
	            transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
	          } else {
	            paddingBuf.push(0);
	          }

	          if (divProps.paddingRight > 0) {
	            paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
	          } else {
	            paddingBuf.push(0);
	          }

	          if (divProps.paddingBottom > 0) {
	            paddingBuf.push(`${divProps.paddingBottom}px`);
	          } else {
	            paddingBuf.push(0);
	          }

	          if (divProps.paddingLeft > 0) {
	            paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
	            transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
	          } else {
	            paddingBuf.push(0);
	          }

	          div.style.padding = paddingBuf.join(" ");

	          if (transformBuf.length) {
	            div.style.transform = transformBuf.join(" ");
	          }
	        } else {
	          div.style.padding = null;
	          div.style.transform = divProps.originalTransform;
	        }
	      }
	    }
	  };

	  function renderTextLayer(renderParameters) {
	    const task = new TextLayerRenderTask({
	      textContent: renderParameters.textContent,
	      textContentStream: renderParameters.textContentStream,
	      container: renderParameters.container,
	      viewport: renderParameters.viewport,
	      textDivs: renderParameters.textDivs,
	      textContentItemsStr: renderParameters.textContentItemsStr,
	      enhanceTextSelection: renderParameters.enhanceTextSelection
	    });

	    task._render(renderParameters.timeout);

	    return task;
	  }

	  return renderTextLayer;
	}();

	exports.renderTextLayer = renderTextLayer;

	/***/ }),
	/* 21 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.SVGGraphics = void 0;

	var _util = __w_pdfjs_require__(2);

	var _display_utils = __w_pdfjs_require__(1);

	var _is_node = __w_pdfjs_require__(4);

	let SVGGraphics = function () {
	  throw new Error("Not implemented: SVGGraphics");
	};

	exports.SVGGraphics = SVGGraphics;
	{
	  const SVG_DEFAULTS = {
	    fontStyle: "normal",
	    fontWeight: "normal",
	    fillColor: "#000000"
	  };
	  const XML_NS = "http://www.w3.org/XML/1998/namespace";
	  const XLINK_NS = "http://www.w3.org/1999/xlink";
	  const LINE_CAP_STYLES = ["butt", "round", "square"];
	  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];

	  const convertImgDataToPng = function () {
	    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
	    const CHUNK_WRAPPER_SIZE = 12;
	    const crcTable = new Int32Array(256);

	    for (let i = 0; i < 256; i++) {
	      let c = i;

	      for (let h = 0; h < 8; h++) {
	        if (c & 1) {
	          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
	        } else {
	          c = c >> 1 & 0x7fffffff;
	        }
	      }

	      crcTable[i] = c;
	    }

	    function crc32(data, start, end) {
	      let crc = -1;

	      for (let i = start; i < end; i++) {
	        const a = (crc ^ data[i]) & 0xff;
	        const b = crcTable[a];
	        crc = crc >>> 8 ^ b;
	      }

	      return crc ^ -1;
	    }

	    function writePngChunk(type, body, data, offset) {
	      let p = offset;
	      const len = body.length;
	      data[p] = len >> 24 & 0xff;
	      data[p + 1] = len >> 16 & 0xff;
	      data[p + 2] = len >> 8 & 0xff;
	      data[p + 3] = len & 0xff;
	      p += 4;
	      data[p] = type.charCodeAt(0) & 0xff;
	      data[p + 1] = type.charCodeAt(1) & 0xff;
	      data[p + 2] = type.charCodeAt(2) & 0xff;
	      data[p + 3] = type.charCodeAt(3) & 0xff;
	      p += 4;
	      data.set(body, p);
	      p += body.length;
	      const crc = crc32(data, offset + 4, p);
	      data[p] = crc >> 24 & 0xff;
	      data[p + 1] = crc >> 16 & 0xff;
	      data[p + 2] = crc >> 8 & 0xff;
	      data[p + 3] = crc & 0xff;
	    }

	    function adler32(data, start, end) {
	      let a = 1;
	      let b = 0;

	      for (let i = start; i < end; ++i) {
	        a = (a + (data[i] & 0xff)) % 65521;
	        b = (b + a) % 65521;
	      }

	      return b << 16 | a;
	    }

	    function deflateSync(literals) {
	      if (!_is_node.isNodeJS) {
	        return deflateSyncUncompressed(literals);
	      }

	      try {
	        let input;

	        if (parseInt(process.versions.node) >= 8) {
	          input = literals;
	        } else {
	          input = Buffer.from(literals);
	        }

	        const output = require$$2__default['default'].deflateSync(input, {
	          level: 9
	        });

	        return output instanceof Uint8Array ? output : new Uint8Array(output);
	      } catch (e) {
	        (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
	      }

	      return deflateSyncUncompressed(literals);
	    }

	    function deflateSyncUncompressed(literals) {
	      let len = literals.length;
	      const maxBlockLength = 0xffff;
	      const deflateBlocks = Math.ceil(len / maxBlockLength);
	      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
	      let pi = 0;
	      idat[pi++] = 0x78;
	      idat[pi++] = 0x9c;
	      let pos = 0;

	      while (len > maxBlockLength) {
	        idat[pi++] = 0x00;
	        idat[pi++] = 0xff;
	        idat[pi++] = 0xff;
	        idat[pi++] = 0x00;
	        idat[pi++] = 0x00;
	        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
	        pi += maxBlockLength;
	        pos += maxBlockLength;
	        len -= maxBlockLength;
	      }

	      idat[pi++] = 0x01;
	      idat[pi++] = len & 0xff;
	      idat[pi++] = len >> 8 & 0xff;
	      idat[pi++] = ~len & 0xffff & 0xff;
	      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
	      idat.set(literals.subarray(pos), pi);
	      pi += literals.length - pos;
	      const adler = adler32(literals, 0, literals.length);
	      idat[pi++] = adler >> 24 & 0xff;
	      idat[pi++] = adler >> 16 & 0xff;
	      idat[pi++] = adler >> 8 & 0xff;
	      idat[pi++] = adler & 0xff;
	      return idat;
	    }

	    function encode(imgData, kind, forceDataSchema, isMask) {
	      const width = imgData.width;
	      const height = imgData.height;
	      let bitDepth, colorType, lineSize;
	      const bytes = imgData.data;

	      switch (kind) {
	        case _util.ImageKind.GRAYSCALE_1BPP:
	          colorType = 0;
	          bitDepth = 1;
	          lineSize = width + 7 >> 3;
	          break;

	        case _util.ImageKind.RGB_24BPP:
	          colorType = 2;
	          bitDepth = 8;
	          lineSize = width * 3;
	          break;

	        case _util.ImageKind.RGBA_32BPP:
	          colorType = 6;
	          bitDepth = 8;
	          lineSize = width * 4;
	          break;

	        default:
	          throw new Error("invalid format");
	      }

	      const literals = new Uint8Array((1 + lineSize) * height);
	      let offsetLiterals = 0,
	          offsetBytes = 0;

	      for (let y = 0; y < height; ++y) {
	        literals[offsetLiterals++] = 0;
	        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
	        offsetBytes += lineSize;
	        offsetLiterals += lineSize;
	      }

	      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
	        offsetLiterals = 0;

	        for (let y = 0; y < height; y++) {
	          offsetLiterals++;

	          for (let i = 0; i < lineSize; i++) {
	            literals[offsetLiterals++] ^= 0xff;
	          }
	        }
	      }

	      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
	      const idat = deflateSync(literals);
	      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
	      const data = new Uint8Array(pngLength);
	      let offset = 0;
	      data.set(PNG_HEADER, offset);
	      offset += PNG_HEADER.length;
	      writePngChunk("IHDR", ihdr, data, offset);
	      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
	      writePngChunk("IDATA", idat, data, offset);
	      offset += CHUNK_WRAPPER_SIZE + idat.length;
	      writePngChunk("IEND", new Uint8Array(0), data, offset);
	      return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
	    }

	    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
	      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
	      return encode(imgData, kind, forceDataSchema, isMask);
	    };
	  }();

	  class SVGExtraState {
	    constructor() {
	      this.fontSizeScale = 1;
	      this.fontWeight = SVG_DEFAULTS.fontWeight;
	      this.fontSize = 0;
	      this.textMatrix = _util.IDENTITY_MATRIX;
	      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
	      this.leading = 0;
	      this.textRenderingMode = _util.TextRenderingMode.FILL;
	      this.textMatrixScale = 1;
	      this.x = 0;
	      this.y = 0;
	      this.lineX = 0;
	      this.lineY = 0;
	      this.charSpacing = 0;
	      this.wordSpacing = 0;
	      this.textHScale = 1;
	      this.textRise = 0;
	      this.fillColor = SVG_DEFAULTS.fillColor;
	      this.strokeColor = "#000000";
	      this.fillAlpha = 1;
	      this.strokeAlpha = 1;
	      this.lineWidth = 1;
	      this.lineJoin = "";
	      this.lineCap = "";
	      this.miterLimit = 0;
	      this.dashArray = [];
	      this.dashPhase = 0;
	      this.dependencies = [];
	      this.activeClipUrl = null;
	      this.clipGroup = null;
	      this.maskId = "";
	    }

	    clone() {
	      return Object.create(this);
	    }

	    setCurrentPoint(x, y) {
	      this.x = x;
	      this.y = y;
	    }

	  }

	  function opListToTree(opList) {
	    let opTree = [];
	    const tmp = [];

	    for (const opListElement of opList) {
	      if (opListElement.fn === "save") {
	        opTree.push({
	          fnId: 92,
	          fn: "group",
	          items: []
	        });
	        tmp.push(opTree);
	        opTree = opTree[opTree.length - 1].items;
	        continue;
	      }

	      if (opListElement.fn === "restore") {
	        opTree = tmp.pop();
	      } else {
	        opTree.push(opListElement);
	      }
	    }

	    return opTree;
	  }

	  function pf(value) {
	    if (Number.isInteger(value)) {
	      return value.toString();
	    }

	    const s = value.toFixed(10);
	    let i = s.length - 1;

	    if (s[i] !== "0") {
	      return s;
	    }

	    do {
	      i--;
	    } while (s[i] === "0");

	    return s.substring(0, s[i] === "." ? i : i + 1);
	  }

	  function pm(m) {
	    if (m[4] === 0 && m[5] === 0) {
	      if (m[1] === 0 && m[2] === 0) {
	        if (m[0] === 1 && m[3] === 1) {
	          return "";
	        }

	        return `scale(${pf(m[0])} ${pf(m[3])})`;
	      }

	      if (m[0] === m[3] && m[1] === -m[2]) {
	        const a = Math.acos(m[0]) * 180 / Math.PI;
	        return `rotate(${pf(a)})`;
	      }
	    } else {
	      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
	        return `translate(${pf(m[4])} ${pf(m[5])})`;
	      }
	    }

	    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
	  }

	  let clipCount = 0;
	  let maskCount = 0;
	  let shadingCount = 0;
	  exports.SVGGraphics = SVGGraphics = class SVGGraphics {
	    constructor(commonObjs, objs, forceDataSchema = false) {
	      this.svgFactory = new _display_utils.DOMSVGFactory();
	      this.current = new SVGExtraState();
	      this.transformMatrix = _util.IDENTITY_MATRIX;
	      this.transformStack = [];
	      this.extraStack = [];
	      this.commonObjs = commonObjs;
	      this.objs = objs;
	      this.pendingClip = null;
	      this.pendingEOFill = false;
	      this.embedFonts = false;
	      this.embeddedFonts = Object.create(null);
	      this.cssStyle = null;
	      this.forceDataSchema = !!forceDataSchema;
	      this._operatorIdMapping = [];

	      for (const op in _util.OPS) {
	        this._operatorIdMapping[_util.OPS[op]] = op;
	      }
	    }

	    save() {
	      this.transformStack.push(this.transformMatrix);
	      const old = this.current;
	      this.extraStack.push(old);
	      this.current = old.clone();
	    }

	    restore() {
	      this.transformMatrix = this.transformStack.pop();
	      this.current = this.extraStack.pop();
	      this.pendingClip = null;
	      this.tgrp = null;
	    }

	    group(items) {
	      this.save();
	      this.executeOpTree(items);
	      this.restore();
	    }

	    loadDependencies(operatorList) {
	      const fnArray = operatorList.fnArray;
	      const argsArray = operatorList.argsArray;

	      for (let i = 0, ii = fnArray.length; i < ii; i++) {
	        if (fnArray[i] !== _util.OPS.dependency) {
	          continue;
	        }

	        for (const obj of argsArray[i]) {
	          const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
	          const promise = new Promise(resolve => {
	            objsPool.get(obj, resolve);
	          });
	          this.current.dependencies.push(promise);
	        }
	      }

	      return Promise.all(this.current.dependencies);
	    }

	    transform(a, b, c, d, e, f) {
	      const transformMatrix = [a, b, c, d, e, f];
	      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
	      this.tgrp = null;
	    }

	    getSVG(operatorList, viewport) {
	      this.viewport = viewport;

	      const svgElement = this._initialize(viewport);

	      return this.loadDependencies(operatorList).then(() => {
	        this.transformMatrix = _util.IDENTITY_MATRIX;
	        this.executeOpTree(this.convertOpList(operatorList));
	        return svgElement;
	      });
	    }

	    convertOpList(operatorList) {
	      const operatorIdMapping = this._operatorIdMapping;
	      const argsArray = operatorList.argsArray;
	      const fnArray = operatorList.fnArray;
	      const opList = [];

	      for (let i = 0, ii = fnArray.length; i < ii; i++) {
	        const fnId = fnArray[i];
	        opList.push({
	          fnId,
	          fn: operatorIdMapping[fnId],
	          args: argsArray[i]
	        });
	      }

	      return opListToTree(opList);
	    }

	    executeOpTree(opTree) {
	      for (const opTreeElement of opTree) {
	        const fn = opTreeElement.fn;
	        const fnId = opTreeElement.fnId;
	        const args = opTreeElement.args;

	        switch (fnId | 0) {
	          case _util.OPS.beginText:
	            this.beginText();
	            break;

	          case _util.OPS.dependency:
	            break;

	          case _util.OPS.setLeading:
	            this.setLeading(args);
	            break;

	          case _util.OPS.setLeadingMoveText:
	            this.setLeadingMoveText(args[0], args[1]);
	            break;

	          case _util.OPS.setFont:
	            this.setFont(args);
	            break;

	          case _util.OPS.showText:
	            this.showText(args[0]);
	            break;

	          case _util.OPS.showSpacedText:
	            this.showText(args[0]);
	            break;

	          case _util.OPS.endText:
	            this.endText();
	            break;

	          case _util.OPS.moveText:
	            this.moveText(args[0], args[1]);
	            break;

	          case _util.OPS.setCharSpacing:
	            this.setCharSpacing(args[0]);
	            break;

	          case _util.OPS.setWordSpacing:
	            this.setWordSpacing(args[0]);
	            break;

	          case _util.OPS.setHScale:
	            this.setHScale(args[0]);
	            break;

	          case _util.OPS.setTextMatrix:
	            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
	            break;

	          case _util.OPS.setTextRise:
	            this.setTextRise(args[0]);
	            break;

	          case _util.OPS.setTextRenderingMode:
	            this.setTextRenderingMode(args[0]);
	            break;

	          case _util.OPS.setLineWidth:
	            this.setLineWidth(args[0]);
	            break;

	          case _util.OPS.setLineJoin:
	            this.setLineJoin(args[0]);
	            break;

	          case _util.OPS.setLineCap:
	            this.setLineCap(args[0]);
	            break;

	          case _util.OPS.setMiterLimit:
	            this.setMiterLimit(args[0]);
	            break;

	          case _util.OPS.setFillRGBColor:
	            this.setFillRGBColor(args[0], args[1], args[2]);
	            break;

	          case _util.OPS.setStrokeRGBColor:
	            this.setStrokeRGBColor(args[0], args[1], args[2]);
	            break;

	          case _util.OPS.setStrokeColorN:
	            this.setStrokeColorN(args);
	            break;

	          case _util.OPS.setFillColorN:
	            this.setFillColorN(args);
	            break;

	          case _util.OPS.shadingFill:
	            this.shadingFill(args[0]);
	            break;

	          case _util.OPS.setDash:
	            this.setDash(args[0], args[1]);
	            break;

	          case _util.OPS.setRenderingIntent:
	            this.setRenderingIntent(args[0]);
	            break;

	          case _util.OPS.setFlatness:
	            this.setFlatness(args[0]);
	            break;

	          case _util.OPS.setGState:
	            this.setGState(args[0]);
	            break;

	          case _util.OPS.fill:
	            this.fill();
	            break;

	          case _util.OPS.eoFill:
	            this.eoFill();
	            break;

	          case _util.OPS.stroke:
	            this.stroke();
	            break;

	          case _util.OPS.fillStroke:
	            this.fillStroke();
	            break;

	          case _util.OPS.eoFillStroke:
	            this.eoFillStroke();
	            break;

	          case _util.OPS.clip:
	            this.clip("nonzero");
	            break;

	          case _util.OPS.eoClip:
	            this.clip("evenodd");
	            break;

	          case _util.OPS.paintSolidColorImageMask:
	            this.paintSolidColorImageMask();
	            break;

	          case _util.OPS.paintImageXObject:
	            this.paintImageXObject(args[0]);
	            break;

	          case _util.OPS.paintInlineImageXObject:
	            this.paintInlineImageXObject(args[0]);
	            break;

	          case _util.OPS.paintImageMaskXObject:
	            this.paintImageMaskXObject(args[0]);
	            break;

	          case _util.OPS.paintFormXObjectBegin:
	            this.paintFormXObjectBegin(args[0], args[1]);
	            break;

	          case _util.OPS.paintFormXObjectEnd:
	            this.paintFormXObjectEnd();
	            break;

	          case _util.OPS.closePath:
	            this.closePath();
	            break;

	          case _util.OPS.closeStroke:
	            this.closeStroke();
	            break;

	          case _util.OPS.closeFillStroke:
	            this.closeFillStroke();
	            break;

	          case _util.OPS.closeEOFillStroke:
	            this.closeEOFillStroke();
	            break;

	          case _util.OPS.nextLine:
	            this.nextLine();
	            break;

	          case _util.OPS.transform:
	            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
	            break;

	          case _util.OPS.constructPath:
	            this.constructPath(args[0], args[1]);
	            break;

	          case _util.OPS.endPath:
	            this.endPath();
	            break;

	          case 92:
	            this.group(opTreeElement.items);
	            break;

	          default:
	            (0, _util.warn)(`Unimplemented operator ${fn}`);
	            break;
	        }
	      }
	    }

	    setWordSpacing(wordSpacing) {
	      this.current.wordSpacing = wordSpacing;
	    }

	    setCharSpacing(charSpacing) {
	      this.current.charSpacing = charSpacing;
	    }

	    nextLine() {
	      this.moveText(0, this.current.leading);
	    }

	    setTextMatrix(a, b, c, d, e, f) {
	      const current = this.current;
	      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
	      current.textMatrixScale = Math.hypot(a, b);
	      current.x = current.lineX = 0;
	      current.y = current.lineY = 0;
	      current.xcoords = [];
	      current.ycoords = [];
	      current.tspan = this.svgFactory.createElement("svg:tspan");
	      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
	      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
	      current.tspan.setAttributeNS(null, "y", pf(-current.y));
	      current.txtElement = this.svgFactory.createElement("svg:text");
	      current.txtElement.appendChild(current.tspan);
	    }

	    beginText() {
	      const current = this.current;
	      current.x = current.lineX = 0;
	      current.y = current.lineY = 0;
	      current.textMatrix = _util.IDENTITY_MATRIX;
	      current.lineMatrix = _util.IDENTITY_MATRIX;
	      current.textMatrixScale = 1;
	      current.tspan = this.svgFactory.createElement("svg:tspan");
	      current.txtElement = this.svgFactory.createElement("svg:text");
	      current.txtgrp = this.svgFactory.createElement("svg:g");
	      current.xcoords = [];
	      current.ycoords = [];
	    }

	    moveText(x, y) {
	      const current = this.current;
	      current.x = current.lineX += x;
	      current.y = current.lineY += y;
	      current.xcoords = [];
	      current.ycoords = [];
	      current.tspan = this.svgFactory.createElement("svg:tspan");
	      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
	      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
	      current.tspan.setAttributeNS(null, "y", pf(-current.y));
	    }

	    showText(glyphs) {
	      const current = this.current;
	      const font = current.font;
	      const fontSize = current.fontSize;

	      if (fontSize === 0) {
	        return;
	      }

	      const fontSizeScale = current.fontSizeScale;
	      const charSpacing = current.charSpacing;
	      const wordSpacing = current.wordSpacing;
	      const fontDirection = current.fontDirection;
	      const textHScale = current.textHScale * fontDirection;
	      const vertical = font.vertical;
	      const spacingDir = vertical ? 1 : -1;
	      const defaultVMetrics = font.defaultVMetrics;
	      const widthAdvanceScale = fontSize * current.fontMatrix[0];
	      let x = 0;

	      for (const glyph of glyphs) {
	        if (glyph === null) {
	          x += fontDirection * wordSpacing;
	          continue;
	        } else if ((0, _util.isNum)(glyph)) {
	          x += spacingDir * glyph * fontSize / 1000;
	          continue;
	        }

	        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
	        const character = glyph.fontChar;
	        let scaledX, scaledY;
	        let width = glyph.width;

	        if (vertical) {
	          let vx;
	          const vmetric = glyph.vmetric || defaultVMetrics;
	          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
	          vx = -vx * widthAdvanceScale;
	          const vy = vmetric[2] * widthAdvanceScale;
	          width = vmetric ? -vmetric[0] : width;
	          scaledX = vx / fontSizeScale;
	          scaledY = (x + vy) / fontSizeScale;
	        } else {
	          scaledX = x / fontSizeScale;
	          scaledY = 0;
	        }

	        if (glyph.isInFont || font.missingFile) {
	          current.xcoords.push(current.x + scaledX);

	          if (vertical) {
	            current.ycoords.push(-current.y + scaledY);
	          }

	          current.tspan.textContent += character;
	        }

	        let charWidth;

	        if (vertical) {
	          charWidth = width * widthAdvanceScale - spacing * fontDirection;
	        } else {
	          charWidth = width * widthAdvanceScale + spacing * fontDirection;
	        }

	        x += charWidth;
	      }

	      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

	      if (vertical) {
	        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
	      } else {
	        current.tspan.setAttributeNS(null, "y", pf(-current.y));
	      }

	      if (vertical) {
	        current.y -= x;
	      } else {
	        current.x += x * textHScale;
	      }

	      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
	      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);

	      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
	        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
	      }

	      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
	        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
	      }

	      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

	      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
	          current.tspan.setAttributeNS(null, "fill", current.fillColor);
	        }

	        if (current.fillAlpha < 1) {
	          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
	        }
	      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
	        current.tspan.setAttributeNS(null, "fill", "transparent");
	      } else {
	        current.tspan.setAttributeNS(null, "fill", "none");
	      }

	      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	        const lineWidthScale = 1 / (current.textMatrixScale || 1);

	        this._setStrokeAttributes(current.tspan, lineWidthScale);
	      }

	      let textMatrix = current.textMatrix;

	      if (current.textRise !== 0) {
	        textMatrix = textMatrix.slice();
	        textMatrix[5] += current.textRise;
	      }

	      current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
	      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
	      current.txtElement.appendChild(current.tspan);
	      current.txtgrp.appendChild(current.txtElement);

	      this._ensureTransformGroup().appendChild(current.txtElement);
	    }

	    setLeadingMoveText(x, y) {
	      this.setLeading(-y);
	      this.moveText(x, y);
	    }

	    addFontStyle(fontObj) {
	      if (!fontObj.data) {
	        throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
	      }

	      if (!this.cssStyle) {
	        this.cssStyle = this.svgFactory.createElement("svg:style");
	        this.cssStyle.setAttributeNS(null, "type", "text/css");
	        this.defs.appendChild(this.cssStyle);
	      }

	      const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
	      this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
	    }

	    setFont(details) {
	      const current = this.current;
	      const fontObj = this.commonObjs.get(details[0]);
	      let size = details[1];
	      current.font = fontObj;

	      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
	        this.addFontStyle(fontObj);
	        this.embeddedFonts[fontObj.loadedName] = fontObj;
	      }

	      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
	      let bold = "normal";

	      if (fontObj.black) {
	        bold = "900";
	      } else if (fontObj.bold) {
	        bold = "bold";
	      }

	      const italic = fontObj.italic ? "italic" : "normal";

	      if (size < 0) {
	        size = -size;
	        current.fontDirection = -1;
	      } else {
	        current.fontDirection = 1;
	      }

	      current.fontSize = size;
	      current.fontFamily = fontObj.loadedName;
	      current.fontWeight = bold;
	      current.fontStyle = italic;
	      current.tspan = this.svgFactory.createElement("svg:tspan");
	      current.tspan.setAttributeNS(null, "y", pf(-current.y));
	      current.xcoords = [];
	      current.ycoords = [];
	    }

	    endText() {
	      const current = this.current;

	      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
	        current.element = current.txtElement;
	        this.clip("nonzero");
	        this.endPath();
	      }
	    }

	    setLineWidth(width) {
	      if (width > 0) {
	        this.current.lineWidth = width;
	      }
	    }

	    setLineCap(style) {
	      this.current.lineCap = LINE_CAP_STYLES[style];
	    }

	    setLineJoin(style) {
	      this.current.lineJoin = LINE_JOIN_STYLES[style];
	    }

	    setMiterLimit(limit) {
	      this.current.miterLimit = limit;
	    }

	    setStrokeAlpha(strokeAlpha) {
	      this.current.strokeAlpha = strokeAlpha;
	    }

	    setStrokeRGBColor(r, g, b) {
	      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
	    }

	    setFillAlpha(fillAlpha) {
	      this.current.fillAlpha = fillAlpha;
	    }

	    setFillRGBColor(r, g, b) {
	      this.current.fillColor = _util.Util.makeHexColor(r, g, b);
	      this.current.tspan = this.svgFactory.createElement("svg:tspan");
	      this.current.xcoords = [];
	      this.current.ycoords = [];
	    }

	    setStrokeColorN(args) {
	      this.current.strokeColor = this._makeColorN_Pattern(args);
	    }

	    setFillColorN(args) {
	      this.current.fillColor = this._makeColorN_Pattern(args);
	    }

	    shadingFill(args) {
	      const width = this.viewport.width;
	      const height = this.viewport.height;

	      const inv = _util.Util.inverseTransform(this.transformMatrix);

	      const bl = _util.Util.applyTransform([0, 0], inv);

	      const br = _util.Util.applyTransform([0, height], inv);

	      const ul = _util.Util.applyTransform([width, 0], inv);

	      const ur = _util.Util.applyTransform([width, height], inv);

	      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
	      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
	      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
	      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
	      const rect = this.svgFactory.createElement("svg:rect");
	      rect.setAttributeNS(null, "x", x0);
	      rect.setAttributeNS(null, "y", y0);
	      rect.setAttributeNS(null, "width", x1 - x0);
	      rect.setAttributeNS(null, "height", y1 - y0);
	      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

	      if (this.current.fillAlpha < 1) {
	        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
	      }

	      this._ensureTransformGroup().appendChild(rect);
	    }

	    _makeColorN_Pattern(args) {
	      if (args[0] === "TilingPattern") {
	        return this._makeTilingPattern(args);
	      }

	      return this._makeShadingPattern(args);
	    }

	    _makeTilingPattern(args) {
	      const color = args[1];
	      const operatorList = args[2];
	      const matrix = args[3] || _util.IDENTITY_MATRIX;
	      const [x0, y0, x1, y1] = args[4];
	      const xstep = args[5];
	      const ystep = args[6];
	      const paintType = args[7];
	      const tilingId = `shading${shadingCount++}`;

	      const [tx0, ty0] = _util.Util.applyTransform([x0, y0], matrix);

	      const [tx1, ty1] = _util.Util.applyTransform([x1, y1], matrix);

	      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);

	      const txstep = xstep * xscale;
	      const tystep = ystep * yscale;
	      const tiling = this.svgFactory.createElement("svg:pattern");
	      tiling.setAttributeNS(null, "id", tilingId);
	      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
	      tiling.setAttributeNS(null, "width", txstep);
	      tiling.setAttributeNS(null, "height", tystep);
	      tiling.setAttributeNS(null, "x", `${tx0}`);
	      tiling.setAttributeNS(null, "y", `${ty0}`);
	      const svg = this.svg;
	      const transformMatrix = this.transformMatrix;
	      const fillColor = this.current.fillColor;
	      const strokeColor = this.current.strokeColor;
	      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
	      this.svg = bbox;
	      this.transformMatrix = matrix;

	      if (paintType === 2) {
	        const cssColor = _util.Util.makeHexColor(...color);

	        this.current.fillColor = cssColor;
	        this.current.strokeColor = cssColor;
	      }

	      this.executeOpTree(this.convertOpList(operatorList));
	      this.svg = svg;
	      this.transformMatrix = transformMatrix;
	      this.current.fillColor = fillColor;
	      this.current.strokeColor = strokeColor;
	      tiling.appendChild(bbox.childNodes[0]);
	      this.defs.appendChild(tiling);
	      return `url(#${tilingId})`;
	    }

	    _makeShadingPattern(args) {
	      switch (args[0]) {
	        case "RadialAxial":
	          const shadingId = `shading${shadingCount++}`;
	          const colorStops = args[3];
	          let gradient;

	          switch (args[1]) {
	            case "axial":
	              const point0 = args[4];
	              const point1 = args[5];
	              gradient = this.svgFactory.createElement("svg:linearGradient");
	              gradient.setAttributeNS(null, "id", shadingId);
	              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
	              gradient.setAttributeNS(null, "x1", point0[0]);
	              gradient.setAttributeNS(null, "y1", point0[1]);
	              gradient.setAttributeNS(null, "x2", point1[0]);
	              gradient.setAttributeNS(null, "y2", point1[1]);
	              break;

	            case "radial":
	              const focalPoint = args[4];
	              const circlePoint = args[5];
	              const focalRadius = args[6];
	              const circleRadius = args[7];
	              gradient = this.svgFactory.createElement("svg:radialGradient");
	              gradient.setAttributeNS(null, "id", shadingId);
	              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
	              gradient.setAttributeNS(null, "cx", circlePoint[0]);
	              gradient.setAttributeNS(null, "cy", circlePoint[1]);
	              gradient.setAttributeNS(null, "r", circleRadius);
	              gradient.setAttributeNS(null, "fx", focalPoint[0]);
	              gradient.setAttributeNS(null, "fy", focalPoint[1]);
	              gradient.setAttributeNS(null, "fr", focalRadius);
	              break;

	            default:
	              throw new Error(`Unknown RadialAxial type: ${args[1]}`);
	          }

	          for (const colorStop of colorStops) {
	            const stop = this.svgFactory.createElement("svg:stop");
	            stop.setAttributeNS(null, "offset", colorStop[0]);
	            stop.setAttributeNS(null, "stop-color", colorStop[1]);
	            gradient.appendChild(stop);
	          }

	          this.defs.appendChild(gradient);
	          return `url(#${shadingId})`;

	        case "Mesh":
	          (0, _util.warn)("Unimplemented pattern Mesh");
	          return null;

	        case "Dummy":
	          return "hotpink";

	        default:
	          throw new Error(`Unknown IR type: ${args[0]}`);
	      }
	    }

	    setDash(dashArray, dashPhase) {
	      this.current.dashArray = dashArray;
	      this.current.dashPhase = dashPhase;
	    }

	    constructPath(ops, args) {
	      const current = this.current;
	      let x = current.x,
	          y = current.y;
	      let d = [];
	      let j = 0;

	      for (const op of ops) {
	        switch (op | 0) {
	          case _util.OPS.rectangle:
	            x = args[j++];
	            y = args[j++];
	            const width = args[j++];
	            const height = args[j++];
	            const xw = x + width;
	            const yh = y + height;
	            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
	            break;

	          case _util.OPS.moveTo:
	            x = args[j++];
	            y = args[j++];
	            d.push("M", pf(x), pf(y));
	            break;

	          case _util.OPS.lineTo:
	            x = args[j++];
	            y = args[j++];
	            d.push("L", pf(x), pf(y));
	            break;

	          case _util.OPS.curveTo:
	            x = args[j + 4];
	            y = args[j + 5];
	            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
	            j += 6;
	            break;

	          case _util.OPS.curveTo2:
	            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
	            x = args[j + 2];
	            y = args[j + 3];
	            j += 4;
	            break;

	          case _util.OPS.curveTo3:
	            x = args[j + 2];
	            y = args[j + 3];
	            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
	            j += 4;
	            break;

	          case _util.OPS.closePath:
	            d.push("Z");
	            break;
	        }
	      }

	      d = d.join(" ");

	      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
	        d = current.path.getAttributeNS(null, "d") + d;
	      } else {
	        current.path = this.svgFactory.createElement("svg:path");

	        this._ensureTransformGroup().appendChild(current.path);
	      }

	      current.path.setAttributeNS(null, "d", d);
	      current.path.setAttributeNS(null, "fill", "none");
	      current.element = current.path;
	      current.setCurrentPoint(x, y);
	    }

	    endPath() {
	      const current = this.current;
	      current.path = null;

	      if (!this.pendingClip) {
	        return;
	      }

	      if (!current.element) {
	        this.pendingClip = null;
	        return;
	      }

	      const clipId = `clippath${clipCount++}`;
	      const clipPath = this.svgFactory.createElement("svg:clipPath");
	      clipPath.setAttributeNS(null, "id", clipId);
	      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
	      const clipElement = current.element.cloneNode(true);

	      if (this.pendingClip === "evenodd") {
	        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
	      } else {
	        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
	      }

	      this.pendingClip = null;
	      clipPath.appendChild(clipElement);
	      this.defs.appendChild(clipPath);

	      if (current.activeClipUrl) {
	        current.clipGroup = null;
	        this.extraStack.forEach(function (prev) {
	          prev.clipGroup = null;
	        });
	        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
	      }

	      current.activeClipUrl = `url(#${clipId})`;
	      this.tgrp = null;
	    }

	    clip(type) {
	      this.pendingClip = type;
	    }

	    closePath() {
	      const current = this.current;

	      if (current.path) {
	        const d = `${current.path.getAttributeNS(null, "d")}Z`;
	        current.path.setAttributeNS(null, "d", d);
	      }
	    }

	    setLeading(leading) {
	      this.current.leading = -leading;
	    }

	    setTextRise(textRise) {
	      this.current.textRise = textRise;
	    }

	    setTextRenderingMode(textRenderingMode) {
	      this.current.textRenderingMode = textRenderingMode;
	    }

	    setHScale(scale) {
	      this.current.textHScale = scale / 100;
	    }

	    setRenderingIntent(intent) {}

	    setFlatness(flatness) {}

	    setGState(states) {
	      for (const [key, value] of states) {
	        switch (key) {
	          case "LW":
	            this.setLineWidth(value);
	            break;

	          case "LC":
	            this.setLineCap(value);
	            break;

	          case "LJ":
	            this.setLineJoin(value);
	            break;

	          case "ML":
	            this.setMiterLimit(value);
	            break;

	          case "D":
	            this.setDash(value[0], value[1]);
	            break;

	          case "RI":
	            this.setRenderingIntent(value);
	            break;

	          case "FL":
	            this.setFlatness(value);
	            break;

	          case "Font":
	            this.setFont(value);
	            break;

	          case "CA":
	            this.setStrokeAlpha(value);
	            break;

	          case "ca":
	            this.setFillAlpha(value);
	            break;

	          default:
	            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
	            break;
	        }
	      }
	    }

	    fill() {
	      const current = this.current;

	      if (current.element) {
	        current.element.setAttributeNS(null, "fill", current.fillColor);
	        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
	        this.endPath();
	      }
	    }

	    stroke() {
	      const current = this.current;

	      if (current.element) {
	        this._setStrokeAttributes(current.element);

	        current.element.setAttributeNS(null, "fill", "none");
	        this.endPath();
	      }
	    }

	    _setStrokeAttributes(element, lineWidthScale = 1) {
	      const current = this.current;
	      let dashArray = current.dashArray;

	      if (lineWidthScale !== 1 && dashArray.length > 0) {
	        dashArray = dashArray.map(function (value) {
	          return lineWidthScale * value;
	        });
	      }

	      element.setAttributeNS(null, "stroke", current.strokeColor);
	      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
	      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
	      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
	      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
	      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
	      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
	      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
	    }

	    eoFill() {
	      if (this.current.element) {
	        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
	      }

	      this.fill();
	    }

	    fillStroke() {
	      this.stroke();
	      this.fill();
	    }

	    eoFillStroke() {
	      if (this.current.element) {
	        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
	      }

	      this.fillStroke();
	    }

	    closeStroke() {
	      this.closePath();
	      this.stroke();
	    }

	    closeFillStroke() {
	      this.closePath();
	      this.fillStroke();
	    }

	    closeEOFillStroke() {
	      this.closePath();
	      this.eoFillStroke();
	    }

	    paintSolidColorImageMask() {
	      const rect = this.svgFactory.createElement("svg:rect");
	      rect.setAttributeNS(null, "x", "0");
	      rect.setAttributeNS(null, "y", "0");
	      rect.setAttributeNS(null, "width", "1px");
	      rect.setAttributeNS(null, "height", "1px");
	      rect.setAttributeNS(null, "fill", this.current.fillColor);

	      this._ensureTransformGroup().appendChild(rect);
	    }

	    paintImageXObject(objId) {
	      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

	      if (!imgData) {
	        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
	        return;
	      }

	      this.paintInlineImageXObject(imgData);
	    }

	    paintInlineImageXObject(imgData, mask) {
	      const width = imgData.width;
	      const height = imgData.height;
	      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
	      const cliprect = this.svgFactory.createElement("svg:rect");
	      cliprect.setAttributeNS(null, "x", "0");
	      cliprect.setAttributeNS(null, "y", "0");
	      cliprect.setAttributeNS(null, "width", pf(width));
	      cliprect.setAttributeNS(null, "height", pf(height));
	      this.current.element = cliprect;
	      this.clip("nonzero");
	      const imgEl = this.svgFactory.createElement("svg:image");
	      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
	      imgEl.setAttributeNS(null, "x", "0");
	      imgEl.setAttributeNS(null, "y", pf(-height));
	      imgEl.setAttributeNS(null, "width", pf(width) + "px");
	      imgEl.setAttributeNS(null, "height", pf(height) + "px");
	      imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);

	      if (mask) {
	        mask.appendChild(imgEl);
	      } else {
	        this._ensureTransformGroup().appendChild(imgEl);
	      }
	    }

	    paintImageMaskXObject(imgData) {
	      const current = this.current;
	      const width = imgData.width;
	      const height = imgData.height;
	      const fillColor = current.fillColor;
	      current.maskId = `mask${maskCount++}`;
	      const mask = this.svgFactory.createElement("svg:mask");
	      mask.setAttributeNS(null, "id", current.maskId);
	      const rect = this.svgFactory.createElement("svg:rect");
	      rect.setAttributeNS(null, "x", "0");
	      rect.setAttributeNS(null, "y", "0");
	      rect.setAttributeNS(null, "width", pf(width));
	      rect.setAttributeNS(null, "height", pf(height));
	      rect.setAttributeNS(null, "fill", fillColor);
	      rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
	      this.defs.appendChild(mask);

	      this._ensureTransformGroup().appendChild(rect);

	      this.paintInlineImageXObject(imgData, mask);
	    }

	    paintFormXObjectBegin(matrix, bbox) {
	      if (Array.isArray(matrix) && matrix.length === 6) {
	        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
	      }

	      if (bbox) {
	        const width = bbox[2] - bbox[0];
	        const height = bbox[3] - bbox[1];
	        const cliprect = this.svgFactory.createElement("svg:rect");
	        cliprect.setAttributeNS(null, "x", bbox[0]);
	        cliprect.setAttributeNS(null, "y", bbox[1]);
	        cliprect.setAttributeNS(null, "width", pf(width));
	        cliprect.setAttributeNS(null, "height", pf(height));
	        this.current.element = cliprect;
	        this.clip("nonzero");
	        this.endPath();
	      }
	    }

	    paintFormXObjectEnd() {}

	    _initialize(viewport) {
	      const svg = this.svgFactory.create(viewport.width, viewport.height);
	      const definitions = this.svgFactory.createElement("svg:defs");
	      svg.appendChild(definitions);
	      this.defs = definitions;
	      const rootGroup = this.svgFactory.createElement("svg:g");
	      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
	      svg.appendChild(rootGroup);
	      this.svg = rootGroup;
	      return svg;
	    }

	    _ensureClipGroup() {
	      if (!this.current.clipGroup) {
	        const clipGroup = this.svgFactory.createElement("svg:g");
	        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
	        this.svg.appendChild(clipGroup);
	        this.current.clipGroup = clipGroup;
	      }

	      return this.current.clipGroup;
	    }

	    _ensureTransformGroup() {
	      if (!this.tgrp) {
	        this.tgrp = this.svgFactory.createElement("svg:g");
	        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

	        if (this.current.activeClipUrl) {
	          this._ensureClipGroup().appendChild(this.tgrp);
	        } else {
	          this.svg.appendChild(this.tgrp);
	        }
	      }

	      return this.tgrp;
	    }

	  };
	}

	/***/ }),
	/* 22 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFNodeStream = void 0;

	var _util = __w_pdfjs_require__(2);

	var _network_utils = __w_pdfjs_require__(23);

	const fs = require$$1__default['default'];

	const http = require$$3__default['default'];

	const https = require$$4__default['default'];

	const url = require$$5__default['default'];

	const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

	function parseUrl(sourceUrl) {
	  const parsedUrl = url.parse(sourceUrl);

	  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
	    return parsedUrl;
	  }

	  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
	    return url.parse(`file:///${sourceUrl}`);
	  }

	  if (!parsedUrl.host) {
	    parsedUrl.protocol = "file:";
	  }

	  return parsedUrl;
	}

	class PDFNodeStream {
	  constructor(source) {
	    this.source = source;
	    this.url = parseUrl(source.url);
	    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
	    this.isFsUrl = this.url.protocol === "file:";
	    this.httpHeaders = this.isHttp && source.httpHeaders || {};
	    this._fullRequestReader = null;
	    this._rangeRequestReaders = [];
	  }

	  get _progressiveDataLength() {
	    return this._fullRequestReader?._loaded ?? 0;
	  }

	  getFullReader() {
	    (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
	    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
	    return this._fullRequestReader;
	  }

	  getRangeReader(start, end) {
	    if (end <= this._progressiveDataLength) {
	      return null;
	    }

	    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

	    this._rangeRequestReaders.push(rangeReader);

	    return rangeReader;
	  }

	  cancelAllRequests(reason) {
	    if (this._fullRequestReader) {
	      this._fullRequestReader.cancel(reason);
	    }

	    const readers = this._rangeRequestReaders.slice(0);

	    readers.forEach(function (reader) {
	      reader.cancel(reason);
	    });
	  }

	}

	exports.PDFNodeStream = PDFNodeStream;

	class BaseFullReader {
	  constructor(stream) {
	    this._url = stream.url;
	    this._done = false;
	    this._storedError = null;
	    this.onProgress = null;
	    const source = stream.source;
	    this._contentLength = source.length;
	    this._loaded = 0;
	    this._filename = null;
	    this._disableRange = source.disableRange || false;
	    this._rangeChunkSize = source.rangeChunkSize;

	    if (!this._rangeChunkSize && !this._disableRange) {
	      this._disableRange = true;
	    }

	    this._isStreamingSupported = !source.disableStream;
	    this._isRangeSupported = !source.disableRange;
	    this._readableStream = null;
	    this._readCapability = (0, _util.createPromiseCapability)();
	    this._headersCapability = (0, _util.createPromiseCapability)();
	  }

	  get headersReady() {
	    return this._headersCapability.promise;
	  }

	  get filename() {
	    return this._filename;
	  }

	  get contentLength() {
	    return this._contentLength;
	  }

	  get isRangeSupported() {
	    return this._isRangeSupported;
	  }

	  get isStreamingSupported() {
	    return this._isStreamingSupported;
	  }

	  async read() {
	    await this._readCapability.promise;

	    if (this._done) {
	      return {
	        value: undefined,
	        done: true
	      };
	    }

	    if (this._storedError) {
	      throw this._storedError;
	    }

	    const chunk = this._readableStream.read();

	    if (chunk === null) {
	      this._readCapability = (0, _util.createPromiseCapability)();
	      return this.read();
	    }

	    this._loaded += chunk.length;

	    if (this.onProgress) {
	      this.onProgress({
	        loaded: this._loaded,
	        total: this._contentLength
	      });
	    }

	    const buffer = new Uint8Array(chunk).buffer;
	    return {
	      value: buffer,
	      done: false
	    };
	  }

	  cancel(reason) {
	    if (!this._readableStream) {
	      this._error(reason);

	      return;
	    }

	    this._readableStream.destroy(reason);
	  }

	  _error(reason) {
	    this._storedError = reason;

	    this._readCapability.resolve();
	  }

	  _setReadableStream(readableStream) {
	    this._readableStream = readableStream;
	    readableStream.on("readable", () => {
	      this._readCapability.resolve();
	    });
	    readableStream.on("end", () => {
	      readableStream.destroy();
	      this._done = true;

	      this._readCapability.resolve();
	    });
	    readableStream.on("error", reason => {
	      this._error(reason);
	    });

	    if (!this._isStreamingSupported && this._isRangeSupported) {
	      this._error(new _util.AbortException("streaming is disabled"));
	    }

	    if (this._storedError) {
	      this._readableStream.destroy(this._storedError);
	    }
	  }

	}

	class BaseRangeReader {
	  constructor(stream) {
	    this._url = stream.url;
	    this._done = false;
	    this._storedError = null;
	    this.onProgress = null;
	    this._loaded = 0;
	    this._readableStream = null;
	    this._readCapability = (0, _util.createPromiseCapability)();
	    const source = stream.source;
	    this._isStreamingSupported = !source.disableStream;
	  }

	  get isStreamingSupported() {
	    return this._isStreamingSupported;
	  }

	  async read() {
	    await this._readCapability.promise;

	    if (this._done) {
	      return {
	        value: undefined,
	        done: true
	      };
	    }

	    if (this._storedError) {
	      throw this._storedError;
	    }

	    const chunk = this._readableStream.read();

	    if (chunk === null) {
	      this._readCapability = (0, _util.createPromiseCapability)();
	      return this.read();
	    }

	    this._loaded += chunk.length;

	    if (this.onProgress) {
	      this.onProgress({
	        loaded: this._loaded
	      });
	    }

	    const buffer = new Uint8Array(chunk).buffer;
	    return {
	      value: buffer,
	      done: false
	    };
	  }

	  cancel(reason) {
	    if (!this._readableStream) {
	      this._error(reason);

	      return;
	    }

	    this._readableStream.destroy(reason);
	  }

	  _error(reason) {
	    this._storedError = reason;

	    this._readCapability.resolve();
	  }

	  _setReadableStream(readableStream) {
	    this._readableStream = readableStream;
	    readableStream.on("readable", () => {
	      this._readCapability.resolve();
	    });
	    readableStream.on("end", () => {
	      readableStream.destroy();
	      this._done = true;

	      this._readCapability.resolve();
	    });
	    readableStream.on("error", reason => {
	      this._error(reason);
	    });

	    if (this._storedError) {
	      this._readableStream.destroy(this._storedError);
	    }
	  }

	}

	function createRequestOptions(parsedUrl, headers) {
	  return {
	    protocol: parsedUrl.protocol,
	    auth: parsedUrl.auth,
	    host: parsedUrl.hostname,
	    port: parsedUrl.port,
	    path: parsedUrl.path,
	    method: "GET",
	    headers
	  };
	}

	class PDFNodeStreamFullReader extends BaseFullReader {
	  constructor(stream) {
	    super(stream);

	    const handleResponse = response => {
	      if (response.statusCode === 404) {
	        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
	        this._storedError = error;

	        this._headersCapability.reject(error);

	        return;
	      }

	      this._headersCapability.resolve();

	      this._setReadableStream(response);

	      const getResponseHeader = name => {
	        return this._readableStream.headers[name.toLowerCase()];
	      };

	      const {
	        allowRangeRequests,
	        suggestedLength
	      } = (0, _network_utils.validateRangeRequestCapabilities)({
	        getResponseHeader,
	        isHttp: stream.isHttp,
	        rangeChunkSize: this._rangeChunkSize,
	        disableRange: this._disableRange
	      });
	      this._isRangeSupported = allowRangeRequests;
	      this._contentLength = suggestedLength || this._contentLength;
	      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
	    };

	    this._request = null;

	    if (this._url.protocol === "http:") {
	      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
	    } else {
	      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
	    }

	    this._request.on("error", reason => {
	      this._storedError = reason;

	      this._headersCapability.reject(reason);
	    });

	    this._request.end();
	  }

	}

	class PDFNodeStreamRangeReader extends BaseRangeReader {
	  constructor(stream, start, end) {
	    super(stream);
	    this._httpHeaders = {};

	    for (const property in stream.httpHeaders) {
	      const value = stream.httpHeaders[property];

	      if (typeof value === "undefined") {
	        continue;
	      }

	      this._httpHeaders[property] = value;
	    }

	    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;

	    const handleResponse = response => {
	      if (response.statusCode === 404) {
	        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
	        this._storedError = error;
	        return;
	      }

	      this._setReadableStream(response);
	    };

	    this._request = null;

	    if (this._url.protocol === "http:") {
	      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
	    } else {
	      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
	    }

	    this._request.on("error", reason => {
	      this._storedError = reason;
	    });

	    this._request.end();
	  }

	}

	class PDFNodeStreamFsFullReader extends BaseFullReader {
	  constructor(stream) {
	    super(stream);
	    let path = decodeURIComponent(this._url.path);

	    if (fileUriRegex.test(this._url.href)) {
	      path = path.replace(/^\//, "");
	    }

	    fs.lstat(path, (error, stat) => {
	      if (error) {
	        if (error.code === "ENOENT") {
	          error = new _util.MissingPDFException(`Missing PDF "${path}".`);
	        }

	        this._storedError = error;

	        this._headersCapability.reject(error);

	        return;
	      }

	      this._contentLength = stat.size;

	      this._setReadableStream(fs.createReadStream(path));

	      this._headersCapability.resolve();
	    });
	  }

	}

	class PDFNodeStreamFsRangeReader extends BaseRangeReader {
	  constructor(stream, start, end) {
	    super(stream);
	    let path = decodeURIComponent(this._url.path);

	    if (fileUriRegex.test(this._url.href)) {
	      path = path.replace(/^\//, "");
	    }

	    this._setReadableStream(fs.createReadStream(path, {
	      start,
	      end: end - 1
	    }));
	  }

	}

	/***/ }),
	/* 23 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.createResponseStatusError = createResponseStatusError;
	exports.extractFilenameFromHeader = extractFilenameFromHeader;
	exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
	exports.validateResponseStatus = validateResponseStatus;

	var _util = __w_pdfjs_require__(2);

	var _content_disposition = __w_pdfjs_require__(24);

	var _display_utils = __w_pdfjs_require__(1);

	function validateRangeRequestCapabilities({
	  getResponseHeader,
	  isHttp,
	  rangeChunkSize,
	  disableRange
	}) {
	  (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
	  const returnValues = {
	    allowRangeRequests: false,
	    suggestedLength: undefined
	  };
	  const length = parseInt(getResponseHeader("Content-Length"), 10);

	  if (!Number.isInteger(length)) {
	    return returnValues;
	  }

	  returnValues.suggestedLength = length;

	  if (length <= 2 * rangeChunkSize) {
	    return returnValues;
	  }

	  if (disableRange || !isHttp) {
	    return returnValues;
	  }

	  if (getResponseHeader("Accept-Ranges") !== "bytes") {
	    return returnValues;
	  }

	  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";

	  if (contentEncoding !== "identity") {
	    return returnValues;
	  }

	  returnValues.allowRangeRequests = true;
	  return returnValues;
	}

	function extractFilenameFromHeader(getResponseHeader) {
	  const contentDisposition = getResponseHeader("Content-Disposition");

	  if (contentDisposition) {
	    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

	    if (filename.includes("%")) {
	      try {
	        filename = decodeURIComponent(filename);
	      } catch (ex) {}
	    }

	    if ((0, _display_utils.isPdfFile)(filename)) {
	      return filename;
	    }
	  }

	  return null;
	}

	function createResponseStatusError(status, url) {
	  if (status === 404 || status === 0 && url.startsWith("file:")) {
	    return new _util.MissingPDFException('Missing PDF "' + url + '".');
	  }

	  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
	}

	function validateResponseStatus(status) {
	  return status === 200 || status === 206;
	}

	/***/ }),
	/* 24 */
	/***/ ((__unused_webpack_module, exports) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

	function getFilenameFromContentDispositionHeader(contentDisposition) {
	  let needsEncodingFixup = true;
	  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

	  if (tmp) {
	    tmp = tmp[1];
	    let filename = rfc2616unquote(tmp);
	    filename = unescape(filename);
	    filename = rfc5987decode(filename);
	    filename = rfc2047decode(filename);
	    return fixupEncoding(filename);
	  }

	  tmp = rfc2231getparam(contentDisposition);

	  if (tmp) {
	    const filename = rfc2047decode(tmp);
	    return fixupEncoding(filename);
	  }

	  tmp = toParamRegExp("filename", "i").exec(contentDisposition);

	  if (tmp) {
	    tmp = tmp[1];
	    let filename = rfc2616unquote(tmp);
	    filename = rfc2047decode(filename);
	    return fixupEncoding(filename);
	  }

	  function toParamRegExp(attributePattern, flags) {
	    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
	  }

	  function textdecode(encoding, value) {
	    if (encoding) {
	      if (!/^[\x00-\xFF]+$/.test(value)) {
	        return value;
	      }

	      try {
	        const decoder = new TextDecoder(encoding, {
	          fatal: true
	        });
	        const bytes = Array.from(value, function (ch) {
	          return ch.charCodeAt(0) & 0xff;
	        });
	        value = decoder.decode(new Uint8Array(bytes));
	        needsEncodingFixup = false;
	      } catch (e) {
	        if (/^utf-?8$/i.test(encoding)) {
	          try {
	            value = decodeURIComponent(escape(value));
	            needsEncodingFixup = false;
	          } catch (err) {}
	        }
	      }
	    }

	    return value;
	  }

	  function fixupEncoding(value) {
	    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
	      value = textdecode("utf-8", value);

	      if (needsEncodingFixup) {
	        value = textdecode("iso-8859-1", value);
	      }
	    }

	    return value;
	  }

	  function rfc2231getparam(contentDispositionStr) {
	    const matches = [];
	    let match;
	    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

	    while ((match = iter.exec(contentDispositionStr)) !== null) {
	      let [, n, quot, part] = match;
	      n = parseInt(n, 10);

	      if (n in matches) {
	        if (n === 0) {
	          break;
	        }

	        continue;
	      }

	      matches[n] = [quot, part];
	    }

	    const parts = [];

	    for (let n = 0; n < matches.length; ++n) {
	      if (!(n in matches)) {
	        break;
	      }

	      let [quot, part] = matches[n];
	      part = rfc2616unquote(part);

	      if (quot) {
	        part = unescape(part);

	        if (n === 0) {
	          part = rfc5987decode(part);
	        }
	      }

	      parts.push(part);
	    }

	    return parts.join("");
	  }

	  function rfc2616unquote(value) {
	    if (value.startsWith('"')) {
	      const parts = value.slice(1).split('\\"');

	      for (let i = 0; i < parts.length; ++i) {
	        const quotindex = parts[i].indexOf('"');

	        if (quotindex !== -1) {
	          parts[i] = parts[i].slice(0, quotindex);
	          parts.length = i + 1;
	        }

	        parts[i] = parts[i].replace(/\\(.)/g, "$1");
	      }

	      value = parts.join('"');
	    }

	    return value;
	  }

	  function rfc5987decode(extvalue) {
	    const encodingend = extvalue.indexOf("'");

	    if (encodingend === -1) {
	      return extvalue;
	    }

	    const encoding = extvalue.slice(0, encodingend);
	    const langvalue = extvalue.slice(encodingend + 1);
	    const value = langvalue.replace(/^[^']*'/, "");
	    return textdecode(encoding, value);
	  }

	  function rfc2047decode(value) {
	    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
	      return value;
	    }

	    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
	      if (encoding === "q" || encoding === "Q") {
	        text = text.replace(/_/g, " ");
	        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
	          return String.fromCharCode(parseInt(hex, 16));
	        });
	        return textdecode(charset, text);
	      }

	      try {
	        text = atob(text);
	      } catch (e) {}

	      return textdecode(charset, text);
	    });
	  }

	  return "";
	}

	/***/ }),
	/* 25 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFNetworkStream = void 0;

	var _util = __w_pdfjs_require__(2);

	var _network_utils = __w_pdfjs_require__(23);
	const OK_RESPONSE = 200;
	const PARTIAL_CONTENT_RESPONSE = 206;

	function getArrayBuffer(xhr) {
	  const data = xhr.response;

	  if (typeof data !== "string") {
	    return data;
	  }

	  const array = (0, _util.stringToBytes)(data);
	  return array.buffer;
	}

	class NetworkManager {
	  constructor(url, args) {
	    this.url = url;
	    args = args || {};
	    this.isHttp = /^https?:/i.test(url);
	    this.httpHeaders = this.isHttp && args.httpHeaders || {};
	    this.withCredentials = args.withCredentials || false;

	    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
	      return new XMLHttpRequest();
	    };

	    this.currXhrId = 0;
	    this.pendingRequests = Object.create(null);
	  }

	  requestRange(begin, end, listeners) {
	    const args = {
	      begin,
	      end
	    };

	    for (const prop in listeners) {
	      args[prop] = listeners[prop];
	    }

	    return this.request(args);
	  }

	  requestFull(listeners) {
	    return this.request(listeners);
	  }

	  request(args) {
	    const xhr = this.getXhr();
	    const xhrId = this.currXhrId++;
	    const pendingRequest = this.pendingRequests[xhrId] = {
	      xhr
	    };
	    xhr.open("GET", this.url);
	    xhr.withCredentials = this.withCredentials;

	    for (const property in this.httpHeaders) {
	      const value = this.httpHeaders[property];

	      if (typeof value === "undefined") {
	        continue;
	      }

	      xhr.setRequestHeader(property, value);
	    }

	    if (this.isHttp && "begin" in args && "end" in args) {
	      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
	      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
	    } else {
	      pendingRequest.expectedStatus = OK_RESPONSE;
	    }

	    xhr.responseType = "arraybuffer";

	    if (args.onError) {
	      xhr.onerror = function (evt) {
	        args.onError(xhr.status);
	      };
	    }

	    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
	    xhr.onprogress = this.onProgress.bind(this, xhrId);
	    pendingRequest.onHeadersReceived = args.onHeadersReceived;
	    pendingRequest.onDone = args.onDone;
	    pendingRequest.onError = args.onError;
	    pendingRequest.onProgress = args.onProgress;
	    xhr.send(null);
	    return xhrId;
	  }

	  onProgress(xhrId, evt) {
	    const pendingRequest = this.pendingRequests[xhrId];

	    if (!pendingRequest) {
	      return;
	    }

	    if (pendingRequest.onProgress) {
	      pendingRequest.onProgress(evt);
	    }
	  }

	  onStateChange(xhrId, evt) {
	    const pendingRequest = this.pendingRequests[xhrId];

	    if (!pendingRequest) {
	      return;
	    }

	    const xhr = pendingRequest.xhr;

	    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
	      pendingRequest.onHeadersReceived();
	      delete pendingRequest.onHeadersReceived;
	    }

	    if (xhr.readyState !== 4) {
	      return;
	    }

	    if (!(xhrId in this.pendingRequests)) {
	      return;
	    }

	    delete this.pendingRequests[xhrId];

	    if (xhr.status === 0 && this.isHttp) {
	      if (pendingRequest.onError) {
	        pendingRequest.onError(xhr.status);
	      }

	      return;
	    }

	    const xhrStatus = xhr.status || OK_RESPONSE;
	    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

	    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
	      if (pendingRequest.onError) {
	        pendingRequest.onError(xhr.status);
	      }

	      return;
	    }

	    const chunk = getArrayBuffer(xhr);

	    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
	      const rangeHeader = xhr.getResponseHeader("Content-Range");
	      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
	      pendingRequest.onDone({
	        begin: parseInt(matches[1], 10),
	        chunk
	      });
	    } else if (chunk) {
	      pendingRequest.onDone({
	        begin: 0,
	        chunk
	      });
	    } else if (pendingRequest.onError) {
	      pendingRequest.onError(xhr.status);
	    }
	  }

	  getRequestXhr(xhrId) {
	    return this.pendingRequests[xhrId].xhr;
	  }

	  isPendingRequest(xhrId) {
	    return xhrId in this.pendingRequests;
	  }

	  abortRequest(xhrId) {
	    const xhr = this.pendingRequests[xhrId].xhr;
	    delete this.pendingRequests[xhrId];
	    xhr.abort();
	  }

	}

	class PDFNetworkStream {
	  constructor(source) {
	    this._source = source;
	    this._manager = new NetworkManager(source.url, {
	      httpHeaders: source.httpHeaders,
	      withCredentials: source.withCredentials
	    });
	    this._rangeChunkSize = source.rangeChunkSize;
	    this._fullRequestReader = null;
	    this._rangeRequestReaders = [];
	  }

	  _onRangeRequestReaderClosed(reader) {
	    const i = this._rangeRequestReaders.indexOf(reader);

	    if (i >= 0) {
	      this._rangeRequestReaders.splice(i, 1);
	    }
	  }

	  getFullReader() {
	    (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
	    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
	    return this._fullRequestReader;
	  }

	  getRangeReader(begin, end) {
	    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
	    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

	    this._rangeRequestReaders.push(reader);

	    return reader;
	  }

	  cancelAllRequests(reason) {
	    if (this._fullRequestReader) {
	      this._fullRequestReader.cancel(reason);
	    }

	    const readers = this._rangeRequestReaders.slice(0);

	    readers.forEach(function (reader) {
	      reader.cancel(reason);
	    });
	  }

	}

	exports.PDFNetworkStream = PDFNetworkStream;

	class PDFNetworkStreamFullRequestReader {
	  constructor(manager, source) {
	    this._manager = manager;
	    const args = {
	      onHeadersReceived: this._onHeadersReceived.bind(this),
	      onDone: this._onDone.bind(this),
	      onError: this._onError.bind(this),
	      onProgress: this._onProgress.bind(this)
	    };
	    this._url = source.url;
	    this._fullRequestId = manager.requestFull(args);
	    this._headersReceivedCapability = (0, _util.createPromiseCapability)();
	    this._disableRange = source.disableRange || false;
	    this._contentLength = source.length;
	    this._rangeChunkSize = source.rangeChunkSize;

	    if (!this._rangeChunkSize && !this._disableRange) {
	      this._disableRange = true;
	    }

	    this._isStreamingSupported = false;
	    this._isRangeSupported = false;
	    this._cachedChunks = [];
	    this._requests = [];
	    this._done = false;
	    this._storedError = undefined;
	    this._filename = null;
	    this.onProgress = null;
	  }

	  _onHeadersReceived() {
	    const fullRequestXhrId = this._fullRequestId;

	    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

	    const getResponseHeader = name => {
	      return fullRequestXhr.getResponseHeader(name);
	    };

	    const {
	      allowRangeRequests,
	      suggestedLength
	    } = (0, _network_utils.validateRangeRequestCapabilities)({
	      getResponseHeader,
	      isHttp: this._manager.isHttp,
	      rangeChunkSize: this._rangeChunkSize,
	      disableRange: this._disableRange
	    });

	    if (allowRangeRequests) {
	      this._isRangeSupported = true;
	    }

	    this._contentLength = suggestedLength || this._contentLength;
	    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

	    if (this._isRangeSupported) {
	      this._manager.abortRequest(fullRequestXhrId);
	    }

	    this._headersReceivedCapability.resolve();
	  }

	  _onDone(args) {
	    if (args) {
	      if (this._requests.length > 0) {
	        const requestCapability = this._requests.shift();

	        requestCapability.resolve({
	          value: args.chunk,
	          done: false
	        });
	      } else {
	        this._cachedChunks.push(args.chunk);
	      }
	    }

	    this._done = true;

	    if (this._cachedChunks.length > 0) {
	      return;
	    }

	    this._requests.forEach(function (requestCapability) {
	      requestCapability.resolve({
	        value: undefined,
	        done: true
	      });
	    });

	    this._requests = [];
	  }

	  _onError(status) {
	    const url = this._url;
	    const exception = (0, _network_utils.createResponseStatusError)(status, url);
	    this._storedError = exception;

	    this._headersReceivedCapability.reject(exception);

	    this._requests.forEach(function (requestCapability) {
	      requestCapability.reject(exception);
	    });

	    this._requests = [];
	    this._cachedChunks = [];
	  }

	  _onProgress(data) {
	    if (this.onProgress) {
	      this.onProgress({
	        loaded: data.loaded,
	        total: data.lengthComputable ? data.total : this._contentLength
	      });
	    }
	  }

	  get filename() {
	    return this._filename;
	  }

	  get isRangeSupported() {
	    return this._isRangeSupported;
	  }

	  get isStreamingSupported() {
	    return this._isStreamingSupported;
	  }

	  get contentLength() {
	    return this._contentLength;
	  }

	  get headersReady() {
	    return this._headersReceivedCapability.promise;
	  }

	  async read() {
	    if (this._storedError) {
	      throw this._storedError;
	    }

	    if (this._cachedChunks.length > 0) {
	      const chunk = this._cachedChunks.shift();

	      return {
	        value: chunk,
	        done: false
	      };
	    }

	    if (this._done) {
	      return {
	        value: undefined,
	        done: true
	      };
	    }

	    const requestCapability = (0, _util.createPromiseCapability)();

	    this._requests.push(requestCapability);

	    return requestCapability.promise;
	  }

	  cancel(reason) {
	    this._done = true;

	    this._headersReceivedCapability.reject(reason);

	    this._requests.forEach(function (requestCapability) {
	      requestCapability.resolve({
	        value: undefined,
	        done: true
	      });
	    });

	    this._requests = [];

	    if (this._manager.isPendingRequest(this._fullRequestId)) {
	      this._manager.abortRequest(this._fullRequestId);
	    }

	    this._fullRequestReader = null;
	  }

	}

	class PDFNetworkStreamRangeRequestReader {
	  constructor(manager, begin, end) {
	    this._manager = manager;
	    const args = {
	      onDone: this._onDone.bind(this),
	      onProgress: this._onProgress.bind(this)
	    };
	    this._requestId = manager.requestRange(begin, end, args);
	    this._requests = [];
	    this._queuedChunk = null;
	    this._done = false;
	    this.onProgress = null;
	    this.onClosed = null;
	  }

	  _close() {
	    if (this.onClosed) {
	      this.onClosed(this);
	    }
	  }

	  _onDone(data) {
	    const chunk = data.chunk;

	    if (this._requests.length > 0) {
	      const requestCapability = this._requests.shift();

	      requestCapability.resolve({
	        value: chunk,
	        done: false
	      });
	    } else {
	      this._queuedChunk = chunk;
	    }

	    this._done = true;

	    this._requests.forEach(function (requestCapability) {
	      requestCapability.resolve({
	        value: undefined,
	        done: true
	      });
	    });

	    this._requests = [];

	    this._close();
	  }

	  _onProgress(evt) {
	    if (!this.isStreamingSupported && this.onProgress) {
	      this.onProgress({
	        loaded: evt.loaded
	      });
	    }
	  }

	  get isStreamingSupported() {
	    return false;
	  }

	  async read() {
	    if (this._queuedChunk !== null) {
	      const chunk = this._queuedChunk;
	      this._queuedChunk = null;
	      return {
	        value: chunk,
	        done: false
	      };
	    }

	    if (this._done) {
	      return {
	        value: undefined,
	        done: true
	      };
	    }

	    const requestCapability = (0, _util.createPromiseCapability)();

	    this._requests.push(requestCapability);

	    return requestCapability.promise;
	  }

	  cancel(reason) {
	    this._done = true;

	    this._requests.forEach(function (requestCapability) {
	      requestCapability.resolve({
	        value: undefined,
	        done: true
	      });
	    });

	    this._requests = [];

	    if (this._manager.isPendingRequest(this._requestId)) {
	      this._manager.abortRequest(this._requestId);
	    }

	    this._close();
	  }

	}

	/***/ }),
	/* 26 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFFetchStream = void 0;

	var _util = __w_pdfjs_require__(2);

	var _network_utils = __w_pdfjs_require__(23);

	function createFetchOptions(headers, withCredentials, abortController) {
	  return {
	    method: "GET",
	    headers,
	    signal: abortController?.signal,
	    mode: "cors",
	    credentials: withCredentials ? "include" : "same-origin",
	    redirect: "follow"
	  };
	}

	function createHeaders(httpHeaders) {
	  const headers = new Headers();

	  for (const property in httpHeaders) {
	    const value = httpHeaders[property];

	    if (typeof value === "undefined") {
	      continue;
	    }

	    headers.append(property, value);
	  }

	  return headers;
	}

	class PDFFetchStream {
	  constructor(source) {
	    this.source = source;
	    this.isHttp = /^https?:/i.test(source.url);
	    this.httpHeaders = this.isHttp && source.httpHeaders || {};
	    this._fullRequestReader = null;
	    this._rangeRequestReaders = [];
	  }

	  get _progressiveDataLength() {
	    return this._fullRequestReader?._loaded ?? 0;
	  }

	  getFullReader() {
	    (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
	    this._fullRequestReader = new PDFFetchStreamReader(this);
	    return this._fullRequestReader;
	  }

	  getRangeReader(begin, end) {
	    if (end <= this._progressiveDataLength) {
	      return null;
	    }

	    const reader = new PDFFetchStreamRangeReader(this, begin, end);

	    this._rangeRequestReaders.push(reader);

	    return reader;
	  }

	  cancelAllRequests(reason) {
	    if (this._fullRequestReader) {
	      this._fullRequestReader.cancel(reason);
	    }

	    const readers = this._rangeRequestReaders.slice(0);

	    readers.forEach(function (reader) {
	      reader.cancel(reason);
	    });
	  }

	}

	exports.PDFFetchStream = PDFFetchStream;

	class PDFFetchStreamReader {
	  constructor(stream) {
	    this._stream = stream;
	    this._reader = null;
	    this._loaded = 0;
	    this._filename = null;
	    const source = stream.source;
	    this._withCredentials = source.withCredentials || false;
	    this._contentLength = source.length;
	    this._headersCapability = (0, _util.createPromiseCapability)();
	    this._disableRange = source.disableRange || false;
	    this._rangeChunkSize = source.rangeChunkSize;

	    if (!this._rangeChunkSize && !this._disableRange) {
	      this._disableRange = true;
	    }

	    if (typeof AbortController !== "undefined") {
	      this._abortController = new AbortController();
	    }

	    this._isStreamingSupported = !source.disableStream;
	    this._isRangeSupported = !source.disableRange;
	    this._headers = createHeaders(this._stream.httpHeaders);
	    const url = source.url;
	    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
	      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
	        throw (0, _network_utils.createResponseStatusError)(response.status, url);
	      }

	      this._reader = response.body.getReader();

	      this._headersCapability.resolve();

	      const getResponseHeader = name => {
	        return response.headers.get(name);
	      };

	      const {
	        allowRangeRequests,
	        suggestedLength
	      } = (0, _network_utils.validateRangeRequestCapabilities)({
	        getResponseHeader,
	        isHttp: this._stream.isHttp,
	        rangeChunkSize: this._rangeChunkSize,
	        disableRange: this._disableRange
	      });
	      this._isRangeSupported = allowRangeRequests;
	      this._contentLength = suggestedLength || this._contentLength;
	      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

	      if (!this._isStreamingSupported && this._isRangeSupported) {
	        this.cancel(new _util.AbortException("Streaming is disabled."));
	      }
	    }).catch(this._headersCapability.reject);
	    this.onProgress = null;
	  }

	  get headersReady() {
	    return this._headersCapability.promise;
	  }

	  get filename() {
	    return this._filename;
	  }

	  get contentLength() {
	    return this._contentLength;
	  }

	  get isRangeSupported() {
	    return this._isRangeSupported;
	  }

	  get isStreamingSupported() {
	    return this._isStreamingSupported;
	  }

	  async read() {
	    await this._headersCapability.promise;
	    const {
	      value,
	      done
	    } = await this._reader.read();

	    if (done) {
	      return {
	        value,
	        done
	      };
	    }

	    this._loaded += value.byteLength;

	    if (this.onProgress) {
	      this.onProgress({
	        loaded: this._loaded,
	        total: this._contentLength
	      });
	    }

	    const buffer = new Uint8Array(value).buffer;
	    return {
	      value: buffer,
	      done: false
	    };
	  }

	  cancel(reason) {
	    if (this._reader) {
	      this._reader.cancel(reason);
	    }

	    if (this._abortController) {
	      this._abortController.abort();
	    }
	  }

	}

	class PDFFetchStreamRangeReader {
	  constructor(stream, begin, end) {
	    this._stream = stream;
	    this._reader = null;
	    this._loaded = 0;
	    const source = stream.source;
	    this._withCredentials = source.withCredentials || false;
	    this._readCapability = (0, _util.createPromiseCapability)();
	    this._isStreamingSupported = !source.disableStream;

	    if (typeof AbortController !== "undefined") {
	      this._abortController = new AbortController();
	    }

	    this._headers = createHeaders(this._stream.httpHeaders);

	    this._headers.append("Range", `bytes=${begin}-${end - 1}`);

	    const url = source.url;
	    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
	      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
	        throw (0, _network_utils.createResponseStatusError)(response.status, url);
	      }

	      this._readCapability.resolve();

	      this._reader = response.body.getReader();
	    }).catch(reason => {
	      if (reason?.name === "AbortError") {
	        return;
	      }

	      throw reason;
	    });
	    this.onProgress = null;
	  }

	  get isStreamingSupported() {
	    return this._isStreamingSupported;
	  }

	  async read() {
	    await this._readCapability.promise;
	    const {
	      value,
	      done
	    } = await this._reader.read();

	    if (done) {
	      return {
	        value,
	        done
	      };
	    }

	    this._loaded += value.byteLength;

	    if (this.onProgress) {
	      this.onProgress({
	        loaded: this._loaded
	      });
	    }

	    const buffer = new Uint8Array(value).buffer;
	    return {
	      value: buffer,
	      done: false
	    };
	  }

	  cancel(reason) {
	    if (this._reader) {
	      this._reader.cancel(reason);
	    }

	    if (this._abortController) {
	      this._abortController.abort();
	    }
	  }

	}

	/***/ })
	/******/ 	]);
	/************************************************************************/
	/******/ 	// The module cache
	/******/ 	var __webpack_module_cache__ = {};
	/******/ 	
	/******/ 	// The require function
	/******/ 	function __w_pdfjs_require__(moduleId) {
	/******/ 		// Check if module is in cache
	/******/ 		if(__webpack_module_cache__[moduleId]) {
	/******/ 			return __webpack_module_cache__[moduleId].exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = __webpack_module_cache__[moduleId] = {
	/******/ 			// no module.id needed
	/******/ 			// no module.loaded needed
	/******/ 			exports: {}
	/******/ 		};
	/******/ 	
	/******/ 		// Execute the module function
	/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
	/******/ 	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/ 	
	/************************************************************************/
	var __webpack_exports__ = {};
	// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
	(() => {
	var exports = __webpack_exports__;


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	Object.defineProperty(exports, "addLinkAttributes", ({
	  enumerable: true,
	  get: function () {
	    return _display_utils.addLinkAttributes;
	  }
	}));
	Object.defineProperty(exports, "getFilenameFromUrl", ({
	  enumerable: true,
	  get: function () {
	    return _display_utils.getFilenameFromUrl;
	  }
	}));
	Object.defineProperty(exports, "isPdfFile", ({
	  enumerable: true,
	  get: function () {
	    return _display_utils.isPdfFile;
	  }
	}));
	Object.defineProperty(exports, "LinkTarget", ({
	  enumerable: true,
	  get: function () {
	    return _display_utils.LinkTarget;
	  }
	}));
	Object.defineProperty(exports, "loadScript", ({
	  enumerable: true,
	  get: function () {
	    return _display_utils.loadScript;
	  }
	}));
	Object.defineProperty(exports, "PDFDateString", ({
	  enumerable: true,
	  get: function () {
	    return _display_utils.PDFDateString;
	  }
	}));
	Object.defineProperty(exports, "RenderingCancelledException", ({
	  enumerable: true,
	  get: function () {
	    return _display_utils.RenderingCancelledException;
	  }
	}));
	Object.defineProperty(exports, "build", ({
	  enumerable: true,
	  get: function () {
	    return _api.build;
	  }
	}));
	Object.defineProperty(exports, "getDocument", ({
	  enumerable: true,
	  get: function () {
	    return _api.getDocument;
	  }
	}));
	Object.defineProperty(exports, "LoopbackPort", ({
	  enumerable: true,
	  get: function () {
	    return _api.LoopbackPort;
	  }
	}));
	Object.defineProperty(exports, "PDFDataRangeTransport", ({
	  enumerable: true,
	  get: function () {
	    return _api.PDFDataRangeTransport;
	  }
	}));
	Object.defineProperty(exports, "PDFWorker", ({
	  enumerable: true,
	  get: function () {
	    return _api.PDFWorker;
	  }
	}));
	Object.defineProperty(exports, "version", ({
	  enumerable: true,
	  get: function () {
	    return _api.version;
	  }
	}));
	Object.defineProperty(exports, "CMapCompressionType", ({
	  enumerable: true,
	  get: function () {
	    return _util.CMapCompressionType;
	  }
	}));
	Object.defineProperty(exports, "createObjectURL", ({
	  enumerable: true,
	  get: function () {
	    return _util.createObjectURL;
	  }
	}));
	Object.defineProperty(exports, "createPromiseCapability", ({
	  enumerable: true,
	  get: function () {
	    return _util.createPromiseCapability;
	  }
	}));
	Object.defineProperty(exports, "createValidAbsoluteUrl", ({
	  enumerable: true,
	  get: function () {
	    return _util.createValidAbsoluteUrl;
	  }
	}));
	Object.defineProperty(exports, "InvalidPDFException", ({
	  enumerable: true,
	  get: function () {
	    return _util.InvalidPDFException;
	  }
	}));
	Object.defineProperty(exports, "MissingPDFException", ({
	  enumerable: true,
	  get: function () {
	    return _util.MissingPDFException;
	  }
	}));
	Object.defineProperty(exports, "OPS", ({
	  enumerable: true,
	  get: function () {
	    return _util.OPS;
	  }
	}));
	Object.defineProperty(exports, "PasswordResponses", ({
	  enumerable: true,
	  get: function () {
	    return _util.PasswordResponses;
	  }
	}));
	Object.defineProperty(exports, "PermissionFlag", ({
	  enumerable: true,
	  get: function () {
	    return _util.PermissionFlag;
	  }
	}));
	Object.defineProperty(exports, "removeNullCharacters", ({
	  enumerable: true,
	  get: function () {
	    return _util.removeNullCharacters;
	  }
	}));
	Object.defineProperty(exports, "shadow", ({
	  enumerable: true,
	  get: function () {
	    return _util.shadow;
	  }
	}));
	Object.defineProperty(exports, "UnexpectedResponseException", ({
	  enumerable: true,
	  get: function () {
	    return _util.UnexpectedResponseException;
	  }
	}));
	Object.defineProperty(exports, "UNSUPPORTED_FEATURES", ({
	  enumerable: true,
	  get: function () {
	    return _util.UNSUPPORTED_FEATURES;
	  }
	}));
	Object.defineProperty(exports, "Util", ({
	  enumerable: true,
	  get: function () {
	    return _util.Util;
	  }
	}));
	Object.defineProperty(exports, "VerbosityLevel", ({
	  enumerable: true,
	  get: function () {
	    return _util.VerbosityLevel;
	  }
	}));
	Object.defineProperty(exports, "AnnotationLayer", ({
	  enumerable: true,
	  get: function () {
	    return _annotation_layer.AnnotationLayer;
	  }
	}));
	Object.defineProperty(exports, "apiCompatibilityParams", ({
	  enumerable: true,
	  get: function () {
	    return _api_compatibility.apiCompatibilityParams;
	  }
	}));
	Object.defineProperty(exports, "GlobalWorkerOptions", ({
	  enumerable: true,
	  get: function () {
	    return _worker_options.GlobalWorkerOptions;
	  }
	}));
	Object.defineProperty(exports, "renderTextLayer", ({
	  enumerable: true,
	  get: function () {
	    return _text_layer.renderTextLayer;
	  }
	}));
	Object.defineProperty(exports, "SVGGraphics", ({
	  enumerable: true,
	  get: function () {
	    return _svg.SVGGraphics;
	  }
	}));

	var _display_utils = __w_pdfjs_require__(1);

	var _api = __w_pdfjs_require__(5);

	var _util = __w_pdfjs_require__(2);

	var _annotation_layer = __w_pdfjs_require__(18);

	var _api_compatibility = __w_pdfjs_require__(9);

	var _worker_options = __w_pdfjs_require__(12);

	var _text_layer = __w_pdfjs_require__(20);

	var _svg = __w_pdfjs_require__(21);
	{
	  const {
	    isNodeJS
	  } = __w_pdfjs_require__(4);

	  if (isNodeJS) {
	    const PDFNodeStream = __w_pdfjs_require__(22).PDFNodeStream;

	    (0, _api.setPDFNetworkStreamFactory)(params => {
	      return new PDFNodeStream(params);
	    });
	  } else {
	    const PDFNetworkStream = __w_pdfjs_require__(25).PDFNetworkStream;

	    let PDFFetchStream;

	    if ((0, _display_utils.isFetchSupported)()) {
	      PDFFetchStream = __w_pdfjs_require__(26).PDFFetchStream;
	    }

	    (0, _api.setPDFNetworkStreamFactory)(params => {
	      if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {
	        return new PDFFetchStream(params);
	      }

	      return new PDFNetworkStream(params);
	    });
	  }
	}
	})();

	/******/ 	return __webpack_exports__;
	/******/ })()
	;
	});

	});

	var pdf$1 = /*@__PURE__*/getDefaultExportFromCjs(pdf);

	var pdf$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pdf, {
		'default': pdf$1
	}));

	function e(t,e=null,n=["rerun the code 10 times"],i=null,r=!1){if(!$()&&!r)return null;console.error(`%c  pragma.js  %c \n\n      encountered a soft error  %c \n\n      \n${i?`Triggered by: [${i.key} ${i}]`:""}\n      \n${t} %c\n\n      \n${null!=e?`Potential ${e}: \n\t${n.join("\n\t")}`:""}\n      `,"font-size:15px","font-size: 12px;","color:whitesmoke","color:white");}function n(){if(!$())return null;console.log(...arguments);}function i$1(){if(!$())return null;console.log("%c  [pragma] \n\n      ","font-size:12px; color:#86D787;",...arguments,"\n");}class r{constructor(t){this.self=t,this.actions=new Map,this.delete=this.destroy;}addWithKey(t,e=null){e=e||this.actions.size,this.actions.set(e,t);}add(...t){for(let e of t)this.addWithKey(e);}forAction(t){for(let[e,n]of this.actions)t(e,n);}exec(...t){this.execAs(this.self,...t);}destroy(...t){t.forEach((t=>this.actions.delete(t)));}execAs(t,...e){this.forAction((function(n,i){i.bind(t)(...e);}));}}function s(){return Math.random().toString(36).substring(3,6)+Math.random().toString(36).substring(5,8)}function o(){return a(8)}function a(t=7){return t<5?s():(s()+a(t-5)).substring(0,t)}function l(t){return a(t)}function h(t,e){for(let[n,i]of Object.entries(e))t[n]=i;return t}const c=t=>t.replace(/([-_]\w)/g,(t=>t[1].toUpperCase()));function u(t,e){let n=`${t}Chain`,i=`on${t.capitalize()}`;return e[n]=new r(e),e[i]=function(t,i){e[n].addWithKey(t,i);},{chainName:n,eventName:i}}function f(t,...e){for(let n of e)u(n,t);}function d(t,e){let n=u(t,e),i=`is${t.capitalize()}ed`;e[n.chainName].add((()=>{e[i]=!0;})),e[n.eventName]=function(t){if(e[i])return t(e);e[n.chainName].add(t);};}function p(t,...e){for(let n of e)d(n,t);}String.prototype.capitalize=function(){return this.charAt(0).toUpperCase()+this.slice(1)};const m=t=>t.toString().replace(/[^a-z0-9]/gi,"-").toLowerCase();globalThis.pragmaSpace||(globalThis.pragmaSpace={}),p(globalThis.pragmaSpace,"docLoad");const g=globalThis.pragmaSpace.onDocLoad;function y(){globalThis.pragmaSpace.isDocLoaded||(i$1(" document is loaded."),globalThis.pragmaSpace.docLoadChain.exec());}document.addEventListener("readystatechange",(()=>{"complete"===document.readyState&&y();})),document.addEventListener("turbolinks:load",(()=>{i$1(" TURBOLINKS loaded"),y();}));var b=/[#.]/g;function x(t,e="div"){var n=t||"",i={tag:e},r=0;let s,o,a;for(;r<n.length;)b.lastIndex=r,a=b.exec(n),s=n.slice(r,a?a.index:n.length),s&&(o?"#"===o?i.id=s:i.class?i.class.push(s):i.class=[s]:i.tag=s,r+=s.length),a&&(o=a[0],r++);return i}function v(t,n,i){if(!Array.isArray(t))return e(`Could not ${i} class [${t}] -> [${n}]`);for(let e of t){let t=e.split(" ");t.length>1?v(t,n,i):n.classList[i](e);}}function C(t,e){v(t,e,"add");}function T(t,e){v(t,e,"remove");}function A(t,e){v(t,e,"toggle");}function S(t){try{let e=document.querySelector(t);if(e)return e}catch{}let e=x(t),n=document.createElement(e.tag||"div");return e.id&&(n.id=e.id),e.class&&C(e.class,n),n}function _(t){return document.createRange().createContextualFragment(t)}function w(t){return t instanceof Element?t:"string"==typeof t?"<"===t[0]?_(t):S(t):e(`Could not find/create element from [${t}]`)}const M={html:(t,e)=>{e.innerHTML=t;},pcss:(t,e)=>{for(let[n,i]of O.cssToDict(t))e.style[c(n)]=i;}},O={cssToDict:t=>{t=t.replace(/\n/g,";").replace(/:/g," ");let n=new Map;for(let e of t.split(";")){if(e.replace(/\s/g,"").length<2)continue;e=e.trim().split(" ");let t=e[0];e.shift(),n.set(t.trim(),e.join(" ").trim());}let i=[];for(const[t,e]of n.entries())CSS.supports(t,e)||i.push(`${t.trim()}: ${e.trim()}`);return i.length>0&&e("CSS syntax error","typos",i),n},css:t=>{let e="";for(let[n,i]of O.cssToDict(t))e+=`${n}:${i};`;return e},html:t=>t};function $(){return globalThis.pragmaSpace.dev}globalThis.pragmaSpace||(globalThis.pragmaSpace={}),globalThis.pragmaSpace.dev=globalThis.pragmaSpace.dev||"undefined"!=typeof process&&process.env&&"development"===process.env.NODE_ENV;var E=Object.freeze({__proto__:null,_deving:$,throwSoft:e,log:n,suc:i$1,whenDOM:g,parseQuery:x,addClassAryTo:C,removeClassAryFrom:T,toggleClassAryOf:A,selectOrCreateDOM:S,elementFrom:w,toHTMLAttr:m,fragmentFromString:_,fillSVG:function(t,e){j(t).findAll("path").forEach((t=>{const n=t.attr("fill");"none"!=n&&"transparent"!=n&&t.attr("fill",e);}));},generateRandomKey:l,objDiff:h,aryDiff:function(t,e){return t.filter((t=>e.indexOf(t)<0))},_extend:function(t,e){Object.setPrototypeOf(t,h(Object.getPrototypeOf(t),e));},overwrite:function(t,e,n){let i=t[e];t[`_${e}`]=i.bind(t),t[e]=n;},createEventChains:p,createChains:f,snake2camel:c,mimic:function(t,e,n){for(let i of n||Object.keys(e)){let n=Object.getOwnPropertyDescriptor(e,i);if(!n)break;Object.defineProperty(t,i,n);}},bench:function(t,e){console.time(e),t(),console.timeEnd(e);},addStyles:function(t){globalThis.pragmaSpace.styles||(globalThis.pragmaSpace.styles=j("style").prependTo("head")),globalThis.pragmaSpace.styles.html(globalThis.pragmaSpace.styles.html()+t);},rk:a,rk5:s,rk8:o,parse:O,apply:M,createTemplate:t=>(new N).run((function(){f(this,"config"),this.config=function(t){return this.configChain.exec(t),this},this.onConfig(((t={})=>{["events","chains","exports","persistentExports"].forEach((e=>{t[e]&&(this[`_${e}`]=t[e],delete t[e]);})),this._events&&p(this,...this._events),this._chains&&f(this,...this._chains);for(let[e,n]of Object.entries(t))this[e]=n,this.export(e);this._exports&&this.export(...this._exports);})),this.export("exports","config","exportChain","configChain","onConfig");}),(function(){"object"==typeof t&&this.config(t);}))});function k(t){if(null==t||null==t)return e(`Could not find a DOM element for ${t}`);if(t.element)return k(t.element);return w(t)}function j(t,e){let n=k(t);var i,r;return n.constructor===DocumentFragment&&(i=n,(r=document.createElement("template")).appendChild(i.cloneNode(!0)),n=r.firstChild),n instanceof Element&&(n.init(),n._render()),"string"==typeof e&&n.html(e),n}const L={init:function(){this.isPragmaElement=!0,p(this,"docLoad","render"),g((()=>this.docLoadChain.exec(this)));},_render:function(){this.renderChain.exec(this);},appendTo:function(t){return this.onDocLoad((()=>{this._parentElement=k(t),this._parentElement.appendChild(this),this._render();})),this},prependTo:function(t){return this.onDocLoad((()=>{this._parentElement=k(t),this._parentElement.prepend(this),this._render();})),this},append:function(...t){return this.onRender((()=>{for(let e of t){let t=k(e);this.appendChild(t);}})),this},destroy:function(){this.onRender((()=>{this.parentElement&&this.parentElement.removeChild(this);}));},css:function(t){return this.onRender((()=>{M.pcss(t,this);})),this},setText:function(t){return t?(this.onRender((()=>{this.textContent=t;})),this):this.text},html:function(t){return t?(this.onRender((()=>{M.html(t,this);})),this):this.innerHTML},setId:function(t){return this.id=t,this},setData:function(t){for(let[e,n]of Object.entries(t))this.dataset[e]=n;return this},getData:function(t){return this.dataset[t]},addClass:function(...t){return C(t,this),this},removeClass:function(...t){return T(t,this),this},toggleClass:function(...t){return A(t,this),this},listenTo:function(...t){return this.onRender((()=>{this.addEventListener(...t);})),this},attr:function(t,e){if("string"==typeof t){if(void 0===e)return this.getAttribute(t);const n=t;(t={})[n]=e;}for(let[e,n]of Object.entries(t))this.setAttribute(e,n);return this},find:function(){return j(this.query(...arguments))},findAll:function(t){return Array.from(this.queryAll(t)).map((t=>j(t)))},query:function(){return this.querySelector(...arguments)},queryAll:function(t){return this.querySelectorAll(t)},hide:function(){return this.style.display="none",this},show:function(){return this.style.display="",this},deepQueryAll:function(t){let e=Array.from(this.queryAll(t));for(let n of this.children)e=e.concat(n.deepQueryAll(t));return e},deepFindAll:function(t){return this.deepQueryAll(t).map((t=>j(t)))},rect:function(){return "function"==typeof this.getBoundingClientRect?this.getBoundingClientRect():{}},offset:function(t){if(t){["width","height","left","right","top","bottom"].forEach((e=>{e in t&&(this.style[e]=t[e]+"px");}));}var e=this.rect();return {top:e.top+window.scrollY,left:e.left+window.scrollX}},x:function(t){return this.left+this.width/2-t/2}},D={top:function(){return this.offset().top},left:function(){return this.offset().left},width:function(){return this.rect().width},height:function(){return this.rect().height},text:function(){return this.textContent},classArray:function(){return Array.from(this.classList)},childrenArray:function(){return Array.from(this.children)}};for(let[t,e]of Object.entries(L))Element.prototype[t]=e;for(let[t,e]of Object.entries(D))Object.defineProperty(Element.prototype,t,{get:e,configurable:!0});class P{constructor(t){this._childMap=new Map,this.key="string"==typeof t?t:o(),this.containsKey=this.childMap.has;}set childMap(t){for(let[e,n]of t)n instanceof P&&this.add(n);}get childMap(){return this._childMap}get kidsum(){return this.childMap.size}get hasKids(){return this.kidsum>0}get shape(){return this.shapePrefix()}get master(){return null==this.parent||null==this.parent.parent?this.parent:this.parent.master}get children(){return Array.from(this.childMap.values())}get depthKey(){return this.parent?this.parent.depthKey+"<~<"+this.key:this.key}get allChildren(){if(!this.hasKids)return null;let t=this.children;for(let e of t){let n=e.allChildren;n&&(t=t.concat(n));}return t}get(t){return this.childMap.get(t)}find(t){if(this.childMap.has(t))return this.childMap.get(t);for(let e of this.childMap.values()){let n;try{n=e.find(t);}catch{}if(n)return n}}adopt(...t){for(let e of t)this.add(e);return this}add(t,n=!1){return t?!n&&this.childMap.has(t.key)?(t.key=`${t.key}<${s()}`,this.add(t)):(t.parent=this,void this.childMap.set(t.key,t)):e(`Could not add [${t}] to [${this.id}]`)}delete(t){return this.remove(t)}remove(t){this.childMap.get(t)&&this.childMap.delete(t);}shapePrefix(t=""){let e=`${t}| ${this.type} - ${this.key} \n`;if(this.hasKids){t+="| ";for(let n of this.children)e+=n.shapePrefix(t);}return e}}const R={parent:(t,e)=>{t.parent=e;},value:(t,e)=>{t.value=e;},key:(t,e)=>{t.key=e;},class:(t,e)=>{t._class=e;},element:(t,n)=>{if(!(n instanceof Element))return e(`Could not add ${n} as the element of [${t}]`);t.element=n;},children:(t,e)=>{if(e.constructor==Array)return t.buildAry(e);t.build(e);},childTemplate:(t,e)=>{}};function K(t,e){return {val:t,set:e}}function z(t,n,i){if(!n)return K(t,!0);if(i)return K(function(t,n){return function(t){return null!=t.min&&null!=t.max}(n)?t=(t=t>n.max?n.min:t)<n.min?n.max:t:e(`Could not loop value, since range (${JSON.stringify(n)}) is unbounded`)}(t,n),!0);let r=function(t,e){return t=e.min?Math.max(e.min,t):t,e.max?Math.min(e.max,t):t}(t,n);return K(r,r==t)}class N extends P{constructor(t,e){super(),p(this,"export"),this.actionChain=new r,"object"==typeof t?function(t,e){let n=new Map;for(let[i,r]of Object.entries(t))R.hasOwnProperty(i)?R[i](e,r):n.set(i,r);e.element&&e.element.whenInDOM((t=>{for(let[i,r]of n)if(i=i.toLowerCase(),i.includes("on")){let n=i.split("on")[1].trim();t.listenTo(n,(()=>{e.action(r);}));}}));}(t,this):this.key=t,this.element||this.as();}get _e(){return this.element}setElement(t,e=!0){return this.elementDOM=t,e&&this.element.id&&(this.id=this.element.id),this}get element(){return this.elementDOM}set element(t){this.setElement(t);}setRange(t=null,e=null){return this.range=this.range||{},this.range.min=null===t?this.range.min:t,this.range.max=null===e?this.range.max:e,this}breakLoop(){return this._loopVal=!1,this}setLoop(t,e){return this.setRange(t,e),this._loopVal=!0,this}get dv(){return this.v-this._lv}get value(){return this.v}setValue(t){return this.value=t,this}set value(t){let e=z(t,this.range,this._loopVal);e.set&&(this._lv=this.v,this.v=e.val,this.exec());}exec(){return this.actionChain.execAs(this,...arguments),this}setKey(t){return this.key=t,this}set key(t){this._KEY=null==t?l():t;}get key(){return this._KEY}set id(t){this.element&&(this.element.id=this.id);}get id(){return m(this.key)}buildAry(t){for(let e of t)this.add(new N(e,this));return this}build(...t){return this.buildAry(t)}on(t,e=null){var n=this;return {do:function(e){return n.element.listenTo(t,(()=>{n.run(e);})),n}}}as(t=null,e){return t=t||`div#${this.id}.pragma`,this.setElement(j(t,e),!1),this}addExport(t){this.exports=this.exports||new Set,this.exports.add(t);}export(...t){for(let e of t)this.addExport(e);}import(...e){let n=new r;for(let i of e)"function"==typeof i&&(i=i()),i.exports&&E.mimic(this,i,i.exports),i.exportChain&&n.add((t=>{i.exportChain.exec(this);}));return n.exec(),this}from(e){return e.exports&&E.mimic(this,e,e.exports),e.exportChain&&e.exportChain.exec(this),this}wireTo(t){let e=this;return t.do((function(){e.value=this.value;})),this}do(){return this.actionChain.add(...arguments),this}extend(e,n){return E.overwrite(this,e,n),this}run(...t){let n=t[0];return "function"==typeof n?this._runAry(t):"object"==typeof n?this._runAry(Object.values(n)):e(`Could not run [${t}] as [${this}]`),this}_runAry(t){for(let e of t)this.runAs(e);}runAs(t){return t.bind(this)()}containAry(t,n="append"){for(let i of t)super.add(i),i.isRendered?e(`[${i}] is already appended`):this.element[n](i);return this}contain(...t){return this.containAry(t)}containFirst(...t){return this.containAry(t.reverse(),"prepend")}pragmatize(){return this.element.appendTo(this.parent&&this.parent.element||"body"),this}pragmatizeAt(t){return this.element.appendTo(t),this}addListeners(t){for(let[e,n]of Object.entries(t))this.on(e).do(n);return this}}const q=["html","css","addClass","removeClass","toggleClass","setId","append","prepend","appendTo","prependTo","listenTo","setData"];for(let t of q)N.prototype[t]=function(){return this.element[t](...arguments),this};const F=["getData"];for(let t of F)N.prototype[t]=function(){return this.element[t](...arguments)};const I=["offset","text","top","left","width","height","x","classArray"];for(let t of I)Object.defineProperty(N.prototype,t,{get:function(){return this.element[t]}});globalThis.pragmaSpace||(globalThis.pragmaSpace={}),globalThis.pragmaSpace.integrateMousetrap=function(t){"function"==typeof t&&(N.prototype.bind=function(e,n,i){let r=this;return t.bind(e,(function(){return r.runAs(n)}),i),this},globalThis.pragmaSpace.mousetrapIntegration=!0,i$1("Mousetrap configuration detected! Extended Pragmas to support .bind() method!"));};try{globalThis.pragmaSpace.integrateMousetrap(Mousetrap);}catch(t){n("Tried to integrate extensions, but failed. To disable,\n  this attempt: globalThis.pragmaSpace.integrate3rdParties = false");}function U(t){return new Promise((e=>e(t())))}function B(...t){return U((()=>{for(let e of t)U(e);}))}const Q=(t,e)=>new N(t,e),W=Q;

	/*
	 * anime.js v3.2.1
	 * (c) 2020 Julian Garnier
	 * Released under the MIT license
	 * animejs.com
	 */

	// Defaults

	var defaultInstanceSettings = {
	  update: null,
	  begin: null,
	  loopBegin: null,
	  changeBegin: null,
	  change: null,
	  changeComplete: null,
	  loopComplete: null,
	  complete: null,
	  loop: 1,
	  direction: 'normal',
	  autoplay: true,
	  timelineOffset: 0
	};

	var defaultTweenSettings = {
	  duration: 1000,
	  delay: 0,
	  endDelay: 0,
	  easing: 'easeOutElastic(1, .5)',
	  round: 0
	};

	var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective', 'matrix', 'matrix3d'];

	// Caching

	var cache$2 = {
	  CSS: {},
	  springs: {}
	};

	// Utils

	function minMax(val, min, max) {
	  return Math.min(Math.max(val, min), max);
	}

	function stringContains(str, text) {
	  return str.indexOf(text) > -1;
	}

	function applyArguments(func, args) {
	  return func.apply(null, args);
	}

	var is = {
	  arr: function (a) { return Array.isArray(a); },
	  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
	  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
	  svg: function (a) { return a instanceof SVGElement; },
	  inp: function (a) { return a instanceof HTMLInputElement; },
	  dom: function (a) { return a.nodeType || is.svg(a); },
	  str: function (a) { return typeof a === 'string'; },
	  fnc: function (a) { return typeof a === 'function'; },
	  und: function (a) { return typeof a === 'undefined'; },
	  nil: function (a) { return is.und(a) || a === null; },
	  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
	  rgb: function (a) { return /^rgb/.test(a); },
	  hsl: function (a) { return /^hsl/.test(a); },
	  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
	  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; },
	};

	// Easings

	function parseEasingParameters(string) {
	  var match = /\(([^)]+)\)/.exec(string);
	  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
	}

	// Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

	function spring(string, duration) {

	  var params = parseEasingParameters(string);
	  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
	  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
	  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
	  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
	  var w0 = Math.sqrt(stiffness / mass);
	  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
	  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
	  var a = 1;
	  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

	  function solver(t) {
	    var progress = duration ? (duration * t) / 1000 : t;
	    if (zeta < 1) {
	      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
	    } else {
	      progress = (a + b * progress) * Math.exp(-progress * w0);
	    }
	    if (t === 0 || t === 1) { return t; }
	    return 1 - progress;
	  }

	  function getDuration() {
	    var cached = cache$2.springs[string];
	    if (cached) { return cached; }
	    var frame = 1/6;
	    var elapsed = 0;
	    var rest = 0;
	    while(true) {
	      elapsed += frame;
	      if (solver(elapsed) === 1) {
	        rest++;
	        if (rest >= 16) { break; }
	      } else {
	        rest = 0;
	      }
	    }
	    var duration = elapsed * frame * 1000;
	    cache$2.springs[string] = duration;
	    return duration;
	  }

	  return duration ? solver : getDuration;

	}

	// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

	function steps$1(steps) {
	  if ( steps === void 0 ) steps = 10;

	  return function (t) { return Math.ceil((minMax(t, 0.000001, 1)) * steps) * (1 / steps); };
	}

	// BezierEasing https://github.com/gre/bezier-easing

	var bezier = (function () {

	  var kSplineTableSize = 11;
	  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
	  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
	  function C(aA1)      { return 3.0 * aA1 }

	  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
	  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

	  function binarySubdivide(aX, aA, aB, mX1, mX2) {
	    var currentX, currentT, i = 0;
	    do {
	      currentT = aA + (aB - aA) / 2.0;
	      currentX = calcBezier(currentT, mX1, mX2) - aX;
	      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
	    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
	    return currentT;
	  }

	  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
	    for (var i = 0; i < 4; ++i) {
	      var currentSlope = getSlope(aGuessT, mX1, mX2);
	      if (currentSlope === 0.0) { return aGuessT; }
	      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	      aGuessT -= currentX / currentSlope;
	    }
	    return aGuessT;
	  }

	  function bezier(mX1, mY1, mX2, mY2) {

	    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
	    var sampleValues = new Float32Array(kSplineTableSize);

	    if (mX1 !== mY1 || mX2 !== mY2) {
	      for (var i = 0; i < kSplineTableSize; ++i) {
	        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	      }
	    }

	    function getTForX(aX) {

	      var intervalStart = 0;
	      var currentSample = 1;
	      var lastSample = kSplineTableSize - 1;

	      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
	        intervalStart += kSampleStepSize;
	      }

	      --currentSample;

	      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
	      var guessForT = intervalStart + dist * kSampleStepSize;
	      var initialSlope = getSlope(guessForT, mX1, mX2);

	      if (initialSlope >= 0.001) {
	        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	      } else if (initialSlope === 0.0) {
	        return guessForT;
	      } else {
	        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	      }

	    }

	    return function (x) {
	      if (mX1 === mY1 && mX2 === mY2) { return x; }
	      if (x === 0 || x === 1) { return x; }
	      return calcBezier(getTForX(x), mY1, mY2);
	    }

	  }

	  return bezier;

	})();

	var penner = (function () {

	  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

	  var eases = { linear: function () { return function (t) { return t; }; } };

	  var functionEasings = {
	    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
	    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
	    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
	    Bounce: function () { return function (t) {
	      var pow2, b = 4;
	      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
	      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
	    }; },
	    Elastic: function (amplitude, period) {
	      if ( amplitude === void 0 ) amplitude = 1;
	      if ( period === void 0 ) period = .5;

	      var a = minMax(amplitude, 1, 10);
	      var p = minMax(period, .1, 2);
	      return function (t) {
	        return (t === 0 || t === 1) ? t : 
	          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
	      }
	    }
	  };

	  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

	  baseEasings.forEach(function (name, i) {
	    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
	  });

	  Object.keys(functionEasings).forEach(function (name) {
	    var easeIn = functionEasings[name];
	    eases['easeIn' + name] = easeIn;
	    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
	    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
	      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
	    eases['easeOutIn' + name] = function (a, b) { return function (t) { return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : 
	      (easeIn(a, b)(t * 2 - 1) + 1) / 2; }; };
	  });

	  return eases;

	})();

	function parseEasings(easing, duration) {
	  if (is.fnc(easing)) { return easing; }
	  var name = easing.split('(')[0];
	  var ease = penner[name];
	  var args = parseEasingParameters(easing);
	  switch (name) {
	    case 'spring' : return spring(easing, duration);
	    case 'cubicBezier' : return applyArguments(bezier, args);
	    case 'steps' : return applyArguments(steps$1, args);
	    default : return applyArguments(ease, args);
	  }
	}

	// Strings

	function selectString(str) {
	  try {
	    var nodes = document.querySelectorAll(str);
	    return nodes;
	  } catch(e) {
	    return;
	  }
	}

	// Arrays

	function filterArray(arr, callback) {
	  var len = arr.length;
	  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
	  var result = [];
	  for (var i = 0; i < len; i++) {
	    if (i in arr) {
	      var val = arr[i];
	      if (callback.call(thisArg, val, i, arr)) {
	        result.push(val);
	      }
	    }
	  }
	  return result;
	}

	function flattenArray(arr) {
	  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
	}

	function toArray$1(o) {
	  if (is.arr(o)) { return o; }
	  if (is.str(o)) { o = selectString(o) || o; }
	  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
	  return [o];
	}

	function arrayContains(arr, val) {
	  return arr.some(function (a) { return a === val; });
	}

	// Objects

	function cloneObject(o) {
	  var clone = {};
	  for (var p in o) { clone[p] = o[p]; }
	  return clone;
	}

	function replaceObjectProps(o1, o2) {
	  var o = cloneObject(o1);
	  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
	  return o;
	}

	function mergeObjects(o1, o2) {
	  var o = cloneObject(o1);
	  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
	  return o;
	}

	// Colors

	function rgbToRgba(rgbValue) {
	  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
	  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
	}

	function hexToRgba(hexValue) {
	  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
	  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	  var r = parseInt(rgb[1], 16);
	  var g = parseInt(rgb[2], 16);
	  var b = parseInt(rgb[3], 16);
	  return ("rgba(" + r + "," + g + "," + b + ",1)");
	}

	function hslToRgba(hslValue) {
	  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
	  var h = parseInt(hsl[1], 10) / 360;
	  var s = parseInt(hsl[2], 10) / 100;
	  var l = parseInt(hsl[3], 10) / 100;
	  var a = hsl[4] || 1;
	  function hue2rgb(p, q, t) {
	    if (t < 0) { t += 1; }
	    if (t > 1) { t -= 1; }
	    if (t < 1/6) { return p + (q - p) * 6 * t; }
	    if (t < 1/2) { return q; }
	    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
	    return p;
	  }
	  var r, g, b;
	  if (s == 0) {
	    r = g = b = l;
	  } else {
	    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	    var p = 2 * l - q;
	    r = hue2rgb(p, q, h + 1/3);
	    g = hue2rgb(p, q, h);
	    b = hue2rgb(p, q, h - 1/3);
	  }
	  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
	}

	function colorToRgb(val) {
	  if (is.rgb(val)) { return rgbToRgba(val); }
	  if (is.hex(val)) { return hexToRgba(val); }
	  if (is.hsl(val)) { return hslToRgba(val); }
	}

	// Units

	function getUnit(val) {
	  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
	  if (split) { return split[1]; }
	}

	function getTransformUnit(propName) {
	  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
	  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
	}

	// Values

	function getFunctionValue(val, animatable) {
	  if (!is.fnc(val)) { return val; }
	  return val(animatable.target, animatable.id, animatable.total);
	}

	function getAttribute(el, prop) {
	  return el.getAttribute(prop);
	}

	function convertPxToUnit(el, value, unit) {
	  var valueUnit = getUnit(value);
	  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
	  var cached = cache$2.CSS[value + unit];
	  if (!is.und(cached)) { return cached; }
	  var baseline = 100;
	  var tempEl = document.createElement(el.tagName);
	  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
	  parentEl.appendChild(tempEl);
	  tempEl.style.position = 'absolute';
	  tempEl.style.width = baseline + unit;
	  var factor = baseline / tempEl.offsetWidth;
	  parentEl.removeChild(tempEl);
	  var convertedUnit = factor * parseFloat(value);
	  cache$2.CSS[value + unit] = convertedUnit;
	  return convertedUnit;
	}

	function getCSSValue(el, prop, unit) {
	  if (prop in el.style) {
	    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
	    return unit ? convertPxToUnit(el, value, unit) : value;
	  }
	}

	function getAnimationType(el, prop) {
	  if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || (is.svg(el) && el[prop]))) { return 'attribute'; }
	  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
	  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
	  if (el[prop] != null) { return 'object'; }
	}

	function getElementTransforms(el) {
	  if (!is.dom(el)) { return; }
	  var str = el.style.transform || '';
	  var reg  = /(\w+)\(([^)]*)\)/g;
	  var transforms = new Map();
	  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
	  return transforms;
	}

	function getTransformValue(el, propName, animatable, unit) {
	  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
	  var value = getElementTransforms(el).get(propName) || defaultVal;
	  if (animatable) {
	    animatable.transforms.list.set(propName, value);
	    animatable.transforms['last'] = propName;
	  }
	  return unit ? convertPxToUnit(el, value, unit) : value;
	}

	function getOriginalTargetValue(target, propName, unit, animatable) {
	  switch (getAnimationType(target, propName)) {
	    case 'transform': return getTransformValue(target, propName, animatable, unit);
	    case 'css': return getCSSValue(target, propName, unit);
	    case 'attribute': return getAttribute(target, propName);
	    default: return target[propName] || 0;
	  }
	}

	function getRelativeValue(to, from) {
	  var operator = /^(\*=|\+=|-=)/.exec(to);
	  if (!operator) { return to; }
	  var u = getUnit(to) || 0;
	  var x = parseFloat(from);
	  var y = parseFloat(to.replace(operator[0], ''));
	  switch (operator[0][0]) {
	    case '+': return x + y + u;
	    case '-': return x - y + u;
	    case '*': return x * y + u;
	  }
	}

	function validateValue(val, unit) {
	  if (is.col(val)) { return colorToRgb(val); }
	  if (/\s/g.test(val)) { return val; }
	  var originalUnit = getUnit(val);
	  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
	  if (unit) { return unitLess + unit; }
	  return unitLess;
	}

	// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
	// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

	function getDistance(p1, p2) {
	  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
	}

	function getCircleLength(el) {
	  return Math.PI * 2 * getAttribute(el, 'r');
	}

	function getRectLength(el) {
	  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
	}

	function getLineLength(el) {
	  return getDistance(
	    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
	    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
	  );
	}

	function getPolylineLength(el) {
	  var points = el.points;
	  var totalLength = 0;
	  var previousPos;
	  for (var i = 0 ; i < points.numberOfItems; i++) {
	    var currentPos = points.getItem(i);
	    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
	    previousPos = currentPos;
	  }
	  return totalLength;
	}

	function getPolygonLength(el) {
	  var points = el.points;
	  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
	}

	// Path animation

	function getTotalLength(el) {
	  if (el.getTotalLength) { return el.getTotalLength(); }
	  switch(el.tagName.toLowerCase()) {
	    case 'circle': return getCircleLength(el);
	    case 'rect': return getRectLength(el);
	    case 'line': return getLineLength(el);
	    case 'polyline': return getPolylineLength(el);
	    case 'polygon': return getPolygonLength(el);
	  }
	}

	function setDashoffset(el) {
	  var pathLength = getTotalLength(el);
	  el.setAttribute('stroke-dasharray', pathLength);
	  return pathLength;
	}

	// Motion path

	function getParentSvgEl(el) {
	  var parentEl = el.parentNode;
	  while (is.svg(parentEl)) {
	    if (!is.svg(parentEl.parentNode)) { break; }
	    parentEl = parentEl.parentNode;
	  }
	  return parentEl;
	}

	function getParentSvg(pathEl, svgData) {
	  var svg = svgData || {};
	  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
	  var rect = parentSvgEl.getBoundingClientRect();
	  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
	  var width = rect.width;
	  var height = rect.height;
	  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
	  return {
	    el: parentSvgEl,
	    viewBox: viewBox,
	    x: viewBox[0] / 1,
	    y: viewBox[1] / 1,
	    w: width,
	    h: height,
	    vW: viewBox[2],
	    vH: viewBox[3]
	  }
	}

	function getPath(path, percent) {
	  var pathEl = is.str(path) ? selectString(path)[0] : path;
	  var p = percent || 100;
	  return function(property) {
	    return {
	      property: property,
	      el: pathEl,
	      svg: getParentSvg(pathEl),
	      totalLength: getTotalLength(pathEl) * (p / 100)
	    }
	  }
	}

	function getPathProgress(path, progress, isPathTargetInsideSVG) {
	  function point(offset) {
	    if ( offset === void 0 ) offset = 0;

	    var l = progress + offset >= 1 ? progress + offset : 0;
	    return path.el.getPointAtLength(l);
	  }
	  var svg = getParentSvg(path.el, path.svg);
	  var p = point();
	  var p0 = point(-1);
	  var p1 = point(+1);
	  var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
	  var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;
	  switch (path.property) {
	    case 'x': return (p.x - svg.x) * scaleX;
	    case 'y': return (p.y - svg.y) * scaleY;
	    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
	  }
	}

	// Decompose value

	function decomposeValue(val, unit) {
	  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
	  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
	  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
	  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
	  return {
	    original: value,
	    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
	    strings: (is.str(val) || unit) ? value.split(rgx) : []
	  }
	}

	// Animatables

	function parseTargets(targets) {
	  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray$1) : toArray$1(targets))) : [];
	  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
	}

	function getAnimatables(targets) {
	  var parsed = parseTargets(targets);
	  return parsed.map(function (t, i) {
	    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
	  });
	}

	// Properties

	function normalizePropertyTweens(prop, tweenSettings) {
	  var settings = cloneObject(tweenSettings);
	  // Override duration if easing is a spring
	  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
	  if (is.arr(prop)) {
	    var l = prop.length;
	    var isFromTo = (l === 2 && !is.obj(prop[0]));
	    if (!isFromTo) {
	      // Duration divided by the number of tweens
	      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
	    } else {
	      // Transform [from, to] values shorthand to a valid tween value
	      prop = {value: prop};
	    }
	  }
	  var propArray = is.arr(prop) ? prop : [prop];
	  return propArray.map(function (v, i) {
	    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
	    // Default delay value should only be applied to the first tween
	    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
	    // Default endDelay value should only be applied to the last tween
	    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
	    return obj;
	  }).map(function (k) { return mergeObjects(k, settings); });
	}


	function flattenKeyframes(keyframes) {
	  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
	  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
	  var properties = {};
	  var loop = function ( i ) {
	    var propName = propertyNames[i];
	    properties[propName] = keyframes.map(function (key) {
	      var newKey = {};
	      for (var p in key) {
	        if (is.key(p)) {
	          if (p == propName) { newKey.value = key[p]; }
	        } else {
	          newKey[p] = key[p];
	        }
	      }
	      return newKey;
	    });
	  };

	  for (var i = 0; i < propertyNames.length; i++) loop( i );
	  return properties;
	}

	function getProperties(tweenSettings, params) {
	  var properties = [];
	  var keyframes = params.keyframes;
	  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
	  for (var p in params) {
	    if (is.key(p)) {
	      properties.push({
	        name: p,
	        tweens: normalizePropertyTweens(params[p], tweenSettings)
	      });
	    }
	  }
	  return properties;
	}

	// Tweens

	function normalizeTweenValues(tween, animatable) {
	  var t = {};
	  for (var p in tween) {
	    var value = getFunctionValue(tween[p], animatable);
	    if (is.arr(value)) {
	      value = value.map(function (v) { return getFunctionValue(v, animatable); });
	      if (value.length === 1) { value = value[0]; }
	    }
	    t[p] = value;
	  }
	  t.duration = parseFloat(t.duration);
	  t.delay = parseFloat(t.delay);
	  return t;
	}

	function normalizeTweens(prop, animatable) {
	  var previousTween;
	  return prop.tweens.map(function (t) {
	    var tween = normalizeTweenValues(t, animatable);
	    var tweenValue = tween.value;
	    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
	    var toUnit = getUnit(to);
	    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
	    var previousValue = previousTween ? previousTween.to.original : originalValue;
	    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
	    var fromUnit = getUnit(from) || getUnit(originalValue);
	    var unit = toUnit || fromUnit;
	    if (is.und(to)) { to = previousValue; }
	    tween.from = decomposeValue(from, unit);
	    tween.to = decomposeValue(getRelativeValue(to, from), unit);
	    tween.start = previousTween ? previousTween.end : 0;
	    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
	    tween.easing = parseEasings(tween.easing, tween.duration);
	    tween.isPath = is.pth(tweenValue);
	    tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
	    tween.isColor = is.col(tween.from.original);
	    if (tween.isColor) { tween.round = 1; }
	    previousTween = tween;
	    return tween;
	  });
	}

	// Tween progress

	var setProgressValue = {
	  css: function (t, p, v) { return t.style[p] = v; },
	  attribute: function (t, p, v) { return t.setAttribute(p, v); },
	  object: function (t, p, v) { return t[p] = v; },
	  transform: function (t, p, v, transforms, manual) {
	    transforms.list.set(p, v);
	    if (p === transforms.last || manual) {
	      var str = '';
	      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
	      t.style.transform = str;
	    }
	  }
	};

	// Set Value helper

	function setTargetsValue(targets, properties) {
	  var animatables = getAnimatables(targets);
	  animatables.forEach(function (animatable) {
	    for (var property in properties) {
	      var value = getFunctionValue(properties[property], animatable);
	      var target = animatable.target;
	      var valueUnit = getUnit(value);
	      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
	      var unit = valueUnit || getUnit(originalValue);
	      var to = getRelativeValue(validateValue(value, unit), originalValue);
	      var animType = getAnimationType(target, property);
	      setProgressValue[animType](target, property, to, animatable.transforms, true);
	    }
	  });
	}

	// Animations

	function createAnimation(animatable, prop) {
	  var animType = getAnimationType(animatable.target, prop.name);
	  if (animType) {
	    var tweens = normalizeTweens(prop, animatable);
	    var lastTween = tweens[tweens.length - 1];
	    return {
	      type: animType,
	      property: prop.name,
	      animatable: animatable,
	      tweens: tweens,
	      duration: lastTween.end,
	      delay: tweens[0].delay,
	      endDelay: lastTween.endDelay
	    }
	  }
	}

	function getAnimations(animatables, properties) {
	  return filterArray(flattenArray(animatables.map(function (animatable) {
	    return properties.map(function (prop) {
	      return createAnimation(animatable, prop);
	    });
	  })), function (a) { return !is.und(a); });
	}

	// Create Instance

	function getInstanceTimings(animations, tweenSettings) {
	  var animLength = animations.length;
	  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
	  var timings = {};
	  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
	  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
	  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
	  return timings;
	}

	var instanceID = 0;

	function createNewInstance(params) {
	  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
	  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
	  var properties = getProperties(tweenSettings, params);
	  var animatables = getAnimatables(params.targets);
	  var animations = getAnimations(animatables, properties);
	  var timings = getInstanceTimings(animations, tweenSettings);
	  var id = instanceID;
	  instanceID++;
	  return mergeObjects(instanceSettings, {
	    id: id,
	    children: [],
	    animatables: animatables,
	    animations: animations,
	    duration: timings.duration,
	    delay: timings.delay,
	    endDelay: timings.endDelay
	  });
	}

	// Core

	var activeInstances = [];

	var engine = (function () {
	  var raf;

	  function play() {
	    if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
	      raf = requestAnimationFrame(step);
	    }
	  }
	  function step(t) {
	    // memo on algorithm issue:
	    // dangerous iteration over mutable `activeInstances`
	    // (that collection may be updated from within callbacks of `tick`-ed animation instances)
	    var activeInstancesLength = activeInstances.length;
	    var i = 0;
	    while (i < activeInstancesLength) {
	      var activeInstance = activeInstances[i];
	      if (!activeInstance.paused) {
	        activeInstance.tick(t);
	        i++;
	      } else {
	        activeInstances.splice(i, 1);
	        activeInstancesLength--;
	      }
	    }
	    raf = i > 0 ? requestAnimationFrame(step) : undefined;
	  }

	  function handleVisibilityChange() {
	    if (!anime.suspendWhenDocumentHidden) { return; }

	    if (isDocumentHidden()) {
	      // suspend ticks
	      raf = cancelAnimationFrame(raf);
	    } else { // is back to active tab
	      // first adjust animations to consider the time that ticks were suspended
	      activeInstances.forEach(
	        function (instance) { return instance ._onDocumentVisibility(); }
	      );
	      engine();
	    }
	  }
	  if (typeof document !== 'undefined') {
	    document.addEventListener('visibilitychange', handleVisibilityChange);
	  }

	  return play;
	})();

	function isDocumentHidden() {
	  return !!document && document.hidden;
	}

	// Public Instance

	function anime(params) {
	  if ( params === void 0 ) params = {};


	  var startTime = 0, lastTime = 0, now = 0;
	  var children, childrenLength = 0;
	  var resolve = null;

	  function makePromise(instance) {
	    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
	    instance.finished = promise;
	    return promise;
	  }

	  var instance = createNewInstance(params);
	  makePromise(instance);

	  function toggleInstanceDirection() {
	    var direction = instance.direction;
	    if (direction !== 'alternate') {
	      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
	    }
	    instance.reversed = !instance.reversed;
	    children.forEach(function (child) { return child.reversed = instance.reversed; });
	  }

	  function adjustTime(time) {
	    return instance.reversed ? instance.duration - time : time;
	  }

	  function resetTime() {
	    startTime = 0;
	    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
	  }

	  function seekChild(time, child) {
	    if (child) { child.seek(time - child.timelineOffset); }
	  }

	  function syncInstanceChildren(time) {
	    if (!instance.reversePlayback) {
	      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
	    } else {
	      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
	    }
	  }

	  function setAnimationsProgress(insTime) {
	    var i = 0;
	    var animations = instance.animations;
	    var animationsLength = animations.length;
	    while (i < animationsLength) {
	      var anim = animations[i];
	      var animatable = anim.animatable;
	      var tweens = anim.tweens;
	      var tweenLength = tweens.length - 1;
	      var tween = tweens[tweenLength];
	      // Only check for keyframes if there is more than one tween
	      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
	      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
	      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
	      var strings = tween.to.strings;
	      var round = tween.round;
	      var numbers = [];
	      var toNumbersLength = tween.to.numbers.length;
	      var progress = (void 0);
	      for (var n = 0; n < toNumbersLength; n++) {
	        var value = (void 0);
	        var toNumber = tween.to.numbers[n];
	        var fromNumber = tween.from.numbers[n] || 0;
	        if (!tween.isPath) {
	          value = fromNumber + (eased * (toNumber - fromNumber));
	        } else {
	          value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
	        }
	        if (round) {
	          if (!(tween.isColor && n > 2)) {
	            value = Math.round(value * round) / round;
	          }
	        }
	        numbers.push(value);
	      }
	      // Manual Array.reduce for better performances
	      var stringsLength = strings.length;
	      if (!stringsLength) {
	        progress = numbers[0];
	      } else {
	        progress = strings[0];
	        for (var s = 0; s < stringsLength; s++) {
	          strings[s];
	          var b = strings[s + 1];
	          var n$1 = numbers[s];
	          if (!isNaN(n$1)) {
	            if (!b) {
	              progress += n$1 + ' ';
	            } else {
	              progress += n$1 + b;
	            }
	          }
	        }
	      }
	      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
	      anim.currentValue = progress;
	      i++;
	    }
	  }

	  function setCallback(cb) {
	    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
	  }

	  function countIteration() {
	    if (instance.remaining && instance.remaining !== true) {
	      instance.remaining--;
	    }
	  }

	  function setInstanceProgress(engineTime) {
	    var insDuration = instance.duration;
	    var insDelay = instance.delay;
	    var insEndDelay = insDuration - instance.endDelay;
	    var insTime = adjustTime(engineTime);
	    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
	    instance.reversePlayback = insTime < instance.currentTime;
	    if (children) { syncInstanceChildren(insTime); }
	    if (!instance.began && instance.currentTime > 0) {
	      instance.began = true;
	      setCallback('begin');
	    }
	    if (!instance.loopBegan && instance.currentTime > 0) {
	      instance.loopBegan = true;
	      setCallback('loopBegin');
	    }
	    if (insTime <= insDelay && instance.currentTime !== 0) {
	      setAnimationsProgress(0);
	    }
	    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
	      setAnimationsProgress(insDuration);
	    }
	    if (insTime > insDelay && insTime < insEndDelay) {
	      if (!instance.changeBegan) {
	        instance.changeBegan = true;
	        instance.changeCompleted = false;
	        setCallback('changeBegin');
	      }
	      setCallback('change');
	      setAnimationsProgress(insTime);
	    } else {
	      if (instance.changeBegan) {
	        instance.changeCompleted = true;
	        instance.changeBegan = false;
	        setCallback('changeComplete');
	      }
	    }
	    instance.currentTime = minMax(insTime, 0, insDuration);
	    if (instance.began) { setCallback('update'); }
	    if (engineTime >= insDuration) {
	      lastTime = 0;
	      countIteration();
	      if (!instance.remaining) {
	        instance.paused = true;
	        if (!instance.completed) {
	          instance.completed = true;
	          setCallback('loopComplete');
	          setCallback('complete');
	          if (!instance.passThrough && 'Promise' in window) {
	            resolve();
	            makePromise(instance);
	          }
	        }
	      } else {
	        startTime = now;
	        setCallback('loopComplete');
	        instance.loopBegan = false;
	        if (instance.direction === 'alternate') {
	          toggleInstanceDirection();
	        }
	      }
	    }
	  }

	  instance.reset = function() {
	    var direction = instance.direction;
	    instance.passThrough = false;
	    instance.currentTime = 0;
	    instance.progress = 0;
	    instance.paused = true;
	    instance.began = false;
	    instance.loopBegan = false;
	    instance.changeBegan = false;
	    instance.completed = false;
	    instance.changeCompleted = false;
	    instance.reversePlayback = false;
	    instance.reversed = direction === 'reverse';
	    instance.remaining = instance.loop;
	    children = instance.children;
	    childrenLength = children.length;
	    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
	    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
	    setAnimationsProgress(instance.reversed ? instance.duration : 0);
	  };

	  // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)
	  instance._onDocumentVisibility = resetTime;

	  // Set Value helper

	  instance.set = function(targets, properties) {
	    setTargetsValue(targets, properties);
	    return instance;
	  };

	  instance.tick = function(t) {
	    now = t;
	    if (!startTime) { startTime = now; }
	    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
	  };

	  instance.seek = function(time) {
	    setInstanceProgress(adjustTime(time));
	  };

	  instance.pause = function() {
	    instance.paused = true;
	    resetTime();
	  };

	  instance.play = function() {
	    if (!instance.paused) { return; }
	    if (instance.completed) { instance.reset(); }
	    instance.paused = false;
	    activeInstances.push(instance);
	    resetTime();
	    engine();
	  };

	  instance.reverse = function() {
	    toggleInstanceDirection();
	    instance.completed = instance.reversed ? false : true;
	    resetTime();
	  };

	  instance.restart = function() {
	    instance.reset();
	    instance.play();
	  };

	  instance.remove = function(targets) {
	    var targetsArray = parseTargets(targets);
	    removeTargetsFromInstance(targetsArray, instance);
	  };

	  instance.reset();

	  if (instance.autoplay) { instance.play(); }

	  return instance;

	}

	// Remove targets from animation

	function removeTargetsFromAnimations(targetsArray, animations) {
	  for (var a = animations.length; a--;) {
	    if (arrayContains(targetsArray, animations[a].animatable.target)) {
	      animations.splice(a, 1);
	    }
	  }
	}

	function removeTargetsFromInstance(targetsArray, instance) {
	  var animations = instance.animations;
	  var children = instance.children;
	  removeTargetsFromAnimations(targetsArray, animations);
	  for (var c = children.length; c--;) {
	    var child = children[c];
	    var childAnimations = child.animations;
	    removeTargetsFromAnimations(targetsArray, childAnimations);
	    if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
	  }
	  if (!animations.length && !children.length) { instance.pause(); }
	}

	function removeTargetsFromActiveInstances(targets) {
	  var targetsArray = parseTargets(targets);
	  for (var i = activeInstances.length; i--;) {
	    var instance = activeInstances[i];
	    removeTargetsFromInstance(targetsArray, instance);
	  }
	}

	// Stagger helpers

	function stagger(val, params) {
	  if ( params === void 0 ) params = {};

	  var direction = params.direction || 'normal';
	  var easing = params.easing ? parseEasings(params.easing) : null;
	  var grid = params.grid;
	  var axis = params.axis;
	  var fromIndex = params.from || 0;
	  var fromFirst = fromIndex === 'first';
	  var fromCenter = fromIndex === 'center';
	  var fromLast = fromIndex === 'last';
	  var isRange = is.arr(val);
	  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
	  var val2 = isRange ? parseFloat(val[1]) : 0;
	  var unit = getUnit(isRange ? val[1] : val) || 0;
	  var start = params.start || 0 + (isRange ? val1 : 0);
	  var values = [];
	  var maxValue = 0;
	  return function (el, i, t) {
	    if (fromFirst) { fromIndex = 0; }
	    if (fromCenter) { fromIndex = (t - 1) / 2; }
	    if (fromLast) { fromIndex = t - 1; }
	    if (!values.length) {
	      for (var index = 0; index < t; index++) {
	        if (!grid) {
	          values.push(Math.abs(fromIndex - index));
	        } else {
	          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
	          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
	          var toX = index%grid[0];
	          var toY = Math.floor(index/grid[0]);
	          var distanceX = fromX - toX;
	          var distanceY = fromY - toY;
	          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
	          if (axis === 'x') { value = -distanceX; }
	          if (axis === 'y') { value = -distanceY; }
	          values.push(value);
	        }
	        maxValue = Math.max.apply(Math, values);
	      }
	      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
	      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
	    }
	    var spacing = isRange ? (val2 - val1) / maxValue : val1;
	    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
	  }
	}

	// Timeline

	function timeline(params) {
	  if ( params === void 0 ) params = {};

	  var tl = anime(params);
	  tl.duration = 0;
	  tl.add = function(instanceParams, timelineOffset) {
	    var tlIndex = activeInstances.indexOf(tl);
	    var children = tl.children;
	    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
	    function passThrough(ins) { ins.passThrough = true; }
	    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
	    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
	    insParams.targets = insParams.targets || params.targets;
	    var tlDuration = tl.duration;
	    insParams.autoplay = false;
	    insParams.direction = tl.direction;
	    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
	    passThrough(tl);
	    tl.seek(insParams.timelineOffset);
	    var ins = anime(insParams);
	    passThrough(ins);
	    children.push(ins);
	    var timings = getInstanceTimings(children, params);
	    tl.delay = timings.delay;
	    tl.endDelay = timings.endDelay;
	    tl.duration = timings.duration;
	    tl.seek(0);
	    tl.reset();
	    if (tl.autoplay) { tl.play(); }
	    return tl;
	  };
	  return tl;
	}

	anime.version = '3.2.1';
	anime.speed = 1;
	// TODO:#review: naming, documentation
	anime.suspendWhenDocumentHidden = true;
	anime.running = activeInstances;
	anime.remove = removeTargetsFromActiveInstances;
	anime.get = getOriginalTargetValue;
	anime.set = setTargetsValue;
	anime.convertPx = convertPxToUnit;
	anime.path = getPath;
	anime.setDashoffset = setDashoffset;
	anime.stagger = stagger;
	anime.timeline = timeline;
	anime.easing = parseEasings;
	anime.penner = penner;
	anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

	/* compromise 13.10.1 MIT */
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();

	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	//this is a not-well-thought-out way to reduce our dependence on `object===object` stuff
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split(''); //generates a unique id for this term

	function makeId(str) {
	  str = str || '_';
	  var text = str + '-';

	  for (var i = 0; i < 7; i++) {
	    text += chars[Math.floor(Math.random() * chars.length)];
	  }

	  return text;
	}

	var _id = makeId;

	//a hugely-ignorant, and widely subjective transliteration of latin, cryllic, greek unicode characters to english ascii.
	//approximate visual (not semantic or phonetic) relationship between unicode and ascii characters
	//http://en.wikipedia.org/wiki/List_of_Unicode_characters
	//https://docs.google.com/spreadsheet/ccc?key=0Ah46z755j7cVdFRDM1A2YVpwa1ZYWlpJM2pQZ003M0E
	var compact = {
	  '!': '',
	  '?': '',
	  '"': '"',
	  "'": '',
	  '-': '',
	  a: '',
	  b: '',
	  c: '',
	  d: '',
	  e: '',
	  f: '',
	  g: '',
	  h: '',
	  I: '',
	  i: '',
	  j: '',
	  k: '',
	  l: '',
	  m: '',
	  n: '',
	  o: '',
	  p: '',
	  q: '',
	  r: '',
	  s: '',
	  t: '',
	  u: '',
	  v: '',
	  w: '',
	  x: '',
	  y: '',
	  z: ''
	}; //decompress data into two hashes

	var unicode = {};
	Object.keys(compact).forEach(function (k) {
	  compact[k].split('').forEach(function (s) {
	    unicode[s] = k;
	  });
	});

	var killUnicode = function killUnicode(str) {
	  var chars = str.split('');
	  chars.forEach(function (s, i) {
	    if (unicode[s]) {
	      chars[i] = unicode[s];
	    }
	  });
	  return chars.join('');
	};

	var unicode_1 = killUnicode; // console.log(killUnicode('bjk'));

	var periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
	var oneLetterAcronym$1 = /^[A-Z]\.,?$/;
	var noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
	var lowerCaseAcronym = /([a-z]\.){1,}[a-z]\.?$/;

	var isAcronym$2 = function isAcronym(str) {
	  //like N.D.A
	  if (periodAcronym.test(str) === true) {
	    return true;
	  } //like c.e.o


	  if (lowerCaseAcronym.test(str) === true) {
	    return true;
	  } //like 'F.'


	  if (oneLetterAcronym$1.test(str) === true) {
	    return true;
	  } //like NDA


	  if (noPeriodAcronym.test(str) === true) {
	    return true;
	  }

	  return false;
	};

	var isAcronym_1$1 = isAcronym$2;

	var hasSlash$1 = /[a-z\u00C0-\u00FF] ?\/ ?[a-z\u00C0-\u00FF]/;
	/** some basic operations on a string to reduce noise */

	var clean = function clean(str) {
	  str = str || '';
	  str = str.toLowerCase();
	  str = str.trim();
	  var original = str; //(very) rough ASCII transliteration -  bjrk -> bjork

	  str = unicode_1(str); //rough handling of slashes - 'see/saw'

	  if (hasSlash$1.test(str) === true) {
	    str = str.replace(/\/.*/, '');
	  } //#tags, @mentions


	  str = str.replace(/^[#@]/, ''); //punctuation

	  str = str.replace(/[,;.!?]+$/, ''); // coerce single curly quotes

	  str = str.replace(/[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]+/g, "'"); // coerce double curly quotes

	  str = str.replace(/[\u0022\u00AB\u00BB\u201C\u201D\u201E\u201F\u2033\u2034\u2036\u2037\u2E42\u301D\u301E\u301F\uFF02]+/g, '"'); //coerce Unicode ellipses

	  str = str.replace(/\u2026/g, '...'); //en-dash

	  str = str.replace(/\u2013/g, '-'); //lookin'->looking (make it easier for conjugation)

	  str = str.replace(/([aeiou][ktrp])in$/, '$1ing'); //turn re-enactment to reenactment

	  if (/^(re|un)-?[^aeiou]./.test(str) === true) {
	    str = str.replace('-', '');
	  } //compact acronyms


	  if (isAcronym_1$1(str)) {
	    str = str.replace(/\./g, '');
	  } //strip leading & trailing grammatical punctuation


	  if (/^[:;]/.test(str) === false) {
	    str = str.replace(/\.{3,}$/g, '');
	    str = str.replace(/[",\.!:;\?\)]+$/g, '');
	    str = str.replace(/^['"\(]+/g, '');
	  } // remove zero-width characters


	  str = str.replace(/[\u200B-\u200D\uFEFF]/g, ''); //do this again..

	  str = str.trim(); //oh shucks,

	  if (str === '') {
	    str = original;
	  } //nice-numbers


	  str = str.replace(/([0-9]),([0-9])/g, '$1$2');
	  return str;
	};

	var clean_1 = clean; // console.log(normalize('Dr. V Cooper'));

	/** reduced is one step further than clean */
	var reduced = function reduced(str) {
	  // remove apostrophes
	  str = str.replace(/[']s$/, '');
	  str = str.replace(/s[']$/, 's');
	  return str;
	};

	var reduce = reduced;

	//all punctuation marks, from https://en.wikipedia.org/wiki/Punctuation
	//we have slightly different rules for start/end - like #hashtags.

	var startings = /^[ \n\t\.'\[\](){}:,!.\-?;\/&*^%+=~|\u0022|\uFF02|\u0027|\u201C|\u2018|\u201F|\u201B|\u201E|\u2E42|\u201A|\u00AB|\u2039|\u2035|\u2036|\u2037|\u301D|\u0060|\u301F]+/;
	var endings = /[ \n\t\.'\[\](){}:,!.\-?;\/&*@^#+=~|\u0022|\uFF02|\u0027|\u201D|\u2019|\u201D|\u2019|\u201D|\u201D|\u2019|\u00BB|\u203A|\u2032|\u2033|\u2034|\u301E|\u00B4|\u301E]+$/; //money = $

	var hasSlash = /\//;
	var hasApostrophe = /[']/;
	var hasAcronym = /^[a-z]\.([a-z]\.)+/i;
	var minusNumber = /^[-+\.][0-9]/;
	var shortYear = /^'[0-9]{2}/;
	/** turn given text into a parsed-up object
	 * seperate the 'meat' of the word from the whitespace+punctuation
	 */

	var parseTerm = function parseTerm(str) {
	  var original = str;
	  var pre = '';
	  var post = '';
	  str = str.replace(startings, function (found) {
	    pre = found; // support '-40'

	    if ((pre === '-' || pre === '+' || pre === '.') && minusNumber.test(str)) {
	      pre = '';
	      return found;
	    } // support years like '97


	    if (pre === "'" && shortYear.test(str)) {
	      pre = '';
	      return found;
	    }

	    return '';
	  });
	  str = str.replace(endings, function (found) {
	    post = found; // keep s-apostrophe - "flanders'" or "chillin'"

	    if (hasApostrophe.test(found) && /[sn][']$/.test(original) && hasApostrophe.test(pre) === false) {
	      post = post.replace(hasApostrophe, '');
	      return "'";
	    } //keep end-period in acronym


	    if (hasAcronym.test(str) === true) {
	      post = post.replace(/\./, '');
	      return '.';
	    }

	    return '';
	  }); //we went too far..

	  if (str === '') {
	    // do a very mild parse, and hope for the best.
	    original = original.replace(/ *$/, function (after) {
	      post = after || '';
	      return '';
	    });
	    str = original;
	    pre = '';
	    post = post;
	  } // create the various forms of our text,


	  var clean = clean_1(str);
	  var parsed = {
	    text: str,
	    clean: clean,
	    reduced: reduce(clean),
	    pre: pre,
	    post: post
	  }; // support aliases for slashes

	  if (hasSlash.test(str)) {
	    str.split(hasSlash).forEach(function (word) {
	      parsed.alias = parsed.alias || {};
	      parsed.alias[word.trim()] = true;
	    });
	  }

	  return parsed;
	};

	var parse$2 = parseTerm;

	function createCommonjsModule(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	var _01Case = createCommonjsModule(function (module, exports) {
	  var titleCase = /^[A-Z][a-z'\u00C0-\u00FF]/;
	  var upperCase = /^[A-Z]+s?$/;
	  /** convert all text to uppercase */

	  exports.toUpperCase = function () {
	    this.text = this.text.toUpperCase();
	    return this;
	  };
	  /** convert all text to lowercase */


	  exports.toLowerCase = function () {
	    this.text = this.text.toLowerCase();
	    return this;
	  };
	  /** only set the first letter to uppercase
	   * leave any existing uppercase alone
	   */


	  exports.toTitleCase = function () {
	    this.text = this.text.replace(/^ *[a-z\u00C0-\u00FF]/, function (x) {
	      return x.toUpperCase();
	    }); //support unicode?

	    return this;
	  };
	  /** if all letters are uppercase */


	  exports.isUpperCase = function () {
	    return upperCase.test(this.text);
	  };
	  /** if the first letter is uppercase, and the rest are lowercase */


	  exports.isTitleCase = function () {
	    return titleCase.test(this.text);
	  };

	  exports.titleCase = exports.isTitleCase;
	});

	var _02Punctuation$1 = createCommonjsModule(function (module, exports) {
	  // these methods are called with '@hasComma' in the match syntax
	  // various unicode quotation-mark formats
	  var startQuote = /(\u0022|\uFF02|\u0027|\u201C|\u2018|\u201F|\u201B|\u201E|\u2E42|\u201A|\u00AB|\u2039|\u2035|\u2036|\u2037|\u301D|\u0060|\u301F)/;
	  var endQuote = /(\u0022|\uFF02|\u0027|\u201D|\u2019|\u201D|\u2019|\u201D|\u201D|\u2019|\u00BB|\u203A|\u2032|\u2033|\u2034|\u301E|\u00B4|\u301E)/;
	  /** search the term's 'post' punctuation  */

	  exports.hasPost = function (punct) {
	    return this.post.indexOf(punct) !== -1;
	  };
	  /** search the term's 'pre' punctuation  */


	  exports.hasPre = function (punct) {
	    return this.pre.indexOf(punct) !== -1;
	  };
	  /** does it have a quotation symbol?  */


	  exports.hasQuote = function () {
	    return startQuote.test(this.pre) || endQuote.test(this.post);
	  };

	  exports.hasQuotation = exports.hasQuote;
	  /** does it have a comma?  */

	  exports.hasComma = function () {
	    return this.hasPost(',');
	  };
	  /** does it end in a period? */


	  exports.hasPeriod = function () {
	    return this.hasPost('.') === true && this.hasPost('...') === false;
	  };
	  /** does it end in an exclamation */


	  exports.hasExclamation = function () {
	    return this.hasPost('!');
	  };
	  /** does it end with a question mark? */


	  exports.hasQuestionMark = function () {
	    return this.hasPost('?') || this.hasPost('');
	  };
	  /** is there a ... at the end? */


	  exports.hasEllipses = function () {
	    return this.hasPost('..') || this.hasPost('') || this.hasPre('..') || this.hasPre('');
	  };
	  /** is there a semicolon after this word? */


	  exports.hasSemicolon = function () {
	    return this.hasPost(';');
	  };
	  /** is there a slash '/' in this word? */


	  exports.hasSlash = function () {
	    return /\//.test(this.text);
	  };
	  /** a hyphen connects two words like-this */


	  exports.hasHyphen = function () {
	    var hyphen = /^(-||)$/;
	    return hyphen.test(this.post) || hyphen.test(this.pre);
	  };
	  /** a dash separates words - like that */


	  exports.hasDash = function () {
	    var hyphen = / (-||) /;
	    return hyphen.test(this.post) || hyphen.test(this.pre);
	  };
	  /** is it multiple words combinded */


	  exports.hasContraction = function () {
	    return Boolean(this.implicit);
	  };
	  /** try to sensibly put this punctuation mark into the term */


	  exports.addPunctuation = function (punct) {
	    // dont add doubles
	    if (punct === ',' || punct === ';') {
	      this.post = this.post.replace(punct, '');
	    }

	    this.post = punct + this.post;
	    return this;
	  };
	});

	// fuzzy-match (damerau-levenshtein)
	// Based on  tad-lispy /node-damerau-levenshtein
	// https://github.com/tad-lispy/node-damerau-levenshtein/blob/master/index.js
	// count steps (insertions, deletions, substitutions, or transpositions)
	var editDistance = function editDistance(strA, strB) {
	  var aLength = strA.length,
	      bLength = strB.length; // fail-fast

	  if (aLength === 0) {
	    return bLength;
	  }

	  if (bLength === 0) {
	    return aLength;
	  } // If the limit is not defined it will be calculate from this and that args.


	  var limit = (bLength > aLength ? bLength : aLength) + 1;

	  if (Math.abs(aLength - bLength) > (limit || 100)) {
	    return limit || 100;
	  } // init the array


	  var matrix = [];

	  for (var i = 0; i < limit; i++) {
	    matrix[i] = [i];
	    matrix[i].length = limit;
	  }

	  for (var _i = 0; _i < limit; _i++) {
	    matrix[0][_i] = _i;
	  } // Calculate matrix.


	  var j, a_index, b_index, cost, min, t;

	  for (var _i2 = 1; _i2 <= aLength; ++_i2) {
	    a_index = strA[_i2 - 1];

	    for (j = 1; j <= bLength; ++j) {
	      // Check the jagged distance total so far
	      if (_i2 === j && matrix[_i2][j] > 4) {
	        return aLength;
	      }

	      b_index = strB[j - 1];
	      cost = a_index === b_index ? 0 : 1; // Step 5
	      // Calculate the minimum (much faster than Math.min(...)).

	      min = matrix[_i2 - 1][j] + 1; // Deletion.

	      if ((t = matrix[_i2][j - 1] + 1) < min) min = t; // Insertion.

	      if ((t = matrix[_i2 - 1][j - 1] + cost) < min) min = t; // Substitution.
	      // Update matrix.

	      var shouldUpdate = _i2 > 1 && j > 1 && a_index === strB[j - 2] && strA[_i2 - 2] === b_index && (t = matrix[_i2 - 2][j - 2] + cost) < min;

	      if (shouldUpdate) {
	        matrix[_i2][j] = t;
	      } else {
	        matrix[_i2][j] = min;
	      }
	    }
	  } // return number of steps


	  return matrix[aLength][bLength];
	}; // score similarity by from 0-1 (steps/length)


	var fuzzyMatch = function fuzzyMatch(strA, strB) {
	  var minLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;

	  if (strA === strB) {
	    return 1;
	  } //don't even bother on tiny strings


	  if (strA.length < minLength || strB.length < minLength) {
	    return 0;
	  }

	  var steps = editDistance(strA, strB);
	  var length = Math.max(strA.length, strB.length);
	  var relative = length === 0 ? 0 : steps / length;
	  var similarity = 1 - relative;
	  return similarity;
	};

	var _fuzzy = fuzzyMatch; // console.log(fuzzyMatch('test', 'test')) //exact match

	var wrapMatch = function wrapMatch() {};
	/** ignore optional/greedy logic, straight-up term match*/


	var doesMatch = function doesMatch(t, reg, index, length) {
	  // support id matches
	  if (reg.id === t.id) {
	    return true;
	  } // support '.'


	  if (reg.anything === true) {
	    return true;
	  } // support '^' (in parentheses)


	  if (reg.start === true && index !== 0) {
	    return false;
	  } // support '$' (in parentheses)


	  if (reg.end === true && index !== length - 1) {
	    return false;
	  } //support a text match


	  if (reg.word !== undefined) {
	    //match contractions
	    if (t.implicit !== null && t.implicit === reg.word) {
	      return true;
	    } // term aliases for slashes and things


	    if (t.alias !== undefined && t.alias.hasOwnProperty(reg.word)) {
	      return true;
	    } // support ~ match


	    if (reg.soft === true && reg.word === t.root) {
	      return true;
	    } // support fuzzy match param


	    if (reg.fuzzy !== undefined) {
	      var score = _fuzzy(reg.word, t.reduced);

	      if (score > reg.fuzzy) {
	        return true;
	      } // support fuzzy + soft match


	      if (reg.soft === true) {
	        score = _fuzzy(reg.word, t.root);

	        if (score > reg.fuzzy) {
	          return true;
	        }
	      }
	    } //match either .clean or .text


	    return reg.word === t.clean || reg.word === t.text || reg.word === t.reduced;
	  } //support #Tag


	  if (reg.tag !== undefined) {
	    return t.tags[reg.tag] === true;
	  } //support @method


	  if (reg.method !== undefined) {
	    if (typeof t[reg.method] === 'function' && t[reg.method]() === true) {
	      return true;
	    }

	    return false;
	  } //support /reg/


	  if (reg.regex !== undefined) {
	    return reg.regex.test(t.clean);
	  } // support optimized (one|two)


	  if (reg.fastOr !== undefined) {
	    return reg.fastOr.hasOwnProperty(t.reduced) || reg.fastOr.hasOwnProperty(t.text);
	  } //support slower (one|two)


	  if (reg.choices !== undefined) {
	    // try to support && operator
	    if (reg.operator === 'and') {
	      // must match them all
	      return reg.choices.every(function (r) {
	        return wrapMatch(t, r, index, length);
	      });
	    } // or must match one


	    return reg.choices.some(function (r) {
	      return wrapMatch(t, r, index, length);
	    });
	  }

	  return false;
	}; // wrap result for !negative match logic


	wrapMatch = function wrapMatch(t, reg, index, length) {
	  var result = doesMatch(t, reg, index, length);

	  if (reg.negative === true) {
	    return !result;
	  }

	  return result;
	};

	var _doesMatch = wrapMatch;

	var boring = {};
	/** check a match object against this term */

	var doesMatch_1 = function doesMatch_1(reg, index, length) {
	  return _doesMatch(this, reg, index, length);
	};
	/** does this term look like an acronym? */


	var isAcronym_1 = function isAcronym_1() {
	  return isAcronym_1$1(this.text);
	};
	/** is this term implied by a contraction? */


	var isImplicit = function isImplicit() {
	  return this.text === '' && Boolean(this.implicit);
	};
	/** does the term have at least one good tag? */


	var isKnown = function isKnown() {
	  return Object.keys(this.tags).some(function (t) {
	    return boring[t] !== true;
	  });
	};
	/** cache the root property of the term */


	var setRoot = function setRoot(world) {
	  var transform = world.transforms;
	  var str = this.implicit || this.clean;

	  if (this.tags.Plural) {
	    str = transform.toSingular(str, world);
	  }

	  if (this.tags.Verb && !this.tags.Negative && !this.tags.Infinitive) {
	    var tense = null;

	    if (this.tags.PastTense) {
	      tense = 'PastTense';
	    } else if (this.tags.Gerund) {
	      tense = 'Gerund';
	    } else if (this.tags.PresentTense) {
	      tense = 'PresentTense';
	    } else if (this.tags.Participle) {
	      tense = 'Participle';
	    } else if (this.tags.Actor) {
	      tense = 'Actor';
	    }

	    str = transform.toInfinitive(str, world, tense);
	  }

	  this.root = str;
	};

	var _03Misc = {
	  doesMatch: doesMatch_1,
	  isAcronym: isAcronym_1,
	  isImplicit: isImplicit,
	  isKnown: isKnown,
	  setRoot: setRoot
	};

	var hasSpace$1 = /[\s-]/;
	var isUpperCase = /^[A-Z-]+$/; // const titleCase = str => {
	//   return str.charAt(0).toUpperCase() + str.substr(1)
	// }

	/** return various text formats of this term */

	var textOut = function textOut(options, showPre, showPost) {
	  options = options || {};
	  var word = this.text;
	  var before = this.pre;
	  var after = this.post; // -word-

	  if (options.reduced === true) {
	    word = this.reduced || '';
	  }

	  if (options.root === true) {
	    word = this.root || '';
	  }

	  if (options.implicit === true && this.implicit) {
	    word = this.implicit || '';
	  }

	  if (options.normal === true) {
	    word = this.clean || this.text || '';
	  }

	  if (options.root === true) {
	    word = this.root || this.reduced || '';
	  }

	  if (options.unicode === true) {
	    word = unicode_1(word);
	  } // cleanup case


	  if (options.titlecase === true) {
	    if (this.tags.ProperNoun && !this.titleCase()) ; else if (this.tags.Acronym) {
	      word = word.toUpperCase(); //uppercase acronyms
	    } else if (isUpperCase.test(word) && !this.tags.Acronym) {
	      // lowercase everything else
	      word = word.toLowerCase();
	    }
	  }

	  if (options.lowercase === true) {
	    word = word.toLowerCase();
	  } // remove the '.'s from 'F.B.I.' (safely)


	  if (options.acronyms === true && this.tags.Acronym) {
	    word = word.replace(/\./g, '');
	  } // -before/after-


	  if (options.whitespace === true || options.root === true) {
	    before = '';
	    after = ' ';

	    if ((hasSpace$1.test(this.post) === false || options.last) && !this.implicit) {
	      after = '';
	    }
	  }

	  if (options.punctuation === true && !options.root) {
	    //normalized end punctuation
	    if (this.hasPost('.') === true) {
	      after = '.' + after;
	    } else if (this.hasPost('?') === true) {
	      after = '?' + after;
	    } else if (this.hasPost('!') === true) {
	      after = '!' + after;
	    } else if (this.hasPost(',') === true) {
	      after = ',' + after;
	    } else if (this.hasEllipses() === true) {
	      after = '...' + after;
	    }
	  }

	  if (showPre !== true) {
	    before = '';
	  }

	  if (showPost !== true) {
	    // let keep = after.match(/\)/) || ''
	    after = ''; //keep //after.replace(/[ .?!,]+/, '')
	  } // remove the '.' from 'Mrs.' (safely)


	  if (options.abbreviations === true && this.tags.Abbreviation) {
	    after = after.replace(/^\./, '');
	  }

	  return before + word + after;
	};

	var _04Text = {
	  textOut: textOut
	};

	var boringTags = {
	  Auxiliary: 1,
	  Possessive: 1
	};
	/** a subjective ranking of tags kinda tfidf-based */

	var rankTags = function rankTags(term, world) {
	  var tags = Object.keys(term.tags);
	  var tagSet = world.tags;
	  tags = tags.sort(function (a, b) {
	    //bury the tags we dont want
	    if (boringTags[b] || !tagSet[b]) {
	      return -1;
	    } // unknown tags are interesting


	    if (!tagSet[b]) {
	      return 1;
	    }

	    if (!tagSet[a]) {
	      return 0;
	    } // then sort by #of parent tags (most-specific tags first)


	    if (tagSet[a].lineage.length > tagSet[b].lineage.length) {
	      return 1;
	    }

	    if (tagSet[a].isA.length > tagSet[b].isA.length) {
	      return -1;
	    }

	    return 0;
	  });
	  return tags;
	};

	var _bestTag = rankTags;

	var jsonDefault = {
	  text: true,
	  tags: true,
	  implicit: true,
	  whitespace: true,
	  clean: false,
	  id: false,
	  index: false,
	  offset: false,
	  bestTag: false
	};
	/** return various metadata for this term */

	var json$1 = function json(options, world) {
	  options = options || {};
	  options = Object.assign({}, jsonDefault, options);
	  var result = {}; // default on

	  if (options.text) {
	    result.text = this.text;
	  }

	  if (options.normal) {
	    result.normal = this.clean;
	  }

	  if (options.tags) {
	    result.tags = Object.keys(this.tags);
	  } // default off


	  if (options.clean) {
	    result.clean = this.clean;
	  }

	  if (options.id || options.offset) {
	    result.id = this.id;
	  }

	  if (options.implicit && this.implicit !== null) {
	    result.implicit = this.implicit;
	  }

	  if (options.whitespace) {
	    result.pre = this.pre;
	    result.post = this.post;
	  }

	  if (options.bestTag) {
	    result.bestTag = _bestTag(this, world)[0];
	  }

	  return result;
	};

	var _05Json$1 = {
	  json: json$1
	};

	var methods$8 = Object.assign({}, _01Case, _02Punctuation$1, _03Misc, _04Text, _05Json$1);

	function isClientSide() {
	  return typeof window !== 'undefined' && window.document;
	}
	/** add spaces at the end */


	var padEnd = function padEnd(str, width) {
	  str = str.toString();

	  while (str.length < width) {
	    str += ' ';
	  }

	  return str;
	};
	/** output for verbose-mode */


	var logTag = function logTag(t, tag, reason) {
	  if (isClientSide()) {
	    console.log('%c' + padEnd(t.clean, 3) + '  + ' + tag + ' ', 'color: #6accb2;');
	    return;
	  } //server-side


	  var log = '\x1b[33m' + padEnd(t.clean, 15) + '\x1b[0m + \x1b[32m' + tag + '\x1b[0m ';

	  if (reason) {
	    log = padEnd(log, 35) + ' ' + reason + '';
	  }

	  console.log(log);
	};
	/** output for verbose mode  */


	var logUntag = function logUntag(t, tag, reason) {
	  if (isClientSide()) {
	    console.log('%c' + padEnd(t.clean, 3) + '  - ' + tag + ' ', 'color: #AB5850;');
	    return;
	  } //server-side


	  var log = '\x1b[33m' + padEnd(t.clean, 3) + ' \x1b[31m - #' + tag + '\x1b[0m ';

	  if (reason) {
	    log = padEnd(log, 35) + ' ' + reason;
	  }

	  console.log(log);
	};

	var isArray$3 = function isArray(arr) {
	  return Object.prototype.toString.call(arr) === '[object Array]';
	};

	var titleCase$4 = function titleCase(str) {
	  return str.charAt(0).toUpperCase() + str.substr(1);
	};

	var fns$1 = {
	  logTag: logTag,
	  logUntag: logUntag,
	  isArray: isArray$3,
	  titleCase: titleCase$4
	};

	/** add a tag, and its descendents, to a term */

	var addTag = function addTag(t, tag, reason, world) {
	  var tagset = world.tags; //support '.' or '-' notation for skipping the tag

	  if (tag === '' || tag === '.' || tag === '-') {
	    return;
	  }

	  if (tag[0] === '#') {
	    tag = tag.replace(/^#/, '');
	  }

	  tag = fns$1.titleCase(tag); //if we already got this one

	  if (t.tags[tag] === true) {
	    return;
	  } // log it?


	  var isVerbose = world.isVerbose();

	  if (isVerbose === true) {
	    fns$1.logTag(t, tag, reason);
	  } //add tag


	  t.tags[tag] = true; //whee!
	  //check tagset for any additional things to do...

	  if (tagset.hasOwnProperty(tag) === true) {
	    //add parent Tags
	    tagset[tag].isA.forEach(function (down) {
	      t.tags[down] = true;

	      if (isVerbose === true) {
	        fns$1.logTag(t, ' ' + down);
	      }
	    }); //remove any contrary tags

	    t.unTag(tagset[tag].notA, '', world);
	  }
	};
	/** support an array of tags */


	var addTags = function addTags(term, tags, reason, world) {
	  if (typeof tags !== 'string') {
	    for (var i = 0; i < tags.length; i++) {
	      addTag(term, tags[i], reason, world);
	    } // tags.forEach(tag => addTag(term, tag, reason, world))

	  } else {
	    addTag(term, tags, reason, world);
	  }
	};

	var add = addTags;

	var lowerCase = /^[a-z]/;

	var titleCase$3 = function titleCase(str) {
	  return str.charAt(0).toUpperCase() + str.substr(1);
	};
	/** remove this tag, and its descentents from the term */


	var unTag$1 = function unTag(t, tag, reason, world) {
	  var isVerbose = world.isVerbose(); //support '*' for removing all tags

	  if (tag === '*') {
	    t.tags = {};
	    return t;
	  }

	  tag = tag.replace(/^#/, '');

	  if (lowerCase.test(tag) === true) {
	    tag = titleCase$3(tag);
	  } // remove the tag


	  if (t.tags[tag] === true) {
	    delete t.tags[tag]; //log in verbose-mode

	    if (isVerbose === true) {
	      fns$1.logUntag(t, tag, reason);
	    }
	  } //delete downstream tags too


	  var tagset = world.tags;

	  if (tagset[tag]) {
	    var lineage = tagset[tag].lineage;

	    for (var i = 0; i < lineage.length; i++) {
	      if (t.tags[lineage[i]] === true) {
	        delete t.tags[lineage[i]];

	        if (isVerbose === true) {
	          fns$1.logUntag(t, ' - ' + lineage[i]);
	        }
	      }
	    }
	  }

	  return t;
	}; //handle an array of tags


	var untagAll = function untagAll(term, tags, reason, world) {
	  if (typeof tags !== 'string' && tags) {
	    for (var i = 0; i < tags.length; i++) {
	      unTag$1(term, tags[i], reason, world);
	    }

	    return;
	  }

	  unTag$1(term, tags, reason, world);
	};

	var unTag_1$1 = untagAll;

	var canBe$2 = function canBe(term, tag, world) {
	  var tagset = world.tags; // cleanup tag

	  if (tag[0] === '#') {
	    tag = tag.replace(/^#/, '');
	  } //fail-fast


	  if (tagset[tag] === undefined) {
	    return true;
	  } //loop through tag's contradictory tags


	  var enemies = tagset[tag].notA || [];

	  for (var i = 0; i < enemies.length; i++) {
	    if (term.tags[enemies[i]] === true) {
	      return false;
	    }
	  }

	  if (tagset[tag].isA !== undefined) {
	    return canBe(term, tagset[tag].isA, world); //recursive
	  }

	  return true;
	};

	var canBe_1$1 = canBe$2;

	/** add a tag or tags, and their descendents to this term
	 * @param  {string | string[]} tags - a tag or tags
	 * @param {string?} [reason] a clue for debugging
	 */

	var tag_1 = function tag_1(tags, reason, world) {
	  add(this, tags, reason, world);
	  return this;
	};
	/** only tag this term if it's consistent with it's current tags */


	var tagSafe$1 = function tagSafe(tags, reason, world) {
	  if (canBe_1$1(this, tags, world)) {
	    add(this, tags, reason, world);
	  }

	  return this;
	};
	/** remove a tag or tags, and their descendents from this term
	 * @param {string | string[]} tags  - a tag or tags
	 * @param {string?} [reason] a clue for debugging
	 */


	var unTag_1 = function unTag_1(tags, reason, world) {
	  unTag_1$1(this, tags, reason, world);
	  return this;
	};
	/** is this tag consistent with the word's current tags?
	 * @param {string | string[]} tags - a tag or tags
	 * @returns {boolean}
	 */


	var canBe_1 = function canBe_1(tags, world) {
	  return canBe_1$1(this, tags, world);
	};

	var tag$1 = {
	  tag: tag_1,
	  tagSafe: tagSafe$1,
	  unTag: unTag_1,
	  canBe: canBe_1
	};

	var Term = /*#__PURE__*/function () {
	  function Term() {
	    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	    _classCallCheck(this, Term);

	    text = String(text);
	    var obj = parse$2(text); // the various forms of our text

	    this.text = obj.text || '';
	    this.clean = obj.clean;
	    this.reduced = obj.reduced;
	    this.root = null;
	    this.implicit = null;
	    this.pre = obj.pre || '';
	    this.post = obj.post || '';
	    this.tags = {};
	    this.prev = null;
	    this.next = null;
	    this.id = _id(obj.clean);
	    this.isA = 'Term'; // easier than .constructor...
	    // support alternative matches

	    if (obj.alias) {
	      this.alias = obj.alias;
	    }
	  }
	  /** set the text of the Term to something else*/


	  _createClass(Term, [{
	    key: "set",
	    value: function set(str) {
	      var obj = parse$2(str);
	      this.text = obj.text;
	      this.clean = obj.clean;
	      return this;
	    }
	  }]);

	  return Term;
	}();
	/** create a deep-copy of this term */


	Term.prototype.clone = function () {
	  var term = new Term(this.text);
	  term.pre = this.pre;
	  term.post = this.post;
	  term.clean = this.clean;
	  term.reduced = this.reduced;
	  term.root = this.root;
	  term.implicit = this.implicit;
	  term.tags = Object.assign({}, this.tags); //use the old id, so it can be matched with .match(doc)
	  // term.id = this.id

	  return term;
	};

	Object.assign(Term.prototype, methods$8);
	Object.assign(Term.prototype, tag$1);
	var Term_1 = Term;

	/** return a flat array of Term objects */
	var terms = function terms(n) {
	  if (this.length === 0) {
	    return [];
	  } // use cache, if it exists


	  if (this.cache.terms) {
	    if (n !== undefined) {
	      return this.cache.terms[n];
	    }

	    return this.cache.terms;
	  }

	  var terms = [this.pool.get(this.start)];

	  for (var i = 0; i < this.length - 1; i += 1) {
	    var id = terms[terms.length - 1].next;

	    if (id === null) {
	      // throw new Error('linked-list broken')
	      console.error("Compromise error: Linked list broken in phrase '" + this.start + "'");
	      break;
	    }

	    var term = this.pool.get(id);
	    terms.push(term); //return this one?

	    if (n !== undefined && n === i) {
	      return terms[n];
	    }
	  }

	  if (n === undefined) {
	    this.cache.terms = terms;
	  }

	  if (n !== undefined) {
	    return terms[n];
	  }

	  return terms;
	};
	/** return a shallow or deep copy of this phrase  */


	var clone$1 = function clone(isShallow) {
	  var _this = this;

	  if (isShallow) {
	    var p = this.buildFrom(this.start, this.length);
	    p.cache = this.cache;
	    return p;
	  } //how do we clone part of the pool?


	  var terms = this.terms();
	  var newTerms = terms.map(function (t) {
	    return t.clone();
	  }); // console.log(newTerms)
	  //connect these new ids up

	  newTerms.forEach(function (t, i) {
	    //add it to the pool..
	    _this.pool.add(t);

	    if (newTerms[i + 1]) {
	      t.next = newTerms[i + 1].id;
	    }

	    if (newTerms[i - 1]) {
	      t.prev = newTerms[i - 1].id;
	    }
	  });
	  return this.buildFrom(newTerms[0].id, newTerms.length);
	};
	/** return last term object */


	var lastTerm = function lastTerm() {
	  var terms = this.terms();
	  return terms[terms.length - 1];
	};
	/** quick lookup for a term id */


	var hasId = function hasId(wantId) {
	  if (this.length === 0 || !wantId) {
	    return false;
	  }

	  if (this.start === wantId) {
	    return true;
	  } // use cache, if available


	  if (this.cache.terms) {
	    var _terms = this.cache.terms;

	    for (var i = 0; i < _terms.length; i++) {
	      if (_terms[i].id === wantId) {
	        return true;
	      }
	    }

	    return false;
	  } // otherwise, go through each term


	  var lastId = this.start;

	  for (var _i = 0; _i < this.length - 1; _i += 1) {
	    var term = this.pool.get(lastId);

	    if (term === undefined) {
	      console.error("Compromise error: Linked list broken. Missing term '".concat(lastId, "' in phrase '").concat(this.start, "'\n")); // throw new Error('linked List error')

	      return false;
	    }

	    if (term.next === wantId) {
	      return true;
	    }

	    lastId = term.next;
	  }

	  return false;
	};
	/** how many seperate, non-empty words is it? */


	var wordCount = function wordCount() {
	  return this.terms().filter(function (t) {
	    return t.text !== '';
	  }).length;
	};
	/** get the full-sentence this phrase belongs to */


	var fullSentence = function fullSentence() {
	  var t = this.terms(0); //find first term in sentence

	  while (t.prev) {
	    t = this.pool.get(t.prev);
	  }

	  var start = t.id;
	  var len = 1; //go to end of sentence

	  while (t.next) {
	    t = this.pool.get(t.next);
	    len += 1;
	  }

	  return this.buildFrom(start, len);
	};

	var _01Utils$1 = {
	  terms: terms,
	  clone: clone$1,
	  lastTerm: lastTerm,
	  hasId: hasId,
	  wordCount: wordCount,
	  fullSentence: fullSentence
	};

	var trimEnd = function trimEnd(str) {
	  return str.replace(/ +$/, '');
	};
	/** produce output in the given format */


	var text$1 = function text() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var isFirst = arguments.length > 1 ? arguments[1] : undefined;
	  var isLast = arguments.length > 2 ? arguments[2] : undefined;

	  if (typeof options === 'string') {
	    if (options === 'normal') {
	      options = {
	        whitespace: true,
	        unicode: true,
	        lowercase: true,
	        punctuation: true,
	        acronyms: true,
	        abbreviations: true,
	        implicit: true,
	        normal: true
	      };
	    } else if (options === 'clean') {
	      options = {
	        titlecase: false,
	        lowercase: true,
	        punctuation: true,
	        whitespace: true,
	        unicode: true,
	        implicit: true,
	        normal: true
	      };
	    } else if (options === 'reduced') {
	      options = {
	        punctuation: false,
	        //Hmm: is this reversed?
	        titlecase: false,
	        lowercase: true,
	        whitespace: true,
	        unicode: true,
	        implicit: true,
	        reduced: true
	      };
	    } else if (options === 'implicit') {
	      options = {
	        punctuation: true,
	        implicit: true,
	        whitespace: true,
	        trim: true
	      };
	    } else if (options === 'root') {
	      options = {
	        titlecase: false,
	        lowercase: true,
	        punctuation: true,
	        whitespace: true,
	        unicode: true,
	        implicit: true,
	        root: true
	      };
	    } else {
	      options = {};
	    }
	  }

	  var terms = this.terms(); //this this phrase a complete sentence?

	  var isFull = false;

	  if (terms[0] && terms[0].prev === null && terms[terms.length - 1].next === null) {
	    isFull = true;
	  }

	  var text = terms.reduce(function (str, t, i) {
	    // don't output intro space for a contraction-match  i'm good => "[am] good"
	    if (i === 0 && t.text === '' && t.implicit !== null && !options.implicit) {
	      return str;
	    }

	    options.last = isLast && i === terms.length - 1;
	    var showPre = true;
	    var showPost = true;

	    if (isFull === false) {
	      // dont show beginning whitespace
	      if (i === 0 && isFirst) {
	        showPre = false;
	      } // dont show end-whitespace


	      if (i === terms.length - 1 && isLast) {
	        showPost = false;
	      }
	    }

	    var txt = t.textOut(options, showPre, showPost); // console.log(terms)
	    // if (options.titlecase && i === 0) {
	    // txt = titleCase(txt)
	    // }

	    return str + txt;
	  }, ''); //full-phrases show punctuation, but not whitespace

	  if (isFull === true && isLast) {
	    text = trimEnd(text);
	  }

	  if (options.trim === true) {
	    text = text.trim();
	  }

	  return text;
	};

	var _02Text = {
	  text: text$1
	};

	/** remove start and end whitespace */
	var trim = function trim() {
	  var terms = this.terms();

	  if (terms.length > 0) {
	    //trim starting
	    terms[0].pre = terms[0].pre.replace(/^\s+/, ''); //trim ending

	    var lastTerm = terms[terms.length - 1];
	    lastTerm.post = lastTerm.post.replace(/\s+$/, '');
	  }

	  return this;
	};

	var _03Change = {
	  trim: trim
	};

	var endOfSentence = /[.?!]\s*$/; // replacing a 'word.' with a 'word!'

	var combinePost = function combinePost(before, after) {
	  //only transfer the whitespace
	  if (endOfSentence.test(after)) {
	    var whitespace = before.match(/\s*$/);
	    return after + whitespace;
	  }

	  return before;
	}; //add whitespace to the start of the second bit


	var addWhitespace$1 = function addWhitespace(beforeTerms, newTerms) {
	  // add any existing pre-whitespace to beginning
	  newTerms[0].pre = beforeTerms[0].pre;
	  var lastTerm = beforeTerms[beforeTerms.length - 1]; //add any existing punctuation to end of our new terms

	  var newTerm = newTerms[newTerms.length - 1];
	  newTerm.post = combinePost(lastTerm.post, newTerm.post); // remove existing punctuation

	  lastTerm.post = ''; //before [space]  - after

	  if (lastTerm.post === '') {
	    lastTerm.post += ' ';
	  }
	}; //insert this segment into the linked-list


	var stitchIn$1 = function stitchIn(beforeTerms, newTerms, pool) {
	  var lastBefore = beforeTerms[beforeTerms.length - 1];
	  var lastNew = newTerms[newTerms.length - 1];
	  var afterId = lastBefore.next; //connect ours in (main  newPhrase)

	  lastBefore.next = newTerms[0].id; //stich the end in  (newPhrase  after)

	  lastNew.next = afterId; //do it backwards, too

	  if (afterId) {
	    // newPhrase  after
	    var afterTerm = pool.get(afterId);
	    afterTerm.prev = lastNew.id;
	  } // before  newPhrase


	  var beforeId = beforeTerms[0].id;

	  if (beforeId) {
	    var newTerm = newTerms[0];
	    newTerm.prev = beforeId;
	  }
	}; // avoid stretching a phrase twice.


	var unique$5 = function unique(list) {
	  return list.filter(function (o, i) {
	    return list.indexOf(o) === i;
	  });
	}; //append one phrase onto another.


	var appendPhrase = function appendPhrase(before, newPhrase, doc) {
	  var beforeTerms = before.terms();
	  var newTerms = newPhrase.terms(); //spruce-up the whitespace issues

	  addWhitespace$1(beforeTerms, newTerms); //insert this segment into the linked-list

	  stitchIn$1(beforeTerms, newTerms, before.pool); // stretch!
	  // make each effected phrase longer

	  var toStretch = [before];
	  var hasId = before.start;
	  var docs = [doc];
	  docs = docs.concat(doc.parents()); // find them all!

	  docs.forEach(function (parent) {
	    // only the phrases that should change
	    var shouldChange = parent.list.filter(function (p) {
	      return p.hasId(hasId);
	    });
	    toStretch = toStretch.concat(shouldChange);
	  }); // don't double-count a phrase

	  toStretch = unique$5(toStretch);
	  toStretch.forEach(function (p) {
	    p.length += newPhrase.length;
	  });
	  before.cache = {};
	  return before;
	};

	var append = appendPhrase;

	var hasSpace = / /; //a new space needs to be added, either on the new phrase, or the old one
	// '[new] [old]'   -or-   '[old] [new] [old]'

	var addWhitespace = function addWhitespace(newTerms) {
	  //add a space before our new text?
	  // add a space after our text
	  var lastTerm = newTerms[newTerms.length - 1];

	  if (hasSpace.test(lastTerm.post) === false) {
	    lastTerm.post += ' ';
	  }

	  return;
	}; //insert this segment into the linked-list


	var stitchIn = function stitchIn(main, newPhrase, newTerms) {
	  // [newPhrase]  [main]
	  var lastTerm = newTerms[newTerms.length - 1];
	  lastTerm.next = main.start; // [before]  [main]

	  var pool = main.pool;
	  var start = pool.get(main.start);

	  if (start.prev) {
	    var before = pool.get(start.prev);
	    before.next = newPhrase.start;
	  } //do it backwards, too
	  // before  newPhrase


	  newTerms[0].prev = main.terms(0).prev; // newPhrase  main

	  main.terms(0).prev = lastTerm.id;
	};

	var unique$4 = function unique(list) {
	  return list.filter(function (o, i) {
	    return list.indexOf(o) === i;
	  });
	}; //append one phrase onto another


	var joinPhrase = function joinPhrase(original, newPhrase, doc) {
	  var starterId = original.start;
	  var newTerms = newPhrase.terms(); //spruce-up the whitespace issues

	  addWhitespace(newTerms); //insert this segment into the linked-list

	  stitchIn(original, newPhrase, newTerms); //increase the length of our phrases

	  var toStretch = [original];
	  var docs = [doc];
	  docs = docs.concat(doc.parents());
	  docs.forEach(function (d) {
	    // only the phrases that should change
	    var shouldChange = d.list.filter(function (p) {
	      return p.hasId(starterId) || p.hasId(newPhrase.start);
	    });
	    toStretch = toStretch.concat(shouldChange);
	  }); // don't double-count

	  toStretch = unique$4(toStretch); // stretch these phrases

	  toStretch.forEach(function (p) {
	    p.length += newPhrase.length; // change the start too, if necessary

	    if (p.start === starterId) {
	      p.start = newPhrase.start;
	    }

	    p.cache = {};
	  });
	  return original;
	};

	var prepend = joinPhrase;

	//recursively decrease the length of all the parent phrases
	var shrinkAll = function shrinkAll(doc, id, deleteLength, after) {
	  var arr = doc.parents();
	  arr.push(doc);
	  arr.forEach(function (d) {
	    //find our phrase to shrink
	    var phrase = d.list.find(function (p) {
	      return p.hasId(id);
	    });

	    if (!phrase) {
	      return;
	    }

	    phrase.length -= deleteLength; // does it start with this soon-removed word?

	    if (phrase.start === id) {
	      phrase.start = after.id;
	    }

	    phrase.cache = {};
	  }); // cleanup empty phrase objects

	  doc.list = doc.list.filter(function (p) {
	    if (!p.start || !p.length) {
	      return false;
	    }

	    return true;
	  });
	};
	/** wrap the linked-list around these terms
	 * so they don't appear any more
	 */


	var deletePhrase = function deletePhrase(phrase, doc) {
	  var pool = doc.pool();
	  var terms = phrase.terms(); //grab both sides of the chain,

	  var prev = pool.get(terms[0].prev) || {};
	  var after = pool.get(terms[terms.length - 1].next) || {};

	  if (terms[0].implicit && prev.implicit) {
	    prev.set(prev.implicit);
	    prev.post += ' ';
	  } // //first, change phrase lengths


	  shrinkAll(doc, phrase.start, phrase.length, after); // connect [prev]->[after]

	  if (prev) {
	    prev.next = after.id;
	  } // connect [prev]<-[after]


	  if (after) {
	    after.prev = prev.id;
	  } // lastly, actually delete the terms from the pool?
	  // for (let i = 0; i < terms.length; i++) {
	  //   pool.remove(terms[i].id)
	  // }

	};

	var _delete$1 = deletePhrase;

	/** put this text at the end */

	var append_1 = function append_1(newPhrase, doc) {
	  append(this, newPhrase, doc);
	  return this;
	};
	/** add this text to the beginning */


	var prepend_1 = function prepend_1(newPhrase, doc) {
	  prepend(this, newPhrase, doc);
	  return this;
	};

	var _delete = function _delete(doc) {
	  _delete$1(this, doc);
	  return this;
	}; // stich-in newPhrase, stretch 'doc' + parents


	var replace$1 = function replace(newPhrase, doc) {
	  //add it do the end
	  var firstLength = this.length;
	  append(this, newPhrase, doc); //delete original terms

	  var tmp = this.buildFrom(this.start, this.length);
	  tmp.length = firstLength;
	  _delete$1(tmp, doc);
	};
	/**
	 * Turn this phrase object into 3 phrase objects
	 */


	var splitOn = function splitOn(p) {
	  var terms = this.terms();
	  var result = {
	    before: null,
	    match: null,
	    after: null
	  };
	  var index = terms.findIndex(function (t) {
	    return t.id === p.start;
	  });

	  if (index === -1) {
	    return result;
	  } //make all three sections into phrase-objects


	  var start = terms.slice(0, index);

	  if (start.length > 0) {
	    result.before = this.buildFrom(start[0].id, start.length);
	  }

	  var match = terms.slice(index, index + p.length);

	  if (match.length > 0) {
	    result.match = this.buildFrom(match[0].id, match.length);
	  }

	  var end = terms.slice(index + p.length, terms.length);

	  if (end.length > 0) {
	    result.after = this.buildFrom(end[0].id, end.length, this.pool);
	  }

	  return result;
	};

	var _04Insert = {
	  append: append_1,
	  prepend: prepend_1,
	  "delete": _delete,
	  replace: replace$1,
	  splitOn: splitOn
	};

	/** return json metadata for this phrase */
	var json = function json() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var world = arguments.length > 1 ? arguments[1] : undefined;
	  var res = {}; // text data

	  if (options.text) {
	    res.text = this.text();
	  }

	  if (options.normal) {
	    res.normal = this.text('normal');
	  }

	  if (options.clean) {
	    res.clean = this.text('clean');
	  }

	  if (options.reduced) {
	    res.reduced = this.text('reduced');
	  }

	  if (options.implicit) {
	    res.implicit = this.text('implicit');
	  }

	  if (options.root) {
	    res.root = this.text('root');
	  }

	  if (options.trim) {
	    if (res.text) {
	      res.text = res.text.trim();
	    }

	    if (res.normal) {
	      res.normal = res.normal.trim();
	    }

	    if (res.reduced) {
	      res.reduced = res.reduced.trim();
	    }
	  } // terms data


	  if (options.terms) {
	    if (options.terms === true) {
	      options.terms = {};
	    }

	    res.terms = this.terms().map(function (t) {
	      return t.json(options.terms, world);
	    });
	  }

	  return res;
	};

	var _05Json = {
	  json: json
	};

	/** match any terms after this phrase */
	var lookAhead = function lookAhead(regs) {
	  // if empty match string, return everything after
	  if (!regs) {
	    regs = '.*';
	  }

	  var pool = this.pool; // get a list of all terms preceding our start

	  var terms = [];

	  var getAfter = function getAfter(id) {
	    var term = pool.get(id);

	    if (!term) {
	      return;
	    }

	    terms.push(term);

	    if (term.prev) {
	      getAfter(term.next); //recursion
	    }
	  };

	  var all = this.terms();
	  var lastTerm = all[all.length - 1];
	  getAfter(lastTerm.next);

	  if (terms.length === 0) {
	    return [];
	  } // got the terms, make a phrase from them


	  var p = this.buildFrom(terms[0].id, terms.length);
	  return p.match(regs);
	};
	/** match any terms before this phrase */


	var lookBehind = function lookBehind(regs) {
	  // if empty match string, return everything before
	  if (!regs) {
	    regs = '.*';
	  }

	  var pool = this.pool; // get a list of all terms preceding our start

	  var terms = [];

	  var getBefore = function getBefore(id) {
	    var term = pool.get(id);

	    if (!term) {
	      return;
	    }

	    terms.push(term);

	    if (term.prev) {
	      getBefore(term.prev); //recursion
	    }
	  };

	  var term = pool.get(this.start);
	  getBefore(term.prev);

	  if (terms.length === 0) {
	    return [];
	  } // got the terms, make a phrase from them


	  var p = this.buildFrom(terms[terms.length - 1].id, terms.length);
	  return p.match(regs);
	};

	var _06Lookahead = {
	  lookAhead: lookAhead,
	  lookBehind: lookBehind
	};

	var methods$7 = Object.assign({}, _01Utils$1, _02Text, _03Change, _04Insert, _05Json, _06Lookahead);

	// try to avoid doing the match
	var failFast$1 = function failFast(p, regs) {
	  if (regs.length === 0) {
	    return true;
	  }

	  for (var i = 0; i < regs.length; i += 1) {
	    var reg = regs[i]; //logical quick-ones

	    if (reg.optional !== true && reg.negative !== true) {
	      //start/end impossibilites
	      if (reg.start === true && i > 0) {
	        return true;
	      }
	    } //this is not possible


	    if (reg.anything === true && reg.negative === true) {
	      return true;
	    }
	  }

	  return false;
	};

	var _02FailFast = failFast$1;

	var _matchLogic = createCommonjsModule(function (module, exports) {
	  //found a match? it's greedy? keep going!
	  exports.getGreedy = function (state, endReg) {
	    // for greedy checking, we no longer care about the reg.start
	    // value, and leaving it can cause failures for anchored greedy
	    // matches.  ditto for end-greedy matches: we need an earlier non-
	    // ending match to succceed until we get to the actual end.
	    var reg = Object.assign({}, state.regs[state.r], {
	      start: false,
	      end: false
	    });
	    var start = state.t;

	    for (; state.t < state.terms.length; state.t += 1) {
	      //stop for next-reg match
	      if (endReg && state.terms[state.t].doesMatch(endReg, state.start_i + state.t, state.phrase_length)) {
	        return state.t;
	      }

	      var count = state.t - start + 1; // is it max-length now?

	      if (reg.max !== undefined && count === reg.max) {
	        return state.t;
	      } //stop here


	      if (state.terms[state.t].doesMatch(reg, state.start_i + state.t, state.phrase_length) === false) {
	        // is it too short?
	        if (reg.min !== undefined && count < reg.min) {
	          return null;
	        }

	        return state.t;
	      }
	    }

	    return state.t;
	  }; //'unspecific greedy' is a weird situation.


	  exports.greedyTo = function (state, nextReg) {
	    var t = state.t; //if there's no next one, just go off the end!

	    if (!nextReg) {
	      return state.terms.length;
	    } //otherwise, we're looking for the next one


	    for (; t < state.terms.length; t += 1) {
	      if (state.terms[t].doesMatch(nextReg, state.start_i + t, state.phrase_length) === true) {
	        return t;
	      }
	    } //guess it doesn't exist, then.


	    return null;
	  }; //we have a special case where an end-anchored greedy match may need to
	  //start matching before the actual end; we do this by (temporarily!)
	  //removing the "end" property from the matching token... since this is
	  //very situation-specific, we *only* do this when we really need to.


	  exports.isEndGreedy = function (reg, state) {
	    if (reg.end === true && reg.greedy === true) {
	      if (state.start_i + state.t < state.phrase_length - 1) {
	        var tmpReg = Object.assign({}, reg, {
	          end: false
	        });

	        if (state.terms[state.t].doesMatch(tmpReg, state.start_i + state.t, state.phrase_length) === true) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }; // match complex OR cases like (a|b|foo bar)


	  exports.doOrBlock = function (state) {
	    var skipN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var block = state.regs[state.r];
	    var wasFound = false; // do each multiword sequence

	    for (var c = 0; c < block.choices.length; c += 1) {
	      // try to match this list of tokens
	      var regs = block.choices[c];
	      wasFound = regs.every(function (cr, w_index) {
	        var extra = 0;
	        var t = state.t + w_index + skipN + extra;

	        if (state.terms[t] === undefined) {
	          return false;
	        }

	        var foundBlock = state.terms[t].doesMatch(cr, t + state.start_i, state.phrase_length); // this can be greedy - '(foo+ bar)'

	        if (foundBlock === true && cr.greedy === true) {
	          for (var i = 1; i < state.terms.length; i += 1) {
	            var term = state.terms[t + i];

	            if (term) {
	              var keepGoing = term.doesMatch(cr, state.start_i + i, state.phrase_length);

	              if (keepGoing === true) {
	                extra += 1;
	              } else {
	                break;
	              }
	            }
	          }
	        }

	        skipN += extra;
	        return foundBlock;
	      });

	      if (wasFound) {
	        skipN += regs.length;
	        break;
	      }
	    } // we found a match -  is it greedy though?


	    if (wasFound && block.greedy === true) {
	      return exports.doOrBlock(state, skipN); // try it again!
	    }

	    return skipN;
	  }; // match AND cases like (#Noun && foo)


	  exports.doAndBlock = function (state) {
	    var longest = 0; // all blocks must match, and we return the greediest match

	    var reg = state.regs[state.r];
	    var allDidMatch = reg.choices.every(function (block) {
	      //  for multi-word blocks, all must match
	      var allWords = block.every(function (cr, w_index) {
	        var tryTerm = state.t + w_index;

	        if (state.terms[tryTerm] === undefined) {
	          return false;
	        }

	        return state.terms[tryTerm].doesMatch(cr, tryTerm, state.phrase_length);
	      });

	      if (allWords === true && block.length > longest) {
	        longest = block.length;
	      }

	      return allWords;
	    });

	    if (allDidMatch === true) {
	      return longest;
	    }

	    return false;
	  }; // get or create named group


	  exports.getGroup = function (state, term_index, name) {
	    if (state.groups[state.groupId]) {
	      return state.groups[state.groupId];
	    }

	    var termId = state.terms[term_index].id;
	    state.groups[state.groupId] = {
	      group: String(name),
	      start: termId,
	      length: 0
	    };
	    return state.groups[state.groupId];
	  };
	});

	/** tries to match a sequence of terms, starting from here */

	var tryHere = function tryHere(terms, regs, start_i, phrase_length) {
	  // all the variables that matter
	  var state = {
	    t: 0,
	    //the term index we're on
	    terms: terms,
	    //the working slice of term objects
	    r: 0,
	    // the reg index we're on
	    regs: regs,
	    //our match conditions
	    groups: {},
	    //all named-group matches
	    start_i: start_i,
	    // term index we're starting from
	    phrase_length: phrase_length,
	    // # of terms in the sentence
	    hasGroup: false,
	    groupId: null,
	    previousGroup: null
	  }; // we must satisfy each rule in 'regs'

	  for (; state.r < regs.length; state.r += 1) {
	    var reg = regs[state.r]; // Check if this reg has a named capture group

	    state.hasGroup = typeof reg.named === 'string' || typeof reg.named === 'number'; // Reuse previous capture group if same

	    if (state.hasGroup === true) {
	      var prev = regs[state.r - 1];

	      if (prev && prev.named === reg.named && state.previousGroup) {
	        state.groupId = state.previousGroup;
	      } else {
	        state.groupId = _id(reg.named);
	        state.previousGroup = state.groupId;
	      }
	    } //have we run-out of terms?


	    if (!state.terms[state.t]) {
	      //are all remaining regs optional or negative?
	      var haveNeeds = regs.slice(state.r).some(function (remain) {
	        return !remain.optional;
	      });

	      if (haveNeeds === false) {
	        break; //done!
	      }

	      return null; // die
	    } //support 'unspecific greedy' .* properly


	    if (reg.anything === true && reg.greedy === true) {
	      var skipto = _matchLogic.greedyTo(state, regs[state.r + 1]); // ensure it's long enough

	      if (reg.min !== undefined && skipto - state.t < reg.min) {
	        return null;
	      } // reduce it back, if it's too long


	      if (reg.max !== undefined && skipto - state.t > reg.max) {
	        state.t = state.t + reg.max;
	        continue;
	      }

	      if (skipto === null) {
	        return null; //couldn't find it
	      } // is it really this easy?....


	      if (state.hasGroup === true) {
	        var g = _matchLogic.getGroup(state, state.t, reg.named);
	        g.length = skipto - state.t;
	      }

	      state.t = skipto;
	      continue;
	    } // support multi-word OR (a|b|foo bar)


	    if (reg.choices !== undefined && reg.operator === 'or') {
	      var skipNum = _matchLogic.doOrBlock(state);

	      if (skipNum) {
	        // handle 'not' logic
	        if (reg.negative === true) {
	          return null; // die
	        }

	        if (state.hasGroup === true) {
	          var _g = _matchLogic.getGroup(state, state.t, reg.named);

	          _g.length += skipNum;
	        }

	        state.t += skipNum;
	        continue;
	      } else if (!reg.optional) {
	        return null; //die
	      }
	    } // support AND (#Noun && foo) blocks


	    if (reg.choices !== undefined && reg.operator === 'and') {
	      var _skipNum = _matchLogic.doAndBlock(state);

	      if (_skipNum) {
	        // handle 'not' logic
	        if (reg.negative === true) {
	          return null; // die
	        }

	        if (state.hasGroup === true) {
	          var _g2 = _matchLogic.getGroup(state, state.t, reg.named);

	          _g2.length += _skipNum;
	        }

	        state.t += _skipNum;
	        continue;
	      } else if (!reg.optional) {
	        return null; //die
	      }
	    } // ok, finally test the term/reg


	    var term = state.terms[state.t];
	    var doesMatch = term.doesMatch(reg, state.start_i + state.t, state.phrase_length);

	    if (reg.anything === true || doesMatch === true || _matchLogic.isEndGreedy(reg, state)) {
	      var startAt = state.t; // if it's a negative optional match... :0

	      if (reg.optional && regs[state.r + 1] && reg.negative) {
	        continue;
	      } // okay, it was a match, but if it's optional too,
	      // we should check the next reg too, to skip it?


	      if (reg.optional && regs[state.r + 1]) {
	        // does the next reg match it too?
	        var nextRegMatched = term.doesMatch(regs[state.r + 1], state.start_i + state.t, state.phrase_length);

	        if (reg.negative || nextRegMatched) {
	          // but does the next reg match the next term??
	          // only skip if it doesn't
	          var nextTerm = state.terms[state.t + 1];

	          if (!nextTerm || !nextTerm.doesMatch(regs[state.r + 1], state.start_i + state.t, state.phrase_length)) {
	            state.r += 1;
	          }
	        }
	      } //advance to the next term!


	      state.t += 1; //check any ending '$' flags

	      if (reg.end === true) {
	        //if this isn't the last term, refuse the match
	        if (state.t !== state.terms.length && reg.greedy !== true) {
	          return null; //die
	        }
	      } //try keep it going!


	      if (reg.greedy === true) {
	        state.t = _matchLogic.getGreedy(state, regs[state.r + 1]);

	        if (state.t === null) {
	          return null; //greedy was too short
	        }

	        if (reg.min && reg.min > state.t) {
	          return null; //greedy was too short
	        } // if this was also an end-anchor match, check to see we really
	        // reached the end


	        if (reg.end === true && state.start_i + state.t !== phrase_length) {
	          return null; //greedy didn't reach the end
	        }
	      }

	      if (state.hasGroup === true) {
	        // Get or create capture group
	        var _g3 = _matchLogic.getGroup(state, startAt, reg.named); // Update group - add greedy or increment length


	        if (state.t > 1 && reg.greedy) {
	          _g3.length += state.t - startAt;
	        } else {
	          _g3.length++;
	        }
	      }

	      continue;
	    } // ok, it doesn't match.
	    // did it *actually match* a negative?


	    if (reg.negative) {
	      var tmpReg = Object.assign({}, reg);
	      tmpReg.negative = false; // try removing it

	      var foundNeg = state.terms[state.t].doesMatch(tmpReg, state.start_i + state.t, state.phrase_length);

	      if (foundNeg === true) {
	        return null; //bye!
	      }
	    } //bah, who cares, keep going


	    if (reg.optional === true) {
	      continue;
	    } // should we skip-over an implicit word?


	    if (state.terms[state.t].isImplicit() && regs[state.r - 1] && state.terms[state.t + 1]) {
	      // if the last match was implicit too, we're missing a word.
	      if (state.terms[state.t - 1] && state.terms[state.t - 1].implicit === regs[state.r - 1].word) {
	        return null;
	      } // does the next one match?


	      if (state.terms[state.t + 1].doesMatch(reg, state.start_i + state.t, state.phrase_length)) {
	        state.t += 2;
	        continue;
	      }
	    }

	    return null; //die
	  } //return our result


	  return {
	    match: state.terms.slice(0, state.t),
	    groups: state.groups
	  };
	};

	var _03TryMatch = tryHere;

	// final checks on the validity of our results
	var postProcess$1 = function postProcess(terms, regs, matches) {
	  if (!matches || matches.length === 0) {
	    return matches;
	  } // ensure end reg has the end term


	  var atEnd = regs.some(function (r) {
	    return r.end;
	  });

	  if (atEnd) {
	    var lastTerm = terms[terms.length - 1];
	    matches = matches.filter(function (_ref) {
	      var arr = _ref.match;
	      return arr.indexOf(lastTerm) !== -1;
	    });
	  }

	  return matches;
	};

	var _04PostProcess = postProcess$1;

	/* break-down a match expression into this:
	{
	  word:'',
	  tag:'',
	  regex:'',

	  start:false,
	  end:false,
	  negative:false,
	  anything:false,
	  greedy:false,
	  optional:false,

	  named:'',
	  choices:[],
	}
	*/
	var hasMinMax = /\{([0-9]+,?[0-9]*)\}/;
	var andSign = /&&/;
	var captureName = new RegExp(/^<(\S+)>/);

	var titleCase$2 = function titleCase(str) {
	  return str.charAt(0).toUpperCase() + str.substr(1);
	};

	var end = function end(str) {
	  return str[str.length - 1];
	};

	var start = function start(str) {
	  return str[0];
	};

	var stripStart = function stripStart(str) {
	  return str.substr(1);
	};

	var stripEnd = function stripEnd(str) {
	  return str.substr(0, str.length - 1);
	};

	var stripBoth = function stripBoth(str) {
	  str = stripStart(str);
	  str = stripEnd(str);
	  return str;
	}; //


	var parseToken = function parseToken(w) {
	  var obj = {}; //collect any flags (do it twice)

	  for (var i = 0; i < 2; i += 1) {
	    //end-flag
	    if (end(w) === '$') {
	      obj.end = true;
	      w = stripEnd(w);
	    } //front-flag


	    if (start(w) === '^') {
	      obj.start = true;
	      w = stripStart(w);
	    } //capture group (this one can span multiple-terms)


	    if (start(w) === '[' || end(w) === ']') {
	      obj.named = true;

	      if (start(w) === '[') {
	        obj.groupType = end(w) === ']' ? 'single' : 'start';
	      } else {
	        obj.groupType = 'end';
	      }

	      w = w.replace(/^\[/, '');
	      w = w.replace(/\]$/, ''); // Use capture group name

	      if (start(w) === '<') {
	        var res = captureName.exec(w);

	        if (res.length >= 2) {
	          obj.named = res[1];
	          w = w.replace(res[0], '');
	        }
	      }
	    } //back-flags


	    if (end(w) === '+') {
	      obj.greedy = true;
	      w = stripEnd(w);
	    }

	    if (w !== '*' && end(w) === '*' && w !== '\\*') {
	      obj.greedy = true;
	      w = stripEnd(w);
	    }

	    if (end(w) === '?') {
	      obj.optional = true;
	      w = stripEnd(w);
	    }

	    if (start(w) === '!') {
	      obj.negative = true; // obj.optional = true

	      w = stripStart(w);
	    } //wrapped-flags


	    if (start(w) === '(' && end(w) === ')') {
	      // support (one && two)
	      if (andSign.test(w)) {
	        obj.choices = w.split(andSign);
	        obj.operator = 'and';
	      } else {
	        obj.choices = w.split('|');
	        obj.operator = 'or';
	      } //remove '(' and ')'


	      obj.choices[0] = stripStart(obj.choices[0]);
	      var last = obj.choices.length - 1;
	      obj.choices[last] = stripEnd(obj.choices[last]); // clean up the results

	      obj.choices = obj.choices.map(function (s) {
	        return s.trim();
	      });
	      obj.choices = obj.choices.filter(function (s) {
	        return s;
	      }); //recursion alert!

	      obj.choices = obj.choices.map(function (str) {
	        return str.split(/ /g).map(parseToken);
	      });
	      w = '';
	    } //regex


	    if (start(w) === '/' && end(w) === '/') {
	      w = stripBoth(w);
	      obj.regex = new RegExp(w); //potential vuln - security/detect-non-literal-regexp

	      return obj;
	    } //soft-match


	    if (start(w) === '~' && end(w) === '~') {
	      w = stripBoth(w);
	      obj.soft = true;
	      obj.word = w;
	      return obj;
	    }
	  } // support #Tag{1,9}


	  if (hasMinMax.test(w) === true) {
	    w = w.replace(hasMinMax, function (a, b) {
	      var arr = b.split(/,/g);

	      if (arr.length === 1) {
	        // '{3}'	Exactly three times
	        obj.min = Number(arr[0]);
	        obj.max = Number(arr[0]);
	      } else {
	        // '{2,4}' Two to four times
	        // '{3,}' Three or more times
	        obj.min = Number(arr[0]);
	        obj.max = Number(arr[1] || 999);
	      } // use same method as '+'


	      obj.greedy = true; // 0 as min means the same as '?'

	      obj.optional = true;
	      return '';
	    });
	  } //do the actual token content


	  if (start(w) === '#') {
	    obj.tag = stripStart(w);
	    obj.tag = titleCase$2(obj.tag);
	    return obj;
	  } //dynamic function on a term object


	  if (start(w) === '@') {
	    obj.method = stripStart(w);
	    return obj;
	  }

	  if (w === '.') {
	    obj.anything = true;
	    return obj;
	  } //support alone-astrix


	  if (w === '*') {
	    obj.anything = true;
	    obj.greedy = true;
	    obj.optional = true;
	    return obj;
	  }

	  if (w) {
	    //somehow handle encoded-chars?
	    w = w.replace('\\*', '*');
	    w = w.replace('\\.', '.');
	    obj.word = w.toLowerCase();
	  }

	  return obj;
	};

	var _01ParseToken = parseToken;

	// name any [unnamed] capture-groups with a number
	var nameGroups = function nameGroups(tokens) {
	  var convert = false;
	  var index = -1;
	  var current; //'fill in' capture groups between start-end

	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i]; // Give name to un-named single tokens

	    if (token.groupType === 'single' && token.named === true) {
	      index += 1;
	      token.named = index;
	      continue;
	    } // Start converting tokens


	    if (token.groupType === 'start') {
	      convert = true;

	      if (typeof token.named === 'string' || typeof token.named === 'number') {
	        current = token.named;
	      } else {
	        index += 1;
	        current = index;
	      }
	    } // Ensure this token has the right name


	    if (convert) {
	      token.named = current;
	    } // Stop converting tokens


	    if (token.groupType === 'end') {
	      convert = false;
	    }
	  }

	  return tokens;
	}; // optimize an 'or' lookup, when the (a|b|c) list is simple or multi-word


	var doFastOrMode = function doFastOrMode(tokens) {
	  return tokens.map(function (token) {
	    if (token.choices !== undefined) {
	      // are they all straight-up words? then optimize them.
	      var shouldPack = token.choices.every(function (block) {
	        if (block.length !== 1) {
	          return false;
	        }

	        var reg = block[0];

	        if (reg.word !== undefined && reg.negative !== true && reg.optional !== true && reg.method !== true) {
	          return true; //reg is simple-enough
	        }

	        return false;
	      });

	      if (shouldPack === true) {
	        var oneOf = {};
	        token.choices.forEach(function (block) {
	          oneOf[block[0].word] = true;
	        });
	        token.fastOr = oneOf;
	        delete token.choices;
	      }
	    }

	    return token;
	  });
	}; // allow multiword OR (foo|one two)
	// const doMultiWord = function (tokens) {
	//   return tokens.map(token => {
	//     if (token.choices !== undefined) {
	//       let isMulti = token.choices.find(o => hasASpace.test(o.word)) || false
	//       if (isMulti !== false) {
	//         token.multiword = true
	//         // turn all choices into arrays
	//         token.choices = token.choices.map(choice => {
	//           if (choice.word) {
	//             choice.sequence = choice.word.split(hasASpace)
	//             delete choice.word
	//           }
	//           return choice
	//         })
	//       }
	//     }
	//     return token
	//   })
	// }
	// const doBlockMode = function (tokens) {
	//   return tokens.map(token => {
	//     // we've already setup fastOr mode
	//     if (token.choices !== undefined) {
	//       // console.log(token)
	//     }
	//     return token
	//   })
	// }


	var postProcess = function postProcess(tokens) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  // ensure all capture groups are filled between start and end
	  // give all capture groups names
	  var count = tokens.filter(function (t) {
	    return t.groupType;
	  }).length;

	  if (count > 0) {
	    tokens = nameGroups(tokens);
	  } // convert 'choices' format to 'fastOr' format


	  if (!opts.fuzzy) {
	    tokens = doFastOrMode(tokens);
	  } // support multiword OR (foo bar|baz)
	  // tokens = doMultiWord(tokens)
	  // support (one two three)
	  // tokens = doBlockMode(tokens)


	  return tokens;
	};

	var _02PostProcess = postProcess;

	var hasReg = /[^[a-z]]\//g;

	var isArray$2 = function isArray(arr) {
	  return Object.prototype.toString.call(arr) === '[object Array]';
	}; // don't split up a regular expression


	var mergeRegexes = function mergeRegexes(arr) {
	  arr.forEach(function (s, i) {
	    var m = s.match(hasReg); // has 1 slash

	    if (m !== null && m.length === 1 && arr[i + 1]) {
	      // merge next one
	      arr[i] += arr[i + 1];
	      arr[i + 1] = ''; // try 2nd one

	      m = arr[i].match(hasReg);

	      if (m !== null && m.length === 1) {
	        arr[i] += arr[i + 2];
	        arr[i + 2] = '';
	      }
	    }
	  });
	  arr = arr.filter(function (s) {
	    return s;
	  });
	  return arr;
	}; //split-up by (these things)


	var byParentheses = function byParentheses(str) {
	  var arr = str.split(/([\^\[\!]*(?:<\S+>)?\(.*?\)[?+*]*\]?\$?)/);
	  arr = arr.map(function (s) {
	    return s.trim();
	  });

	  if (hasReg.test(str)) {
	    arr = mergeRegexes(arr);
	  }

	  return arr;
	};

	var byWords = function byWords(arr) {
	  var words = [];
	  arr.forEach(function (a) {
	    //keep brackets lumped together
	    if (/\(.*\)/.test(a)) {
	      words.push(a);
	      return;
	    }

	    var list = a.split(' ');
	    list = list.filter(function (w) {
	      return w;
	    });
	    words = words.concat(list);
	  });
	  return words;
	}; //turn an array into a 'choices' list


	var byArray = function byArray(arr) {
	  var blocks = arr.map(function (s) {
	    return [{
	      word: s
	    }];
	  });
	  return [{
	    choices: blocks,
	    operator: 'or'
	  }];
	}; // turn a Doc object into a reg of ids to lookup


	var fromDoc = function fromDoc(doc) {
	  if (!doc || !doc.list || !doc.list[0]) {
	    return [];
	  }

	  var regs = [];
	  doc.list.forEach(function (p) {
	    var ids = [];
	    p.terms().forEach(function (t) {
	      ids.push(t.id);
	    });
	    regs.push(ids);
	  });
	  return [{
	    idBlocks: regs
	  }];
	}; // add fuzziness etc to each reg


	var addOptions = function addOptions(tokens, opts) {
	  // add default fuzzy-search limit
	  if (opts.fuzzy === true) {
	    opts.fuzzy = 0.85;
	  }

	  if (typeof opts.fuzzy === 'number') {
	    tokens = tokens.map(function (reg) {
	      // add a fuzzy-match on 'word' tokens
	      if (opts.fuzzy > 0 && reg.word) {
	        reg.fuzzy = opts.fuzzy;
	      } //add it to or|and choices too


	      if (reg.choices) {
	        reg.choices.forEach(function (block) {
	          block.forEach(function (r) {
	            r.fuzzy = opts.fuzzy;
	          });
	        });
	      }

	      return reg;
	    });
	  }

	  return tokens;
	};
	/** parse a match-syntax string into json */


	var syntax = function syntax(input) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  // fail-fast
	  if (input === null || input === undefined || input === '') {
	    return [];
	  } //try to support a ton of different formats:


	  if (_typeof(input) === 'object') {
	    if (isArray$2(input)) {
	      if (input.length === 0 || !input[0]) {
	        return [];
	      } //is it a pre-parsed reg-list?


	      if (_typeof(input[0]) === 'object') {
	        return input;
	      } //support a flat array of normalized words


	      if (typeof input[0] === 'string') {
	        return byArray(input);
	      }
	    } //support passing-in a compromise object as a match


	    if (input && input.isA === 'Doc') {
	      return fromDoc(input);
	    }

	    return [];
	  }

	  if (typeof input === 'number') {
	    input = String(input); //go for it?
	  }

	  var tokens = byParentheses(input); // console.log(tokens)

	  tokens = byWords(tokens);
	  tokens = tokens.map(function (str) {
	    return _01ParseToken(str);
	  }); //clean up anything weird

	  tokens = _02PostProcess(tokens, opts); // add fuzzy limits, etc

	  tokens = addOptions(tokens, opts); // console.log(tokens)

	  return tokens;
	};

	var matchSyntax = syntax; // console.log(syntax('before [(united states|canadian)] after'))

	// match an explicit sequence of term ids
	// take a phrase and find any of the idBlocks in it
	var idLookup = function idLookup(terms, regs) {
	  var matches = [];
	  var blocklist = regs[0].idBlocks;

	  var _loop = function _loop(_t) {
	    blocklist.forEach(function (block) {
	      if (block.length === 0) {
	        t = _t;
	        return;
	      }

	      var foundAll = block.every(function (id, i) {
	        t = _t;
	        return terms[_t + i].id === id;
	      });

	      if (foundAll) {
	        matches.push({
	          match: terms.slice(_t, _t + block.length)
	        }); //  skip top-loop forward

	        _t += block.length - 1;
	      }
	    });
	    t = _t;
	  };

	  for (var t = 0; t < terms.length; t += 1) {
	    _loop(t);
	  }

	  return matches;
	};

	var idLookup_1 = idLookup;

	/**  returns a simple array of arrays */

	var matchAll = function matchAll(p, regs) {
	  var matchOne = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  //if we forgot to parse it..
	  if (typeof regs === 'string') {
	    regs = matchSyntax(regs);
	  } //try to dismiss it, at-once


	  if (_02FailFast(p, regs) === true) {
	    return [];
	  } //any match needs to be this long, at least


	  var minLength = regs.filter(function (r) {
	    return r.optional !== true && r.negative !== true;
	  }).length;
	  var terms = p.terms();
	  var matches = []; // these id-lookups can be super-fast

	  if (regs[0].idBlocks) {
	    var res = idLookup_1(terms, regs);

	    if (res && res.length > 0) {
	      return _04PostProcess(terms, regs, res);
	    }
	  } //optimisation for '^' start logic


	  if (regs[0].start === true) {
	    var _res = _03TryMatch(terms, regs, 0, terms.length);

	    if (_res && _res.match && _res.match.length > 0) {
	      _res.match = _res.match.filter(function (m) {
	        return m;
	      });
	      matches.push(_res);
	    }

	    return _04PostProcess(terms, regs, matches);
	  } //try starting, from every term


	  for (var i = 0; i < terms.length; i += 1) {
	    // slice may be too short
	    if (i + minLength > terms.length) {
	      break;
	    } //try it!


	    var _res2 = _03TryMatch(terms.slice(i), regs, i, terms.length);

	    if (_res2 && _res2.match && _res2.match.length > 0) {
	      //zoom forward!
	      i += _res2.match.length - 1; //[capture-groups] return some null responses

	      _res2.match = _res2.match.filter(function (m) {
	        return m;
	      });
	      matches.push(_res2); //ok, maybe that's enough?

	      if (matchOne === true) {
	        return _04PostProcess(terms, regs, matches);
	      }
	    }
	  }

	  return _04PostProcess(terms, regs, matches);
	};

	var _01MatchAll = matchAll;

	/** return anything that doesn't match.
	 * returns a simple array of arrays
	 */

	var notMatch = function notMatch(p, regs) {
	  var found = {};
	  var arr = _01MatchAll(p, regs);
	  arr.forEach(function (_ref) {
	    var ts = _ref.match;
	    ts.forEach(function (t) {
	      found[t.id] = true;
	    });
	  }); //return anything not found

	  var terms = p.terms();
	  var result = [];
	  var current = [];
	  terms.forEach(function (t) {
	    if (found[t.id] === true) {
	      if (current.length > 0) {
	        result.push(current);
	        current = [];
	      }

	      return;
	    }

	    current.push(t);
	  });

	  if (current.length > 0) {
	    result.push(current);
	  }

	  return result;
	};

	var not$1 = notMatch;

	/** return an array of matching phrases */

	var match_1 = function match_1(regs) {
	  var _this = this;

	  var justOne = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var matches = _01MatchAll(this, regs, justOne); //make them phrase objects

	  matches = matches.map(function (_ref) {
	    var match = _ref.match,
	        groups = _ref.groups;

	    var p = _this.buildFrom(match[0].id, match.length, groups);

	    p.cache.terms = match;
	    return p;
	  });
	  return matches;
	};
	/** return boolean if one match is found */


	var has = function has(regs) {
	  var matches = _01MatchAll(this, regs, true);
	  return matches.length > 0;
	};
	/** remove all matches from the result */


	var not = function not(regs) {
	  var _this2 = this;

	  var matches = not$1(this, regs); //make them phrase objects

	  matches = matches.map(function (list) {
	    return _this2.buildFrom(list[0].id, list.length);
	  });
	  return matches;
	};
	/** return a list of phrases that can have this tag */


	var canBe$1 = function canBe(tag, world) {
	  var _this3 = this;

	  var results = [];
	  var terms = this.terms();
	  var previous = false;

	  for (var i = 0; i < terms.length; i += 1) {
	    var can = terms[i].canBe(tag, world);

	    if (can === true) {
	      if (previous === true) {
	        //add it to the end
	        results[results.length - 1].push(terms[i]);
	      } else {
	        results.push([terms[i]]); //make a new one
	      }

	      previous = can;
	    }
	  } //turn them into Phrase objects


	  results = results.filter(function (a) {
	    return a.length > 0;
	  }).map(function (arr) {
	    return _this3.buildFrom(arr[0].id, arr.length);
	  });
	  return results;
	};

	var match = {
	  match: match_1,
	  has: has,
	  not: not,
	  canBe: canBe$1
	};

	var Phrase = function Phrase(id, length, pool) {
	  _classCallCheck(this, Phrase);

	  this.start = id;
	  this.length = length;
	  this.isA = 'Phrase'; // easier than .constructor...

	  Object.defineProperty(this, 'pool', {
	    enumerable: false,
	    writable: true,
	    value: pool
	  });
	  Object.defineProperty(this, 'cache', {
	    enumerable: false,
	    writable: true,
	    value: {}
	  });
	  Object.defineProperty(this, 'groups', {
	    enumerable: false,
	    writable: true,
	    value: {}
	  });
	};
	/** create a new Phrase object from an id and length */


	Phrase.prototype.buildFrom = function (id, length, groups) {
	  var p = new Phrase(id, length, this.pool); //copy-over or replace capture-groups too

	  if (groups && Object.keys(groups).length > 0) {
	    p.groups = groups;
	  } else {
	    p.groups = this.groups;
	  }

	  return p;
	}; //apply methods


	Object.assign(Phrase.prototype, match);
	Object.assign(Phrase.prototype, methods$7); //apply aliases

	var aliases$1 = {
	  term: 'terms'
	};
	Object.keys(aliases$1).forEach(function (k) {
	  return Phrase.prototype[k] = Phrase.prototype[aliases$1[k]];
	});
	var Phrase_1 = Phrase;

	/** a key-value store of all terms in our Document */
	var Pool = /*#__PURE__*/function () {
	  function Pool() {
	    var words = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Pool);

	    //quiet this property in console.logs
	    Object.defineProperty(this, 'words', {
	      enumerable: false,
	      value: words
	    });
	  }
	  /** throw a new term object in */


	  _createClass(Pool, [{
	    key: "add",
	    value: function add(term) {
	      this.words[term.id] = term;
	      return this;
	    }
	    /** find a term by it's id */

	  }, {
	    key: "get",
	    value: function get(id) {
	      return this.words[id];
	    }
	    /** find a term by it's id */

	  }, {
	    key: "remove",
	    value: function remove(id) {
	      delete this.words[id];
	    }
	  }, {
	    key: "merge",
	    value: function merge(pool) {
	      Object.assign(this.words, pool.words);
	      return this;
	    }
	    /** helper method */

	  }, {
	    key: "stats",
	    value: function stats() {
	      return {
	        words: Object.keys(this.words).length
	      };
	    }
	  }]);

	  return Pool;
	}();
	/** make a deep-copy of all terms */


	Pool.prototype.clone = function () {
	  var _this = this;

	  var keys = Object.keys(this.words);
	  var words = keys.reduce(function (h, k) {
	    var t = _this.words[k].clone();

	    h[t.id] = t;
	    return h;
	  }, {});
	  return new Pool(words);
	};

	var Pool_1 = Pool;

	//add forward/backward 'linked-list' prev/next ids
	var linkTerms = function linkTerms(terms) {
	  terms.forEach(function (term, i) {
	    if (i > 0) {
	      term.prev = terms[i - 1].id;
	    }

	    if (terms[i + 1]) {
	      term.next = terms[i + 1].id;
	    }
	  });
	};

	var _linkTerms = linkTerms;

	//(Rule-based sentence boundary segmentation) - chop given text into its proper sentences.
	// Ignore periods/questions/exclamations used in acronyms/abbreviations/numbers, etc.
	// @spencermountain 2017 MIT
	//proper nouns with exclamation marks
	// const blacklist = {
	//   yahoo: true,
	//   joomla: true,
	//   jeopardy: true,
	// }
	//regs-
	var initSplit = /(\S.+?[.!?\u203D\u2E18\u203C\u2047-\u2049])(?=\s+|$)/g;
	var hasSomething = /\S/;
	var isAcronym$1 = /[ .][A-Z]\.? *$/i;
	var hasEllipse = /(?:\u2026|\.{2,}) *$/;
	var newLine = /((?:\r?\n|\r)+)/; // Match different new-line formats

	var hasLetter = /[a-z0-9\u00C0-\u00FF\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff]/i;
	var startWhitespace = /^\s+/; // Start with a regex:

	var naiive_split = function naiive_split(text) {
	  var all = []; //first, split by newline

	  var lines = text.split(newLine);

	  for (var i = 0; i < lines.length; i++) {
	    //split by period, question-mark, and exclamation-mark
	    var arr = lines[i].split(initSplit);

	    for (var o = 0; o < arr.length; o++) {
	      all.push(arr[o]);
	    }
	  }

	  return all;
	};
	/** does this look like a sentence? */


	var isSentence = function isSentence(str, abbrevs) {
	  // check for 'F.B.I.'
	  if (isAcronym$1.test(str) === true) {
	    return false;
	  } //check for '...'


	  if (hasEllipse.test(str) === true) {
	    return false;
	  } // must have a letter


	  if (hasLetter.test(str) === false) {
	    return false;
	  }

	  var txt = str.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, '');
	  var words = txt.split(' ');
	  var lastWord = words[words.length - 1].toLowerCase(); // check for 'Mr.'

	  if (abbrevs.hasOwnProperty(lastWord)) {
	    return false;
	  } // //check for jeopardy!
	  // if (blacklist.hasOwnProperty(lastWord)) {
	  //   return false
	  // }


	  return true;
	};

	var splitSentences = function splitSentences(text, world) {
	  var abbrevs = world.cache.abbreviations;
	  text = text || '';
	  text = String(text);
	  var sentences = []; // First do a greedy-split..

	  var chunks = []; // Ensure it 'smells like' a sentence

	  if (!text || typeof text !== 'string' || hasSomething.test(text) === false) {
	    return sentences;
	  } // cleanup unicode-spaces


	  text = text.replace('\xa0', ' '); // Start somewhere:

	  var splits = naiive_split(text); // Filter-out the crap ones

	  for (var i = 0; i < splits.length; i++) {
	    var s = splits[i];

	    if (s === undefined || s === '') {
	      continue;
	    } //this is meaningful whitespace


	    if (hasSomething.test(s) === false) {
	      //add it to the last one
	      if (chunks[chunks.length - 1]) {
	        chunks[chunks.length - 1] += s;
	        continue;
	      } else if (splits[i + 1]) {
	        //add it to the next one
	        splits[i + 1] = s + splits[i + 1];
	        continue;
	      }
	    } //else, only whitespace, no terms, no sentence


	    chunks.push(s);
	  } //detection of non-sentence chunks:
	  //loop through these chunks, and join the non-sentence chunks back together..


	  for (var _i = 0; _i < chunks.length; _i++) {
	    var c = chunks[_i]; //should this chunk be combined with the next one?

	    if (chunks[_i + 1] && isSentence(c, abbrevs) === false) {
	      chunks[_i + 1] = c + (chunks[_i + 1] || '');
	    } else if (c && c.length > 0) {
	      //&& hasLetter.test(c)
	      //this chunk is a proper sentence..
	      sentences.push(c);
	      chunks[_i] = '';
	    }
	  } //if we never got a sentence, return the given text


	  if (sentences.length === 0) {
	    return [text];
	  } //move whitespace to the ends of sentences, when possible
	  //['hello',' world'] -> ['hello ','world']


	  for (var _i2 = 1; _i2 < sentences.length; _i2 += 1) {
	    var ws = sentences[_i2].match(startWhitespace);

	    if (ws !== null) {
	      sentences[_i2 - 1] += ws[0];
	      sentences[_i2] = sentences[_i2].replace(startWhitespace, '');
	    }
	  }

	  return sentences;
	};

	var _01Sentences = splitSentences; // console.log(sentence_parser('john f. kennedy'));

	var wordlike = /\S/;
	var isBoundary = /^[!?.]+$/;
	var naiiveSplit = /(\S+)/;
	var isSlash = /[a-z] ?\/ ?[a-z]*$/;
	var notWord = ['.', '?', '!', ':', ';', '-', '', '', '--', '...', '(', ')', '[', ']', '"', "'", '`'];
	notWord = notWord.reduce(function (h, c) {
	  h[c] = true;
	  return h;
	}, {});

	var hasHyphen = function hasHyphen(str) {
	  //dont split 're-do'
	  if (/^(re|un)-?[^aeiou]./.test(str) === true) {
	    return false;
	  } //letter-number 'aug-20'


	  var reg = /^([a-z\u00C0-\u00FF`"'/]+)(-||)([a-z0-9\u00C0-\u00FF].*)/i;

	  if (reg.test(str) === true) {
	    return true;
	  } //number-letter '20-aug'


	  var reg2 = /^([0-9]{1,4})(-||)([a-z\u00C0-\u00FF`"'/-]+$)/i;

	  if (reg2.test(str) === true) {
	    return true;
	  } //support weird number-emdash combo '20102011'
	  // let reg2 = /^([0-9]+)(|)([0-9].*)/i
	  // if (reg2.test(str)) {
	  //   return true
	  // }


	  return false;
	}; // 'he / she' should be one word


	var combineSlashes = function combineSlashes(arr) {
	  for (var i = 1; i < arr.length - 1; i++) {
	    if (isSlash.test(arr[i])) {
	      arr[i - 1] += arr[i] + arr[i + 1];
	      arr[i] = null;
	      arr[i + 1] = null;
	    }
	  }

	  return arr;
	};

	var splitHyphens = function splitHyphens(word) {
	  var arr = []; //support multiple-hyphenated-terms

	  var hyphens = word.split(/[-]/);
	  var whichDash = '-';
	  var found = word.match(/[-]/);

	  if (found && found[0]) {
	    whichDash = found;
	  }

	  for (var o = 0; o < hyphens.length; o++) {
	    if (o === hyphens.length - 1) {
	      arr.push(hyphens[o]);
	    } else {
	      arr.push(hyphens[o] + whichDash);
	    }
	  }

	  return arr;
	};

	var isArray$1 = function isArray(arr) {
	  return Object.prototype.toString.call(arr) === '[object Array]';
	}; //turn a string into an array of strings (naiive for now, lumped later)


	var splitWords = function splitWords(str) {
	  var result = [];
	  var arr = []; //start with a naiive split

	  str = str || '';

	  if (typeof str === 'number') {
	    str = String(str);
	  }

	  if (isArray$1(str)) {
	    return str;
	  }

	  var words = str.split(naiiveSplit);

	  for (var i = 0; i < words.length; i++) {
	    //split 'one-two'
	    if (hasHyphen(words[i]) === true) {
	      arr = arr.concat(splitHyphens(words[i]));
	      continue;
	    }

	    arr.push(words[i]);
	  } //greedy merge whitespace+arr to the right


	  var carry = '';

	  for (var _i = 0; _i < arr.length; _i++) {
	    var word = arr[_i]; //if it's more than a whitespace

	    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {
	      //put whitespace on end of previous term, if possible
	      if (result.length > 0) {
	        result[result.length - 1] += carry;
	        result.push(word);
	      } else {
	        //otherwise, but whitespace before
	        result.push(carry + word);
	      }

	      carry = '';
	    } else {
	      carry += word;
	    }
	  } //handle last one


	  if (carry) {
	    if (result.length === 0) {
	      result[0] = '';
	    }

	    result[result.length - 1] += carry; //put it on the end
	  } // combine 'one / two'


	  result = combineSlashes(result); // remove empty results

	  result = result.filter(function (s) {
	    return s;
	  });
	  return result;
	};

	var _02Words = splitWords;

	var isArray = function isArray(arr) {
	  return Object.prototype.toString.call(arr) === '[object Array]';
	};
	/** turn a string into an array of Phrase objects */


	var fromText = function fromText() {
	  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var world = arguments.length > 1 ? arguments[1] : undefined;
	  var pool = arguments.length > 2 ? arguments[2] : undefined;
	  var sentences = null; //a bit of validation, first

	  if (typeof text !== 'string') {
	    if (typeof text === 'number') {
	      text = String(text);
	    } else if (isArray(text)) {
	      sentences = text;
	    }
	  } //tokenize into words


	  sentences = sentences || _01Sentences(text, world);
	  sentences = sentences.map(function (str) {
	    return _02Words(str);
	  }); //turn them into proper objects

	  pool = pool || new Pool_1();
	  var phrases = sentences.map(function (terms) {
	    terms = terms.map(function (str) {
	      var term = new Term_1(str);
	      pool.add(term);
	      return term;
	    }); //add next/previous ids

	    _linkTerms(terms); //return phrase objects

	    var p = new Phrase_1(terms[0].id, terms.length, pool);
	    p.cache.terms = terms;
	    return p;
	  }); //return them ready for a Document object

	  return phrases;
	};

	var _01Tokenizer = fromText;

	var fromJSON = function fromJSON(json, world) {
	  var pool = new Pool_1();
	  var phrases = json.map(function (p, k) {
	    var terms = p.terms.map(function (o, i) {
	      var term = new Term_1(o.text);
	      term.pre = o.pre !== undefined ? o.pre : '';

	      if (o.post === undefined) {
	        o.post = ' '; //no given space for very last term

	        if (i >= p.terms.length - 1) {
	          o.post = '. ';

	          if (k >= p.terms.length - 1) {
	            o.post = '.';
	          }
	        }
	      }

	      term.post = o.post !== undefined ? o.post : ' ';

	      if (o.tags) {
	        o.tags.forEach(function (tag) {
	          return term.tag(tag, '', world);
	        });
	      }

	      pool.add(term);
	      return term;
	    }); //add prev/next links

	    _linkTerms(terms); // return a proper Phrase object

	    return new Phrase_1(terms[0].id, terms.length, pool);
	  });
	  return phrases;
	};

	var fromJSON_1 = fromJSON;

	var _version = '13.10.1';

	var entity = ['Person', 'Place', 'Organization'];
	var nouns$1 = {
	  Noun: {
	    notA: ['Verb', 'Adjective', 'Adverb']
	  },
	  // - singular
	  Singular: {
	    isA: 'Noun',
	    notA: 'Plural'
	  },
	  //a specific thing that's capitalized
	  ProperNoun: {
	    isA: 'Noun'
	  },
	  // -- people
	  Person: {
	    isA: ['ProperNoun', 'Singular'],
	    notA: ['Place', 'Organization', 'Date']
	  },
	  FirstName: {
	    isA: 'Person'
	  },
	  MaleName: {
	    isA: 'FirstName',
	    notA: ['FemaleName', 'LastName']
	  },
	  FemaleName: {
	    isA: 'FirstName',
	    notA: ['MaleName', 'LastName']
	  },
	  LastName: {
	    isA: 'Person',
	    notA: ['FirstName']
	  },
	  NickName: {
	    isA: 'Person',
	    notA: ['FirstName', 'LastName']
	  },
	  Honorific: {
	    isA: 'Noun',
	    notA: ['FirstName', 'LastName', 'Value']
	  },
	  // -- places
	  Place: {
	    isA: 'Singular',
	    notA: ['Person', 'Organization']
	  },
	  Country: {
	    isA: ['Place', 'ProperNoun'],
	    notA: ['City']
	  },
	  City: {
	    isA: ['Place', 'ProperNoun'],
	    notA: ['Country']
	  },
	  Region: {
	    isA: ['Place', 'ProperNoun']
	  },
	  Address: {
	    isA: 'Place'
	  },
	  //---Orgs---
	  Organization: {
	    isA: ['Singular', 'ProperNoun'],
	    notA: ['Person', 'Place']
	  },
	  SportsTeam: {
	    isA: 'Organization'
	  },
	  School: {
	    isA: 'Organization'
	  },
	  Company: {
	    isA: 'Organization'
	  },
	  // - plural
	  Plural: {
	    isA: 'Noun',
	    notA: ['Singular']
	  },
	  //(not plural or singular)
	  Uncountable: {
	    isA: 'Noun'
	  },
	  Pronoun: {
	    isA: 'Noun',
	    notA: entity
	  },
	  //a word for someone doing something -'plumber'
	  Actor: {
	    isA: 'Noun',
	    notA: entity
	  },
	  //a gerund-as-noun - 'swimming'
	  Activity: {
	    isA: 'Noun',
	    notA: ['Person', 'Place']
	  },
	  //'kilograms'
	  Unit: {
	    isA: 'Noun',
	    notA: entity
	  },
	  //'Canadians'
	  Demonym: {
	    isA: ['Noun', 'ProperNoun'],
	    notA: entity
	  },
	  //`john's`
	  Possessive: {
	    isA: 'Noun' // notA: 'Pronoun',

	  }
	};

	var verbs$1 = {
	  Verb: {
	    notA: ['Noun', 'Adjective', 'Adverb', 'Value']
	  },
	  // walks
	  PresentTense: {
	    isA: 'Verb',
	    notA: ['PastTense', 'FutureTense']
	  },
	  // neutral form - 'walk'
	  Infinitive: {
	    isA: 'PresentTense',
	    notA: ['PastTense', 'Gerund']
	  },
	  //close the door!
	  Imperative: {
	    isA: 'Infinitive' // notA: ['PresentTense', 'PastTense', 'FutureTense', 'Gerund'],

	  },
	  // walking
	  Gerund: {
	    isA: 'PresentTense',
	    notA: ['PastTense', 'Copula', 'FutureTense']
	  },
	  // walked
	  PastTense: {
	    isA: 'Verb',
	    notA: ['FutureTense']
	  },
	  // will walk
	  FutureTense: {
	    isA: 'Verb'
	  },
	  // is
	  Copula: {
	    isA: 'Verb'
	  },
	  // would have
	  Modal: {
	    isA: 'Verb',
	    notA: ['Infinitive']
	  },
	  // had walked
	  PerfectTense: {
	    isA: 'Verb',
	    notA: 'Gerund'
	  },
	  Pluperfect: {
	    isA: 'Verb'
	  },
	  // shown
	  Participle: {
	    isA: 'PastTense'
	  },
	  // show up
	  PhrasalVerb: {
	    isA: 'Verb'
	  },
	  //'up' part
	  Particle: {
	    isA: 'PhrasalVerb'
	  },
	  //this can be an adverb
	  Auxiliary: {
	    notA: ['Noun', 'Adjective', 'Value']
	  }
	};

	var values = {
	  Value: {
	    notA: ['Verb', 'Adjective', 'Adverb']
	  },
	  Ordinal: {
	    isA: 'Value',
	    notA: ['Cardinal']
	  },
	  Cardinal: {
	    isA: 'Value',
	    notA: ['Ordinal']
	  },
	  Fraction: {
	    isA: 'Value',
	    notA: ['Noun']
	  },
	  RomanNumeral: {
	    isA: 'Cardinal',
	    //can be a person, too
	    notA: ['Ordinal', 'TextValue']
	  },
	  TextValue: {
	    isA: 'Value',
	    notA: ['NumericValue']
	  },
	  NumericValue: {
	    isA: 'Value',
	    notA: ['TextValue']
	  },
	  Money: {
	    isA: 'Cardinal'
	  },
	  Percent: {
	    isA: 'Value'
	  }
	};

	var anything = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Value', 'QuestionWord'];
	var misc$1 = {
	  //--Adjectives--
	  Adjective: {
	    notA: ['Noun', 'Verb', 'Adverb', 'Value']
	  },
	  // adjectives that can conjugate
	  Comparable: {
	    isA: ['Adjective']
	  },
	  // better
	  Comparative: {
	    isA: ['Adjective']
	  },
	  // best
	  Superlative: {
	    isA: ['Adjective'],
	    notA: ['Comparative']
	  },
	  NumberRange: {
	    isA: ['Contraction']
	  },
	  Adverb: {
	    notA: ['Noun', 'Verb', 'Adjective', 'Value']
	  },
	  // Dates:
	  //not a noun, but usually is
	  Date: {
	    notA: ['Verb', 'Adverb', 'Preposition', 'Adjective']
	  },
	  Month: {
	    isA: ['Date', 'Singular'],
	    notA: ['Year', 'WeekDay', 'Time']
	  },
	  WeekDay: {
	    isA: ['Date', 'Noun']
	  },
	  // '9:20pm'
	  Time: {
	    isA: ['Date'],
	    notA: ['AtMention']
	  },
	  //glue
	  Determiner: {
	    notA: anything
	  },
	  Conjunction: {
	    notA: anything
	  },
	  Preposition: {
	    notA: anything
	  },
	  // what, who, why
	  QuestionWord: {
	    notA: ['Determiner']
	  },
	  // peso, euro
	  Currency: {
	    isA: ['Noun']
	  },
	  // ughh
	  Expression: {
	    notA: ['Noun', 'Adjective', 'Verb', 'Adverb']
	  },
	  // dr.
	  Abbreviation: {},
	  // internet tags
	  Url: {
	    notA: ['HashTag', 'PhoneNumber', 'Verb', 'Adjective', 'Value', 'AtMention', 'Email']
	  },
	  PhoneNumber: {
	    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention', 'Email']
	  },
	  HashTag: {},
	  AtMention: {
	    isA: ['Noun'],
	    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'Email']
	  },
	  Emoji: {
	    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention']
	  },
	  Emoticon: {
	    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention']
	  },
	  Email: {
	    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention']
	  },
	  //non-exclusive
	  Acronym: {
	    notA: ['Plural', 'RomanNumeral']
	  },
	  Negative: {
	    notA: ['Noun', 'Adjective', 'Value']
	  },
	  // if, unless, were
	  Condition: {
	    notA: ['Verb', 'Adjective', 'Noun', 'Value']
	  }
	};

	// i just made these up
	var colorMap = {
	  Noun: 'blue',
	  Verb: 'green',
	  Negative: 'green',
	  Date: 'red',
	  Value: 'red',
	  Adjective: 'magenta',
	  Preposition: 'cyan',
	  Conjunction: 'cyan',
	  Determiner: 'cyan',
	  Adverb: 'cyan'
	};
	/** add a debug color to some tags */

	var addColors = function addColors(tags) {
	  Object.keys(tags).forEach(function (k) {
	    // assigned from plugin, for example
	    if (tags[k].color) {
	      tags[k].color = tags[k].color;
	      return;
	    } // defined above


	    if (colorMap[k]) {
	      tags[k].color = colorMap[k];
	      return;
	    }

	    tags[k].isA.some(function (t) {
	      if (colorMap[t]) {
	        tags[k].color = colorMap[t];
	        return true;
	      }

	      return false;
	    });
	  });
	  return tags;
	};

	var _color = addColors;

	var unique$3 = function unique(arr) {
	  return arr.filter(function (v, i, a) {
	    return a.indexOf(v) === i;
	  });
	}; //add 'downward' tags (that immediately depend on this one)


	var inferIsA = function inferIsA(tags) {
	  Object.keys(tags).forEach(function (k) {
	    var tag = tags[k];
	    var len = tag.isA.length;

	    for (var i = 0; i < len; i++) {
	      var down = tag.isA[i];

	      if (tags[down]) {
	        tag.isA = tag.isA.concat(tags[down].isA);
	      }
	    } // clean it up


	    tag.isA = unique$3(tag.isA);
	  });
	  return tags;
	};

	var _isA = inferIsA;

	var unique$2 = function unique(arr) {
	  return arr.filter(function (v, i, a) {
	    return a.indexOf(v) === i;
	  });
	}; // crawl the tag-graph and infer any conflicts
	// faster than doing this at tag-time


	var inferNotA = function inferNotA(tags) {
	  var keys = Object.keys(tags);
	  keys.forEach(function (k) {
	    var tag = tags[k];
	    tag.notA = tag.notA || [];
	    tag.isA.forEach(function (down) {
	      if (tags[down] && tags[down].notA) {
	        // borrow its conflicts
	        var notA = typeof tags[down].notA === 'string' ? [tags[down].isA] : tags[down].notA || [];
	        tag.notA = tag.notA.concat(notA);
	      }
	    }); // any tag that lists us as a conflict, we conflict it back.

	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];

	      if (tags[key].notA.indexOf(k) !== -1) {
	        tag.notA.push(key);
	      }
	    } // clean it up


	    tag.notA = unique$2(tag.notA);
	  });
	  return tags;
	};

	var _notA = inferNotA;

	// a lineage is all 'incoming' tags that have this as 'isA'
	var inferLineage = function inferLineage(tags) {
	  var keys = Object.keys(tags);
	  keys.forEach(function (k) {
	    var tag = tags[k];
	    tag.lineage = []; // find all tags with it in their 'isA' set

	    for (var i = 0; i < keys.length; i++) {
	      if (tags[keys[i]].isA.indexOf(k) !== -1) {
	        tag.lineage.push(keys[i]);
	      }
	    }
	  });
	  return tags;
	};

	var _lineage = inferLineage;

	var validate = function validate(tags) {
	  // cleanup format
	  Object.keys(tags).forEach(function (k) {
	    var tag = tags[k]; // ensure isA is an array

	    tag.isA = tag.isA || [];

	    if (typeof tag.isA === 'string') {
	      tag.isA = [tag.isA];
	    } // ensure notA is an array


	    tag.notA = tag.notA || [];

	    if (typeof tag.notA === 'string') {
	      tag.notA = [tag.notA];
	    }
	  });
	  return tags;
	}; // build-out the tag-graph structure


	var inferTags = function inferTags(tags) {
	  // validate data
	  tags = validate(tags); // build its 'down tags'

	  tags = _isA(tags); // infer the conflicts

	  tags = _notA(tags); // debug tag color

	  tags = _color(tags); // find incoming links

	  tags = _lineage(tags);
	  return tags;
	};

	var inference = inferTags;

	var addIn = function addIn(obj, tags) {
	  Object.keys(obj).forEach(function (k) {
	    tags[k] = obj[k];
	  });
	};

	var build = function build() {
	  var tags = {};
	  addIn(nouns$1, tags);
	  addIn(verbs$1, tags);
	  addIn(values, tags);
	  addIn(misc$1, tags); // do the graph-stuff

	  tags = inference(tags);
	  return tags;
	};

	var tags = build();

	var _data = {
	  "Comparative": "truebetter",
	  "Superlative": "trueearlier",
	  "PresentTense": "trueis,sounds",
	  "Value": "truea few",
	  "Noun": "truea5b4c2f1here,ie,lit,m0no doubt,pd,tce;a,d;t,y;a,ca,o0;l,rp;a,l;d,l,rc",
	  "Copula": "truea1is,w0;as,ere;m,re",
	  "PastTense": "truebe3came,d2had,lied,meant,sa2taken,w0;as,e0;nt,re;id;en,gan",
	  "Condition": "trueif,lest,unless",
	  "Preposition": "true'o,-,aLbIcHdGexcept,fFiDmidQnotwithstandiRoBpSqua,sAt6u3vi2w0;/o,hereNith0;!in,oR;a,s-a-vis;n1p0;!on;like,til;h0ill,owards;an,r0;ough0u;!oJ;ans,ince,o that;',f0n2ut;!f;f,n0;!to;or,rom;espite,own,u3;hez,irca;ar1e0oAy;sides,tween;ri6;',bo7cross,ft6lo5m3propos,round,s1t0;!op;! long 0;as;id0ong0;!st;ng;er;ut",
	  "Gerund": "trueaccord0be0develop0go0result0stain0;ing",
	  "Negative": "truen0;ever,o0;!n,t",
	  "QuestionWord": "truehow3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
	  "Plural": "truerecords",
	  "Conjunction": "true&,aFbBcuz,how9in caEno8o7p5supposing,t2v1wh0yet;eth9ile;ers4s;h0o;eref9o0;!uC;l0rovided that;us;r,therwi6; matt1r;!ev0;er;e0ut;cau1f0;ore;se;lthou1nd,s 0;far as,if;gh",
	  "Abbreviation": "truea0Jb0Gc0Ad08e05f02g01h00iYjWkanVlTmNnKoJpFque,rDs8t6u5v2w0;is0r,y0B;!c;a,b,e1i0ol,s,t;tro,vo;r,t;niv,safa,t;ce,e0;l,mp,nn,x;ask,e2fc,gt,i1q,r,s,t,u0;pt,rg;r,tu;c,nJp0;!t;b,d,e0;pGs,v;a,d,ennNhd,l,p,r1s0vt;!eud;ef,o0;b,f,n;ct,kla,nt;e0ov;b0e;!r;a4d,essrs,i1lle,me,r7s0t;!tr;n1s0;c,ter;!n;!j,r,sc;at,it,lb,ng,t0;!d;!s;an,d,r,u0;l,n;a,da,e,n0;c,f;on,wy;a,en,ov;e1ig,l0m,r,t,y;!a;b,m;a,g,ng,s1tc,x0;!p;p,q,t;ak,e0ist,r;c,f,pt,t;a3ca,l,m2o0pl,res,yn;!l0m1nn,rp;!o;dr;!l0pt;!if;a,c,l1r0;ig,os;!dg,vd;d4l3p2r1ss0tty,ug,ve;n,t;c,iz;prox,r,t;!ta;!j,m,v",
	  "Pronoun": "true'em,elle,h4i3me,ourselves,she5th1us,we,you0;!rself;e0ou;m,y;!l,t;e0im;!'s",
	  "Singular": "true0:15;1:12;2:18;a15b0Sc0Jd0Ce09f04gZhViUjel0kitty,lSmOnNoMpHquestionGrEs9t6u4w3;ay,om02;nc0Zs 3;doll0Kst0M; rex,a4h3ic,ragedy,v show;ere,i2;l0x return;i6ky,omeoMt3uper bowl,yst14;ep4ri2u3;de0Xff;faSmoS;st1ze;al0i2o3;om,se;! mark;a6i1la5r4u3;dPrpoH;eroga00ie0Gobl0U;te,y1;rt,te0N;bjWceJthers,verview;othi2umb1;a5ee08o3;del,m3nopo0rni2th1;!my;n,yf0;i3unch;ne;ci2nsect;ead start,o3uman right;l0me4u3;se;! run;adf0entlem6irl02laci1od,rand4u3;l0y; slam,fa3mo3;th1;an;a6ella,ly,ol0r4un3;di2;ee market,iWo3;nti1sP;mi0th1;conomy,gg,ner7ven4x3;ampTecu9;i2t;ad8e5inn1o3ragonf0ude;cumentGg3i0l0or;gy;ath,t3;ec3;tive;!dy;a9eili2h7i5o3redit card;ttage,u3;ri1sin;ty,vil w3;ar;andeli1ocol3;ate;n3rF;ary;aCel0lesJo8r5u3;n3tterf0;ti2;eakfa4o3;!th1;st;dy,tt5y3;!fri3;end;le;nki2r3;ri1;er;d5l0noma0u3;nt;ly; homin5verti3;si2;ng;em",
	  "FemaleName": "true0:J3;1:J7;2:IG;3:IF;4:IX;5:IK;6:JO;7:H0;8:JG;9:JK;A:HN;B:HY;C:IT;D:IP;E:JD;F:HC;G:I0;aGRbFLcDPdCYeBOfB4gADh9Ti9Gj8Gk7Gl60m49n3No3Jp37qu36r2Ds16t0Eu0Cv02wVxiTyOzH;aLeIineb,oHsof2;e3Uf2la,ra;h3iKlIna,ynH;ab,ep;da,ma;da,h3iHra;nab;aKeJi0Fol5BuIvH;etAonDO;i0na;le0sen2;el,gm3Jn,rGJs8W;aoHme0nyi;m62yAE;aMendDYhiDFiH;dele8lJnH;if48niHo0;e,f47;a,helmi0lHma;a,ow;ka0nB;aNeKiHusa5;cIktoriBMlAole7viH;anC3enJ0;kF9tor2;da,lA9nus,rHs0;a,nHoniH4;a,iFQ;leHnesH4;nIHrH;i1y;g8rHxH5;su5te;aYeUhRiNoLrIuHy3;i,la;acIZiHu0L;c2na,sH;hBPta;nHr0H;iBNya;aJffaEOnHs6;a,gtiH;ng;!nFQra;aIeHomasi0;a,l9Po8Ares1;l2ndolwethu;g9Go88rIssH;!a,ie;eHi,ri9;sa,za;bPlNmLnJrIs6tHwa0;ia0um;a63yn;iHya;a,ka,s6;arB6e3iHmEDra;!ka;a,iH;a,t6;at6it6;a0Fcarlet3We0BhXiTkye,neza0oRtNuIyH;bIBlvi1;e,ha,mayIEni7sIzH;an3MetAie,y;anHi9;!a,e,nH;aDe;aJeH;fHl5GphH;an4;cHZr5;b2fiA8m0OnHphi1;d3ia,ja,ya;er3lJmon1nIobh8PtH;a,i;dy;lEPv2;aMeIirHo0risF7y5;a,lDK;ba,e0i5lJrH;iHrDOyl;!d8Hfa;ia,lDX;hd,iMki3nJrIu0w0yH;la,ma,na;i,le8on,ron;aIda,ia,nHon;a,on;!ya;k6mH;!aa;lJrItaye81vH;da,inj;e0ife;en1i0ma;anA5bNd3Nh1RiBkMlLmJndIrHs6vannaD;aDi0;ra,y;aHi3;nt6ra;lDKma,ome;ee0in8Ru3;in1ri0;a05e00hYiVoIuH;by,thDH;bScRghQl2KnPsJwIxH;anAXie,y;an,e0;aIeHie,lE; merBLann9ll1marDBt7;!lHnn1;iHyn;e,nH;a,d9K;da,i,na;ayy8D;hel62io;bDKer7yn;a,cIkHmas,n9Fta,ya;ki,o;helGki;ea,iannGDoH;da,n1K;an0bJem9Agi0iInHta,y0;a88ee;han83na;a,eH;cEAkaD;bi0chIe,i0mo0nHquEKvCy0;di,ia;aEIelHiB;!e,le;een4ia0;aNeMhKipaluk,oJrHute66;iHudenCQ;scil3LyamvaB;lly,rt2;ilome0oebe,ylH;is,lis;arl,ggy,nelope,r5t3;ige,m0TnKo5rvaDGtIulH;a,etAin1;ricHsy,tBY;a,e,ia;do3i06;ctav2dIfCZis6lHphCZumC3yunbileg;a,ga,iv2;eHvAC;l2tA;aWeUiMoIurHy5;!ay,ul;a,eJor,rIuH;f,r;aDeCma;ll1mi;aNcLhariBOkKlaJna,sHta,vi;anHha;ur;!y;a,iDTki;hoGk9VolH;a,eDJ;!mh;hir,lHna,risFsreC;!a,lBT;asuLdKh2i6CnJomi9rgEPtHzanin zah3;aHhal4;li1s6;cy,etA;a,e8iEV;nngu30;a09ckenz4e01iMoJrignayani,uriDDyH;a,rH;a,lNna,tG;bi0i3llBInH;a,iH;ca,ka,qD3;a,cTkaSlNmi,nLrItzi,yH;ar;aIiam,lH;anEO;!l,nB;dy,eHh,n4;nhGrva;aKdJiCPlH;iHy;cent,e;red;!gros;!e5;ae5hH;ae5el3Z;ag5EgNi,lKrH;edi79iIjem,on,yH;em,l;em,sF;an4iHliF;nHsCE;a,da;!an,han;b0DcASd0Be,g09ha,i08ja,l06n04rLsoum60tKuIv82x9IyHz4;a,bell,ra,soB9;de,rH;a,eC;h8Fild1t4;a,cYgUiKjor4l7Sn4s6tJwa,yH;!aHbe6Wja8lAE;m,nBH;a,ha,in1;!aJbCBeIja,lEna,sHt64;!a,ol,sa;!l1H;! Jh,mInH;!a,e,n1;!awit,i;aliAHcJeduarBfernIjHlui5Y;o6Ful2;anB;ecil2la3;arJeIie,oHr44ueriA;!t;!ry;et42i37;el4Ui76y;dHon,ue5;akran7y;ak,en,iHk,lo3O;a,ka,nB;a,re,s4te;daHg4;!l3A;alEd4elHge,isDBon0;ei8in1yn;el,le;a0Ne0CiYoQuLyH;d2la,nH;!a,dIeBGnHsCL;!a,eBF;a,sCJ;aCWcJel0PiFlIna,pHz;e,i7;a,u,wa;iHy;a0Se,ja,l2JnB;is,l1SrJttIuHvel4;el5is1;e,ie;aKeIi9na,rH;a86i9;lHn1t7;ei;!in1;aSbb9CdRepa,lMnJsIv2zH;!a,be5LetAz4;a,etA;!a,dH;a,sHy;ay,ey,i,y;a,iJja,lHy;iHy;aA0e;!aH;!n5F;ia,ya;!nH;!a,ne;aPda,e0iNjYla,nMoKsJtHx4y5;iHt4;c2t2;e2LlCG;la,nHra;a,ie,o3;a,or1;a,gh,laH;!ni;!h,nH;a,d3e,n5P;cOdon97iNkes6mi9Ana,rMtJurIvHxmi,y5;ern1in2;a,e54ie,yn;as6iIoH;nya,ya;fa,s6;a,isF;a,la;ey,ie,y;a04eZhXiOlAKoNrJyH;lHra;a,ee,ie;istHy6D;a,en,iIyH;!na;!e,n59;nul,ri,urtnB0;aOerNlAZmJrHzzy;a,stH;en,in;!berlImernH;aq;eHi,y;e,y;a,stC;!na,ra;aHei3ongordzol;dij1w5;el7QiKjsi,lJnIrH;a,i,ri;d3na,za;ey,i,lBDs4y;ra,s6;bi7cAJdiat7IeB2iRlQmPnyakuma19rNss6KtKvi7yH;!e,lH;a,eH;e,i8L;a6DeIhHi4NlEri0y;ar6Ber6Bie,leCrB2y;!lyn8Gri0;a,en,iHl5Soli0yn;!ma,n3VsF;a5il1;ei8Ei,l4;a,tl6L;a07eYiVoNuH;anLdKliHst63;a8HeHsF;!n8tH;!a,te;e5Ji3Jy;a,i7;!anNcelEd6RelGhan7RlLni,sIva0yH;a,ce;eHie;fHlEph5U;a,in1;eHie;en,n1;!a,e,n41;lHng;!i1ClH;!i1B;anMle0nJrIsH;i8Csi8C;i,ri;!a,elGif2CnH;a,etAiHy;!e,f2A;a,e8EiInH;a,e8DiH;e,n1;cMd1mi,nIque4Xsmin3Ovie3y8zH;min9;a9eIiH;ce,e,n1s;!lHsFt0F;e,le;inIk4lEquelH;in1yn;da,ta;lRmPnOo0rNsIvaHzaro;!a0lu,na;aJiIlaHob84;!n9N;do3;!belHdo3;!a,e,l39;a77en1i0ma;a,di3es,gr6Yji;a8elBogH;en1;a,e8iHo0se;a0na;aSeOiJoHusFyacin2B;da,ll4rten23snH;a,i9Q;lImaH;ri;aIdHlaI;a,egard;ry;ath1CiJlInriet7rmi8sH;sa,t1B;en2Sga,mi;di;bi2Dil8IlNnMrJsItHwa,yl8Iz7H;i5St4;n5Yti;iHmo51ri52;etH;!te;aDnaD;a,ey,l4;a03eXiSlQoOrKunJwH;enHyne1Q;!dolE;ay,el;acIetHiselB;a,chC;e,ieH;!la;ld1AogooH;sh;adys,enHor2yn2H;a,da,na;aKgi,lIna,ov89selHta;a,e,le;da,liH;an;!n0;mLnJorgIrH;ald3Pi,m3Ctru8B;etAi4W;a,eHna;s26vieve;ma;bIil,le,mHrnet,yG;al5Ni5;i5FrielH;a,l1;aVeSiRloOoz2rH;anJeIiH;da,eB;da,ja;!cH;esIiHoi0O;n1s61;!ca;!rH;a,encH;e,ia;en,o0;lIn0rnH;!anB;ec2ic2;jr,n7rKtHy9;emIiHma,ouma7;ha,ma,n;eh;ah,iBrah,za0;cr4Nd0Ne0Mi0Lk7l04mWn4YrTsNtMuLvH;aJelIiH;!e,ta;in0Gyn;!ngel2S;geni1la,ni45;h5Sta;mLperanKtH;eIhHrel5;er;l30r9;za;a,eralB;iHma,nest2Jyn;cHka,n;a,ka;a,eMiJmH;aHie,y;!li8;lHn1;ee,iHy;a,e,ja;lHrald;da,y;aWeUiNlMma,no3oKsJvH;a,iH;na,ra;a,ie;iHuiH;se;a,en,ie,y;a0c2da,f,nMsJzaH;!betHve7;e,h;aHe,ka;!beH;th;!a,or;anor,nH;!a;!in1na;leCs6;vi;eIiHna,wi0;e,th;l,n;aYeMh2iLjeneKoHul30;lor5Tminiq4In3FrHtt4;a,eCis,la,othHthy;ea,y;ba;an0AnaDon8x4ya;anQbPde,eOiMja,lJmetr2nHsir5K;a,iH;ce,se;a,iIla,orHphi8;es,is;a,l6D;dHrdH;re;!d5Cna;!b2HoraDra;a,d3nH;!a,e;hl2i0l0HmNnLphn1rIvi1XyH;le,na;a,by,cIia,lH;a,en1;ey,ie;a,etAiH;!ca,el1Cka,z;arHia;is;a0Se0Oh05i03lVoKrIynH;di,th2;istHy05;al,i0;lPnMrIurH;tn1E;aJd2NiHn2Nri8;!nH;a,e,n1;!l1X;cepci59n4sH;tanHuelo;ce,za;eHleC;en,tA;aJeoIotH;il51;!pat3;ir9rJudH;etAiH;a,ne;a,e,iH;ce,sZ;a3er3ndH;i,y;aReNloe,rH;isJyH;stH;al;sy,tH;a1Ren,iHy;!an1e,n1;deJlseIrH;!i9yl;a,y;li8;nMrH;isKlImH;ai8;a,eHotA;n1tA;!sa;d3elGtH;al,elG;cIlH;esAi44;el2ilH;e,ia,y;itlZlYmilXndWrOsMtHy5;aKeJhHri0;erHleCrEy;in1;ri0;li0ri0;a33sH;a32ie;a,iNlLmeJolIrH;ie,ol;!e,in1yn;lHn;!a,la;a,eHie,o7y;ne,y;na,sF;a0Hi0H;a,e,l1;is7l4;in,yn;a0Ie02iZlXoUrH;andSeQiJoIyH;an0nn;nwEok9;an3DdgLg0XtH;n2XtH;!aInH;ey,i,y;ny;etH;!t9;an0e,nH;da,na;i9y;bbi9glarIlo05nH;i7n4;ka;ancHossom,ythe;a,he;an17lja0nHsm3I;i7tH;ou;aUcky,linTni7rPssOtJulaDvH;!erlH;ey,y;hJsy,tH;e,iHy9;e,na;!anH;ie,y;!ie;nHt6yl;adIiH;ce;etAi8;ay,da;!triH;ce,z;rbJyaH;rmH;aa;a3ie,o3ra;a2Sb2Md23g1Zi1Qj5l16m0Xn09oi,r04sUtTuPvOwa,yIzH;ra,u0;aKes6gJlIseH;!l;in;un;!nH;a,na;a,i2Ir2J;drJgus1RrIsteH;ja;el2;a,ey,i,y;aahua,he0;hIi2Gja,mi7s2DtrH;id;aMlIraqHt21;at;eIi9yH;!n;e,iHy;gh;!nH;ti;iJleIo6pi7;ta;en,n1tA;aHelG;!n1J;a00dje5eYgUiSjQnJohito,toHya;inetAnH;el5ia;!aKeIiHmJ;e,ka;!mHtA;ar4;!belIliFmU;sa;!le;a,eliH;ca;ka,sHta;a,sa;elHie;a,iH;a,ca,n1qH;ue;!tA;te;! JbImHstasiNya;ar2;el;cla3jul2pau5;aLberKeliJiHy;e,l2naH;!ta;a,ja;!ly;hGiIl2nB;da;a,ra;le;aWba,ePiMlKma,thJyH;a,c2sH;a,on,sa;ea;iHys0N;e,s0M;a,cIn1sHza;a,e,ha,on,sa;e,ia,ja;c2is6jaKksaKna,sJxH;aHia;!nd3;ia,saH;nd3;ra;ia;i0nIyH;ah,na;a,is,naDoud;la;c6da,leCmNnLsH;haDlH;inHyY;g,n;!h;a,o,slH;ey;ee;en;at6g4nIusH;ti0;es;ie;aWdiTelMrH;eJiH;anMenH;a,e,ne;an0;na;!aLeKiIyH;nn;a,n1;a,e;!ne;!iH;de;e,lEsH;on;yn;!lH;i8yn;ne;aKbIiHrL;!gaK;ey,i9y;!e;gaH;il;dKliyJradhIs6;ha;ya;ah;a,ya",
	  "Actor": "trueaJbGcFdCengineIfAgardenIh9instructPjournalLlawyIm8nurse,opeOp5r3s1t0;echnCherapK;ailNcientJecretary,oldiGu0;pervKrgeon;e0oofE;ceptionGsearC;hotographClumbColi1r0sychologF;actitionBogrammB;cem6t5;echanic,inist9us4;airdress8ousekeep8;arm7ire0;fight6m2;eputy,iet0;ici0;an;arpent2lerk;ricklay1ut0;ch0;er;ccoun6d2ge7r0ssis6ttenda7;chitect,t0;ist;minist1v0;is1;rat0;or;ta0;nt",
	  "Honorific": "truea01bYcQdPeOfiJgIhon,jr,king,lHmCoffic00p7queen,r3s0taoiseach,vice6;e1fc,gt,ir,r,u0;ltRpt,rg;cond liInBrgeaJ;abbi,e0;ar1p9s,v0;!erend; admirX;astOhd,r0vt;esideDi1of0;!essM;me mini4nce0;!ss;a3essrs,i2lle,me,r1s0;!tr;!s;stK;gistrate,j,r6yF;i3lb,t;en,ov;eld mar3rst l0;ady,i0;eutena0;nt;shG;sq,xcellency;et,oct6r,utchess;apt6hance4mdr,o0pl;lonel,m2ngress0unci3;m0wom0;an;dr,mand5;ll0;or;!ain;ldg,rig0;!adi0;er;d0sst,tty,yatullah;j,m0v;!ir0;al",
	  "SportsTeam": "true0:1A;1:1H;2:1G;a1Eb16c0Td0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Bm01newToQpJqueens parkIreal salt lake,sAt5utah jazz,vancouver whitecaps,w3yW;ashington 3est ham0Rh10;natio1Oredski2wizar0W;ampa bay 6e5o3;ronto 3ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasC;buccanee0ra0K;a7eattle 5heffield0Kporting kansas0Wt3;. louis 3oke0V;c1Frams;marine0s3;eah15ounG;cramento Rn 3;antonio spu0diego 3francisco gJjose earthquak1;char08paA; ran07;a8h5ittsburgh 4ortland t3;imbe0rail blaze0;pirat1steele0;il3oenix su2;adelphia 3li1;eagl1philNunE;dr1;akland 3klahoma city thunder,rlando magic;athle0Mrai3;de0; 3castle01;england 7orleans 6york 3;city fc,g4je0FknXme0Fred bul0Yy3;anke1;ian0D;pelica2sain0C;patrio0Brevolut3;ion;anchester Be9i3ontreal impact;ami 7lwaukee b6nnesota 3;t4u0Fvi3;kings;imberwolv1wi2;rewe0uc0K;dolphi2heat,marli2;mphis grizz3ts;li1;cXu08;a4eicesterVos angeles 3;clippe0dodDla9; galaxy,ke0;ansas city 3nE;chiefs,roya0E; pace0polis colU;astr06dynamo,rockeTtexa2;olden state warrio0reen bay pac3;ke0;.c.Aallas 7e3i05od5;nver 5troit 3;lio2pisto2ti3;ge0;broncZnuggeM;cowbo4maver3;ic00;ys; uQ;arCelKh8incinnati 6leveland 5ol3;orado r3umbus crew sc;api5ocki1;brow2cavalie0india2;bengaWre3;ds;arlotte horAicago 3;b4cubs,fire,wh3;iteB;ea0ulR;diff3olina panthe0; c3;ity;altimore 9lackburn rove0oston 5rooklyn 3uffalo bilN;ne3;ts;cel4red3; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 3;brav1falco2h4u3;nited;aw9;ns;es;on villa,r3;os;c5di3;amondbac3;ks;ardi3;na3;ls",
	  "Uncountable": "true0:1I;1:16;2:1X;a1Rb1Jc1Ad17e10f0Ug0Nh0Ii0Ej0Dknowled1Ql08mYnews,oXpTrOsDt8vi7w3;a5ea0Bi4oo3;d,l;ldlife,ne;rmth,t0;neg17ol0Ctae;e6h5oothpaste,r3una;affTou3;ble,sers,t;ermod1Mund0;a,nnis;aBcene0Aeri1hAil9kittl1now,o8p6t4u3;g10nshi0Q;ati1Le3;am,el;ace1Ee3;ci1ed;ap,cc0;k,v0;eep,ingl1;d0Dfe18l3nd,tish;m11t;a6e4ic3;e,ke0M;c3laxa0Isearch;ogni0Hrea0H;bi1in;aPe5hys2last9o3ress04;l3rk,w0;it2yA;a12trZ;bstetr2il,xygen;aAe8ilk,o5u3;mps,s3;ic;n3o0I;ey,o3;gamy;a3chan2;sl1t;chine3il,themat2; learn0Bry;aught0e5i4ogi0Su3;ck,g0I;ce,ghtn08ngui0QteratN;a3isM;th0;ewelAusti0L;ce,mp3nformaUtself;a3ortan0J;ti3;en0H;a6isto5o3;ck3mework,n3spitali0B;ey;ry;ir,libut,ppiD;ene6o4r3um,ymna0D;aCound;l3ssip;d,f; 3t2;editQpo3;ol;i7lour,o4urnit3;ure;od,rgive3uri0wl;ne3;ss;c9sh;conom2duca8lectr7n5quip6th2very3;body,o3thH;ne;joy3tertain3;ment;iciPon2;tiI;ar4iabet1raugh4;es;ts;aAelcius,h6iv2l5o3urrency;al,ld w3nfusiDttD;ar;ass2oth5;aos,e3;e4w3;ing;se;r7sh;a7eef,i4lood,owls,read,utt0;er;lliar4s3;on;ds;g3ss;ga3;ge;c8dvi7ero5ir4mnes3rt,thlet2;ty;craft;b2d3naut2;ynam2;ce;id,ou3;st2;ics",
	  "Infinitive": "true0:6S;1:76;2:5C;3:74;4:73;5:67;6:6F;7:6Y;8:6Q;9:72;A:70;B:5X;C:6X;D:6L;E:77;F:5B;a6Kb66c57d4De3Xf3Jg3Dh37i2Uj2Sk2Ql2Hm26n23o1Yp1Jr0Rs06tYuTvOwHyG;awn,ield;aJe1Zhist6iIoGre6D;nd0rG;k,ry;pe,sh,th0;lk,nHrGsh,tDve;n,raE;d0t;aJiHoG;te,w;eGsC;!w;l6Jry;nHpGr4se;gra4Pli41;dGi9lo5Zpub3Q;erGo;mi5Cw1I;aMeLhKig5SoJrHuGwi7;ne,rn;aGe0Mi5Uu7y;de,in,nsf0p,v5J;r2ZuD;ank,reatB;nd,st;lk,rg1Qs9;aZcWeVhTi4Dkip,lSmRnee3Lo52pQtJuGwitD;bmCck,ff0gge7ppHrGspe5;ge,pri1rou4Zvi3;ly,o36;aLeKoJrHuG;dy,mb6;aFeGi3;ngthBss,tD;p,re;m,p;in,ke,r0Qy;la58oil,rink6;e1Zi6o3J;am,ip;a2iv0oG;ck,rtBut;arDem,le5n1r3tt6;aHo2rG;atDew;le,re;il,ve;a05eIisk,oHuG;in,le,sh;am,ll;a01cZdu8fYgXje5lUmTnt,pQquPsKtJvGwa5V;eGiew,o36;al,l,rG;se,t;aFi2u44;eJi7oItG;!o2rG;i5uc20;l3rt;mb6nt,r3;e7i2;air,eHlGo43r0K;a8y;at;aFemb0i3Zo3;aHeGi3y;a1nt;te,x;a5Dr0J;act1Yer,le5u1;a13ei3k5PoGyc6;gni2Cnci6rd;ch,li2Bs5N;i1nG;ge,k;aTerSiRlOoMrIuG;b21ll,mp,rGsh;cha1s4Q;ai1eIiEoG;cGdu8greAhibCmi1te7vi2W;eAlaim;di5pa2ss,veE;iEp,rtr46sGur;e,t;aHead,uG;g,n4;n,y;ck,le;fo34mCsi7;ck,iErt4Mss,u1;bJccur,ff0pera9utweIverGwe;co47lap,ta22u1wG;helm;igh;ser3taF;eHotG;e,i8;ed,gle5;aMeLiIoHuG;ltip3Grd0;nit13ve;nHrr12sreprG;eseE;d,g6us;asu2lt,n0Nr4;intaFna4rHtG;ch,t0;ch,kGry;et;aMeLiJoGu1C;aHck,oGve;k,sB;d,n;ft,g35ke,mCnk,st2YveG;!n;a2Fc0Et;b0Nck,uG;gh,nD;iGno34;ck,ll,ss;am,oFuG;d4mp;gno2mQnGss3H;cOdica9flu0MhNsKtIvG;eGol3;nt,st;erGrodu8;a5fe2;i7tG;aGru5;ll;abCibC;lu1Fr1D;agi24pG;lemeEo22ro3;aKeIi2oHuG;nt,rry;n02pe,st;aGlp;d,t;nd6ppBrm,te;aKloAove1PrIuG;arGeAi15;ant39d;aGip,ow,umb6;b,sp;in,th0ze;aReaQiOlMoJrHuncG;ti3J;acGeshB;tu2;cus,lHrG;ce,eca7m,s30;d,l24;a1ZoG;at,od,w;gu2lGni1Xt,x;e,l;r,tu2;il,stBvG;or;a15cho,le5mSnPstNvalua9xG;a0AcLerKi7pGte19;a18eHi2laFoGreA;rt,se;ct,riG;en8;ci1t;el,han4;abGima9;li1J;ab6couXdHfor8ga4han8j03riDsu2t0vG;isi2Vy;!u2;body,er4pG;hasiGow0;ze;a07eUiLoKrHuG;mp;aHeAiG;ft;g,in;d4ubt;ff0p,re5sHvG;iZor8;aKcHliGmiApl1Btingui14;ke;oGuA;uGv0;ra4;gr1YppG;ear,ro3;cOeNfLliv0ma0Fny,pKsHterG;mi0G;cribe,er3iHtrG;oy;gn,re;a0Be0Ai5osC;eGi0By;at,ct;m,pB;iIlHrG;ea1;a2i06;de;ma4n8rGte;e,kB;a0Ae09h06i9l04oJrG;aHeGoAu0Hy;a9dC;ck,ve;llZmSnHok,py,uGv0;gh,nt;cePdu5fMsKtIvG;eGin8;rt,y;aFin0VrG;a7ibu9ol;iGtitu9;d0st;iHoGroE;rm;gu2rm;rn;biLfoKmaJpG;a2laF;in;re;nd;rt;ne;ap1e5;aGip,o1;im,w;aHeG;at,ck,w;llen4n4r4se;a1nt0;ll,ncIrGt0u1;eGry;!en;el;aSePloOoMrIuG;lGry;ly;igHuG;sh;htB;en;a7mb,o7rrGth0un8;ow;ck;ar,lHnefCtrG;ay;ie3ong;ng,se;band0Jc0Bd06ffo05gr04id,l01mu1nYppTrQsKttGvoid,waC;acIeHra5;ct;m0Fnd;h,k;k,sG;eIiHocia9uG;me;gn,st;mb6rt;le;chHgGri3;ue;!i3;eaJlIroG;aDve;ch;aud,y;l,r;noun8sw0tG;icipa9;ce;lHt0;er;e4ow;ee;rd;aRdIju7mCoR;it;st;!reA;ss;cJhie3knowled4tiva9;te;ge;ve;eIouEu1;se;nt;pt;on",
	  "Unit": "true0:19;a14b12c0Od0Ne0Lf0Gg0Ch09in0Hjoule0k02l00mNnMoLpIqHsqCt7volts,w6y4z321;g,s;c,f,n;b,e2;a0Nb,d0Dears old,o1;tt0H;att0b;able4b3d,e2on1sp;!ne0;a2r0D;!l,sp;spo04; ft,uare 1;c0Id0Hf3i0Fkilo0Jm1ya0E;e0Mil1;e0li0H;eet0o0D;t,uart0;ascals,e2i1ou0Pt;c0Mnt0;rcent,t02;hms,uYz;an0JewtT;/s,b,e9g,i3l,m2p1,;h,s;!;!/h,cro5l1;e1li08;! pFs1;! 1;anEpD;g06s0B;gQter1;! 2s1;! 1;per second;b,i00m,u1x;men0x0;b,elvin0g,ilo2m1nR;!/h,ph,;byZgXmeter1;! p2s1;! p1;er1; hour;e1g,r0z;ct1rtz0;aXogQ;al2b,igAra1;in0m0;!l1;on0;a4emtPl2t1;,; oz,uid ou1;nce0;hrenheit0rad0;b,x1;abyH;eciCg,l,mA;arat0eAg,m9oulomb0u1;bic 1p0;c5d4fo3i2meAya1;rd0;nch0;ot0;eci2;enti1;me4;!,;lsius0nti1;g2li1me1;ter0;ram0;bl,y1;te0;c4tt1;os1;eco1;nd0;re0;!s",
	  "Organization": "true0:46;a3Ab2Qc2Ad21e1Xf1Tg1Lh1Gi1Dj19k17l13m0Sn0Go0Dp07qu06rZsStFuBv8w3y1;amaha,m0Xou1w0X;gov,tu2S;a3e1orld trade organizati41;lls fargo,st1;fie22inghou16;l1rner br3D;-m11gree31l street journ25m11;an halNeriz3Wisa,o1;dafo2Gl1;kswagLvo;bs,kip,n2ps,s1;a tod2Rps;es35i1;lev2Xted natio2Uv; mobi2Kaco bePd bMeAgi frida9h3im horto2Tmz,o1witt2W;shiba,y1;ota,s r Y;e 1in lizzy;b3carpen33daily ma2Xguess w2holli0rolling st1Ms1w2;mashing pumpki2Ouprem0;ho;ea1lack eyed pe3Fyrds;ch bo1tl0;ys;l2s1;co,la m12;efoni07us;a6e4ieme2Gnp,o2pice gir5ta1ubaru;rbucks,to2N;ny,undgard1;en;a2Rx pisto1;ls;few25insbu26msu1X;.e.m.,adiohead,b6e3oyal 1yan2X;b1dutch she4;ank;/max,aders dige1Ed 1vl32;bu1c1Uhot chili peppe2Klobst28;ll;c,s;ant2Vizno2F;an5bs,e3fiz24hilip morrBi2r1;emier27octer & gamb1Rudenti14;nk floyd,zza hut;psi28tro1uge08;br2Qchina,n2Q; 2ason1Xda2G;ld navy,pec,range juli2xf1;am;us;a9b8e5fl,h4i3o1sa,wa;kia,tre dame,vart1;is;ke,ntendo,ss0K;l,s;c,st1Etflix,w1; 1sweek;kids on the block,york08;a,c;nd1Us2t1;ional aca2Fo,we0Q;a,cYd0O;aAcdonald9e5i3lb,o1tv,yspace;b1Nnsanto,ody blu0t1;ley crue,or0O;crosoft,t1;as,subisO;dica3rcedes2talli1;ca;!-benz;id,re;'s,s;c's milk,tt13z1Y;'ore09a3e1g,ittle caesa1Ktd;novo,x1;is,mark; pres5-z-boy,bour party;atv,fc,kk,m1od1K;art;iffy lu0Lo3pmorgan1sa;! cha1;se;hnson & johns1Sy d1R;bm,hop,n1tv;c,g,te1;l,rpol; & m,asbro,ewlett-packaTi3o1sbc,yundai;me dep1n1J;ot;tac1zbollah;hi;eneral 6hq,l5mb,o2reen d0Iu1;cci,ns n ros0;ldman sachs,o1;dye1g0B;ar;axo smith kliZencore;electr0Im1;oto0V;a3bi,da,edex,i1leetwood mac,oGrito-l0A;at,nancial1restoV; tim0;cebook,nnie mae;b06sa,u3xxon1; m1m1;ob0H;!rosceptics;aiml0Ae5isney,o3u1;nkin donuts,po0Wran dur1;an;j,w j1;on0;a,f leppa3ll,p2r spiegZstiny's chi1;ld;eche mode,t;rd;aEbc,hBi9nn,o3r1;aigsli5eedence clearwater reviv1ossra05;al;!ca c5l4m1o0Ast05;ca2p1;aq;st;dplMgate;ola;a,sco1tigroup;! systems;ev2i1;ck fil-a,na daily;r0Hy;dbury,pital o1rl's jr;ne;aGbc,eCfAl6mw,ni,o2p,r1;exiteeWos;ei3mbardiJston 1;glo1pizza;be;ng;ack & deckFo2ue c1;roX;ckbuster video,omingda1;le; g1g1;oodriN;cht3e ge0n & jer2rkshire hathaw1;ay;ryH;el;nana republ3s1xt5y5;f,kin robbi1;ns;ic;bXcSdidRerosmith,ig,lLmFnheuser-busEol,ppleAr7s3t&t,v2y1;er;is,on;hland2s1;n,ociated F; o1;il;by4g2m1;co;os; compu2bee1;'s;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 4catel2t1;air;!-luce1;nt;jazeera,qae1;da;as;/dc,a3er,t1;ivisi1;on;demy of scienc0;es;ba,c",
	  "Demonym": "true0:16;1:13;a0Wb0Nc0Cd0Ae09f07g04h02iYjVkTlPmLnIomHpDqatari,rBs7t5u4v3wel0Rz2;am0Fimbabwe0;enezuel0ietnam0H;g9krai1;aiwThai,rinida0Iu2;ni0Qrkmen;a4cot0Ke3ingapoOlovak,oma0Tpa05udRw2y0X;edi0Kiss;negal0Br08;mo0uU;o6us0Lw2;and0;a3eru0Hhilipp0Po2;li0Ertugu06;kist3lesti1na2raguay0;ma1;ani;amiZi2orweP;caragu0geri2;an,en;a3ex0Mo2;ngo0Erocc0;cedo1la2;gasy,y08;a4eb9i2;b2thua1;e0Dy0;o,t02;azakh,eny0o2uwaiti;re0;a2orda1;ma0Bp2;anN;celandic,nd4r2sraeli,ta02vo06;a2iT;ni0qi;i0oneV;aiDin2ondur0unN;di;amDe2hanai0reek,uatemal0;or2rm0;gi0;i2ren7;lipino,n4;cuadoVgyp6ngliJsto1thiopi0urope0;a2ominXut4;niH;a9h6o4roa3ub0ze2;ch;ti0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el8o6r3ul2;gaG;aziBi2;ti2;sh;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;gent2me1;ine;ba1ge2;ri0;ni0;gh0r2;ic0;an",
	  "Possessive": "trueanyAh5its,m3noCo1sometBthe0yo1;ir1mselves;ur0;!s;i8y0;!se4;er1i0;mse2s;!s0;!e0;lf;o1t0;hing;ne",
	  "Currency": "true$,aud,bScQdLeurKfJgbp,hkd,iIjpy,kGlEp8r7s3usd,x2y1z0,,,,,,,,,,,;lotyS;en,uanR;af,of;h0t5;e0il5;k0q0;elM;iel,oubleLp,upeeL;e2ound st0;er0;lingI;n0soH;ceGn0;ies,y;e0i8;i,mpi7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!o8;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;ad,e0ny;nt1;aht,itcoin0;!s",
	  "City": "truea2Wb26c1Wd1Re1Qf1Og1Ih1Ai18jakar2Hk0Zl0Tm0Gn0Co0ApZquiYrVsLtCuBv8w3y1z0;agreb,uri1Z;ang1Te0okohama;katerin1Hrev34;ars3e2i0rocl3;ckl0Vn0;nipeg,terth0W;llingt1Oxford;aw;a1ern1Mi0;en2Hlni2Z;lenc2Uncouv0Gr2Gughn;lan bat0Dtrecht;a6bilisi,e5he4i3o2rondheim,u0;nVr0;in,ku;kyo,ronIulouC;anj23l13miso2Jra2A; haJssaloni0X;gucigalpa,hr2Ol av0L;i0llinn,mpe2Bngi07rtu;chu22n2MpT;a3e2h1kopje,t0ydney;ockholm,uttga12;angh1Fenzh1X;o0KvZ;int peters0Ul3n0ppo1F; 0ti1B;jo0salv2;se;v0z0Q;adU;eykjavik,i1o0;me,sario,t25;ga,o de janei17;to;a8e6h5i4o2r0ueb1Qyongya1N;a0etor24;gue;rt0zn24; elizabe3o;ls1Grae24;iladelph1Znom pe07oenix;r0tah tik19;th;lerJr0tr10;is;dessa,s0ttawa;a1Hlo;a2ew 0is;delTtaip0york;ei;goya,nt0Upl0Uv1R;a5e4i3o1u0;mb0Lni0I;nt0scH;evideo,real;l1Mn01skolc;delln,lbour0S;drid,l5n3r0;ib1se0;ille;or;chest0dalWi0Z;er;mo;a4i1o0vAy01;nd00s angel0F;ege,ma0nz,sbZverpo1;!ss0;ol; pla0Iusan0F;a5hark4i3laipeda,o1rak0uala lump2;ow;be,pavog0sice;ur;ev,ng8;iv;b3mpa0Kndy,ohsiu0Hra0un03;c0j;hi;ncheMstanb0zmir;ul;a5e3o0; chi mi1ms,u0;stI;nh;lsin0rakliG;ki;ifa,m0noi,va0A;bu0SiltD;alw4dan3en2hent,iza,othen1raz,ua0;dalaj0Gngzhou;bu0P;eUoa;sk;ay;es,rankfu0;rt;dmont4indhovU;a1ha01oha,u0;blRrb0Eshanbe;e0kar,masc0FugavpiJ;gu,je0;on;a7ebu,h2o0raioJuriti01;lo0nstanJpenhagNrk;gFmbo;enn3i1ristchur0;ch;ang m1c0ttagoL;ago;ai;i0lgary,pe town,rac4;ro;aHeBirminghWogoAr5u0;char3dap3enos air2r0sZ;g0sa;as;es;est;a2isba1usse0;ls;ne;silPtisla0;va;ta;i3lgrade,r0;g1l0n;in;en;ji0rut;ng;ku,n3r0sel;celo1ranquil0;la;na;g1ja lu0;ka;alo0kok;re;aBb9hmedabad,l7m4n2qa1sh0thens,uckland;dod,gabat;ba;k0twerp;ara;m5s0;terd0;am;exandr0maty;ia;idj0u dhabi;an;lbo1rh0;us;rg",
	  "Country": "true0:38;1:2L;a2Wb2Dc21d1Xe1Rf1Lg1Bh19i13j11k0Zl0Um0Gn05om3CpZqat1JrXsKtCu6v4wal3yemTz2;a24imbabwe;es,lis and futu2X;a2enezue31ietnam;nuatu,tican city;.5gTkraiZnited 3ruXs2zbeE;a,sr;arab emirat0Kkingdom,states2;! of am2X;k.,s.2; 27a.;a7haBimor-les0Bo6rinidad4u2;nis0rk2valu;ey,me2Xs and caic1T; and 2-2;toba1J;go,kel0Ynga;iw2Vji2nz2R;ki2T;aCcotl1eBi8lov7o5pa2Bri lanka,u4w2yr0;az2ed9itzerl1;il1;d2Qriname;lomon1Vmal0uth 2;afr2IkLsud2O;ak0en0;erra leoEn2;gapo1Wt maart2;en;negKrb0ychellY;int 2moa,n marino,udi arab0;hele24luc0mart1Z;epublic of ir0Com2Cuss0w2;an25;a3eHhilippinTitcairn1Ko2uerto riM;l1rtugE;ki2Bl3nama,pua new0Tra2;gu6;au,esti2;ne;aAe8i6or2;folk1Gth3w2;ay; k2ern mariana1B;or0M;caragua,ger2ue;!ia;p2ther18w zeal1;al;mib0u2;ru;a6exi5icro09o2yanm04;ldova,n2roc4zamb9;a3gol0t2;enegro,serrat;co;c9dagascZl6r4urit3yot2;te;an0i14;shall0Vtin2;ique;a3div2i,ta;es;wi,ys0;ao,ed00;a5e4i2uxembourg;b2echtenste10thu1E;er0ya;ban0Gsotho;os,tv0;azakh1De2iriba02osovo,uwait,yrgyz1D;eling0Jnya;a2erF;ma15p1B;c6nd5r3s2taly,vory coast;le of m19rael;a2el1;n,q;ia,oI;el1;aiSon2ungary;dur0Mg kong;aAermany,ha0Pibralt9re7u2;a5ern4inea2ya0O;!-biss2;au;sey;deloupe,m,tema0P;e2na0M;ce,nl1;ar;bTmb0;a6i5r2;ance,ench 2;guia0Dpoly2;nes0;ji,nl1;lklandTroeT;ast tim6cu5gypt,l salv5ngl1quatorial3ritr4st2thiop0;on0; guin2;ea;ad2;or;enmark,jibou4ominica3r con2;go;!n B;ti;aAentral african 9h7o4roat0u3yprQzech2; 8ia;ba,racao;c3lo2morPngo-brazzaville,okFsta r03te d'ivoiK;mb0;osD;i2ristmasF;le,na;republic;m2naTpe verde,yman9;bod0ero2;on;aFeChut00o8r4u2;lgar0r2;kina faso,ma,undi;azil,itish 2unei;virgin2; is2;lands;liv0nai4snia and herzegoviGtswaGuvet2; isl1;and;re;l2n7rmuF;ar2gium,ize;us;h3ngladesh,rbad2;os;am3ra2;in;as;fghaFlCmAn5r3ustr2zerbaijH;al0ia;genti2men0uba;na;dorra,g4t2;arct6igua and barbu2;da;o2uil2;la;er2;ica;b2ger0;an0;ia;ni2;st2;an",
	  "Region": "true0:1U;a20b1Sc1Id1Des1Cf19g13h10i0Xj0Vk0Tl0Qm0FnZoXpSqPrMsDtAut9v6w3y1zacatec22;o05u1;cat18kZ;a1est vi4isconsin,yomi14;rwick0shington1;! dc;er2i1;rgin1S;acruz,mont;ah,tar pradesh;a2e1laxca1DuscaA;nnessee,x1R;bas0Kmaulip1QsmJ;a6i4o2taf0Ou1ylh13;ffVrr00s0Y;me10no1Auth 1;cSdR;ber1Ic1naloa;hu0Sily;n2skatchew0Rxo1;ny; luis potosi,ta catari1I;a1hode7;j1ngp02;asth0Mshahi;inghai,u1;e1intana roo;bec,ensWreta0E;ara4e2rince edward1; isU;i,nnsylv1rnambu02;an14;!na;axa0Ndisha,h1klaho1Bntar1reg4x04;io;ayarit,eBo3u1;evo le1nav0L;on;r1tt0Rva scot0X;f6mandy,th1; 1ampton0;c3d2yo1;rk0;ako0Y;aroli0V;olk;bras0Xva01w1; 2foundland1;! and labrador;brunswick,hamp0jers1mexiJyork state;ey;a6i2o1;nta0Nrelos;ch3dlanBn2ss1;issippi,ouri;as geraGneso0M;igQoacQ;dhya,harasht04ine,ni3r1ssachusetts;anhao,y1;land;p1toba;ur;anca0e1incoln0ouis8;e1iH;ds;a1entucky,hul0A;ns08rnata0Dshmir;alis1iangxi;co;daho,llino2nd1owa;ia05;is;a2ert1idalEunA;ford0;mp0waii;ansu,eorgWlou5u1;an2erre1izhou,jarat;ro;ajuato,gdo1;ng;cester0;lori2uji1;an;da;sex;e4o2uran1;go;rs1;et;lawaErby0;a8ea7hi6o1umbrH;ahui4l3nnectic2rsi1ventry;ca;ut;iMorado;la;apEhuahua;ra;l8m1;bridge0peche;a5r4uck1;ingham0;shi1;re;emen,itish columb3;h2ja cal1sque,var2;iforn1;ia;guascalientes,l4r1;izo2kans1;as;na;a2ber1;ta;ba2s1;ka;ma",
	  "Place": "truea07b05cZdYeXfVgRhQiOjfk,kMlKmHneEoDp9que,rd,s8t5u4v3w0yyz;is1y0;!o;!c;a,t;pYsafa,t;e1he 0;bronx,hamptons;nn,x;ask,fo,oho,t,under6yd;a2e1h0;l,x;k,nnK;!cifX;kla,nt,rd;b1w eng0;land;!r;a1co,i0t,uc;dKnn;libu,nhattS;a0gw,hr;s,x;an0ul;!s;a0cn,da,ndianMst;!x;arlem,kg,nd,wy;a2re0;at 0enwich;britain,lak6;!y village;co,l0ra;!a;urope,verglad2;ak,en,fw,ist,own4xb;al4dg,gk,hina3l2o1r0;es;lo,nn;!t;town;!if;cn,e0kk,lvd,rooklyn;l air,verly hills;frica,lta,m5ntarct2r1sia,tl0ve;!ant1;ct0iz;ic0; oce0;an;ericas,s",
	  "WeekDay": "truefri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
	  "Month": "trueaBdec9feb7j2mar,nov9oct1sep0;!t8;!o8;an3u0;l1n0;!e;!y;!u1;!ru0;ary;!em0;ber;pr1ug0;!ust;!il",
	  "Date": "trueago,t2week0yesterd4; e0e0;nd;mr2o0;d0morrow;ay;!w",
	  "FirstName": "trueaKblair,cGdevFgabrieEhinaDjBk8l7m3nelly,quinn,re2sh0;ay,e0iloh;a,lby;g6ne;a1el0ina,org5;!okuh9;naia,r0;ion,lo;ashawn,uca;asCe1ir0rE;an;lsAnyat2rry;am0ess6ie,ude;ie,m5;ta;le;an,on;as2h0;arl0eyenne;ie;ey,sidy;lex2ndr1ubr0;ey;a,ea;is",
	  "LastName": "true0:9F;1:9V;2:9H;3:9X;4:9N;5:8J;6:9K;7:A0;8:9E;9:88;A:6E;B:77;C:6J;a9Ub8Lc7Kd6Xe6Rf6Dg5Vh58i54j4Pk45l3Nm2Rn2Eo26p1Nquispe,r17s0Ft05vVwOxNyGzD;aytsADhD;aDou,u;ng,o;aGeun7ZiDoshiA9un;!lD;diDmaz;rim,z;maDng;da,guc97mo6UsDzaB;aBhiA7;iao,u;aHeGiEoDright,u;jc8Sng;lDmm0nkl0sniewsB;liA1s3;b0iss,lt0;a5Rgn0lDng,tanabe;k0sh;aHeGiEoDukA;lk5roby5;dAllalDnogr2Zr0Zss0val37;ba,obos;lasEsel7N;lGn dFrg8EsEzD;qu7;ily9Oqu7silj9O;en b35ijk,yk;enzue95verde;aLeix1JhHi4j6ka3IoGrFsui,uD;om4ZrD;c4n0un1;an,embl8TynisB;dor95lst31m2rr9th;at5Mi7LoD;mErD;are6Ylaci64;ps3s0Y;hirAkah8Dnaka;a00chWeThPiNmKoItFuEvDzabo;en8Aobod34;ar7bot2lliv4zuB;aEein0oD;i67j3Lyan8V;l6rm0;kol5lovy5re6Psa,to,uD;ng,sa;iDy5Z;rn5tD;!h;l5YmDngh,rbu;mo6Do6J;aFeDimizu;hu,vchD;en7Cuk;la,r17;gu8mDoh,pulve8Trra4R;jDyD;on5;evi6Filtz,miDneid0roed0ulz,warz;dEtD;!z;!t;ar42h6ito,lFnDr2saBto,v2;ch7d0AtDz;a4Pe,os;as,ihAm3Zo0Q;aOeNiKoGuEyD;a66oo,u;bio,iz,sD;so,u;bEc7Bdrigue57g03j73mDosevelt,ssi,ta7Nux,w3Z;a4Be0O;ertsDins3;!on;bei0LcEes,vDzzo;as,e8;ci,hards3;ag4es,it0ut0y9;dFmEnDsmu7Zv5F;tan1;ir7os;ic,u;aSeLhJiGoErDut6;asad,if5Zochazk1W;lishc24pDrti62u55we66;e2Tov48;cEe09nD;as,to;as60hl0;aDillips;k,m,n5K;de3AetIna,rGtD;ersErovDtersC;!a,ic;en,on;eDic,ry,ss3;i8ra,tz,z;ers;h71k,rk0tEvD;ic,l3T;el,t2O;bJconnor,g2ClGnei5PrEzD;demir,turk;ella3MtDwe5N;ega,iz;iDof6GsC;vDyn1F;ei8;aPri1;aLeJguy1iFoDune44ym4;rodahl,vDwak;ak3Uik5otn56;eEkolDlsCx3;ic,ov6X;ls1miD;!n1;ils3mD;co42ec;gy,kaEray4varD;ro;jiDmu8shiD;ma;aXcVeQiPoIuD;lGnFrDssoli5T;atDpUr68;i,ov2;oz,te4B;d0l0;h4lIo0HrEsDza0Z;er,s;aFeEiDoz5r3Ete4B;!n6F;au,i8no,t4M;!l9;i2Rl0;crac5Ohhail5kke3Qll0;hmeGij0j2ElFndErci0ssiDyer19;!er;e3Bo2Z;n0Io;dAti;cartDlaughl6;hy;dMe6Dgnu5Ei0jer34kLmJnci59rFtEyD;er,r;ei,ic,su1N;iEkAqu9roqu6tinD;ez,s;a54c,nD;!o;a52mD;ad5;e5Oin1;rig4Ns1;aSeMiIoGuEyD;!nch;k2nDo;d,gu;mbarDpe2Rvr2;di;!nDu,yana1R;coln,dD;bDholm;erg;bed5TfeGhtFitn0kaEn6rDw2G;oy;!j;in1on1;bvDvD;re;iDmmy,rsCu,voie;ne,t11;aTennedy,h4iSlQnez46oJrGuEvar4woD;k,n;cerDmar58znets5;a,o2G;aDem0i2Zyeziu;sni3PvD;ch3U;bay4Frh0Jsk0TvaFwalDzl5;czDsB;yk;cFlD;!cDen3Q;huk;!ev2ic,s;e6uiveD;rt;eff0l2mu8nnun1;hn,lloe,minsBrEstra31to,ur,yDzl5;a,s0;j0GlsC;aMenLha2Pim0QoEuD;ng,r2;e2JhFnErge2Ju2NvD;anA;es,ss3;anEnsD;en,on,t3;nesDsC;en,s1;ki26s1;cGkob3RnsDrv06;en,sD;enDon;!s;ks3obs1;brahimAglesi3Ake4Ll0CnoZoneFshikEto,vanoD;u,v4A;awa;scu;aPeIitchcock,jaltal6oFrist46uD;!aDb0gh9ynh;m4ng;a23dz2fEjga2Sk,rDx3B;ak0Yvat;er,fm3B;iGmingw3NnErD;nand7re8;dDriks1;ers3;kkiEnD;on1;la,n1;dz2g1lvoLmJnsCqIrr0SsFuEyD;as36es;g1ng;anEhiD;mo0Q;i,ov08;ue;alaD;in1;rs1;aMeorgLheorghe,iJjonIoGrEuDw3;o,staf2Utierr7zm4;ayDg2iffitUub0;li1G;lub3Rme0JnD;calv9zale0I;aj,i;l,mDordaL;en7;iev3B;gnJlGmaFnd2No,rDs2Nuthi0;cDza;ia;ge;eaElD;agh0i,o;no;e,on;ab0erMiIjeldsted,lor9oGrFuD;cDent9ji3F;hs;an1Wiedm4;ntaDrt6st0urni0;na;lipEsD;ch0;ovD;!ic;hatAnandeVrD;arDei8;a,i;ov2;dHinste6riksCsDva0D;cob2ZpDtra2X;inoDosiM;za;en,s3;er,is3wards;aUeMiKjurhuJoHrisco0YuEvorakD;!oQ;arte,boEmitru,rDt2U;and,ic;is;g4he0Hmingu7n2Ord19tD;to;us;aDmitr29ssanayake;s,z; GbnaFlEmirDrvis1Lvi,w4;!ov2;gado,ic;th;bo0groot,jo03lEsilDvri9;va;a cruz,e3uD;ca;hl,mcevsBnErw6t2EviD;d5es,s;ieDku1S;ls1;ki;a05e00hNiobMlarkLoFrD;ivDuz;elli;h1lGntFop0rDs26x;byn,reD;a,ia;i,rer0O;em4liD;ns;!e;anu;aLeIiu,oGriDuJwe;stD;eDiaD;ns1;i,ng,uFwDy;!dhury;!n,onEuD;ng;!g;kEnDtterjee,v7;!d,g;ma,raboD;rty;bGl09ng2rD;eghetEnD;a,y;ti;an,ota0M;cer9lder3mpbeIrFstDvadi08;iDro;llo;doEt0uDvalho;so;so,zo;ll;es;a09eXhUiSlNoGrFyD;rne,tyD;qi;ank5iem,ooks,yant;gdan5nFruya,su,uchEyHziD;c,n5;ard;darDik;enD;ko;ov;aEondD;al;nEzD;ev2;co;ancRshwD;as;a01oDuiy4;umDwmD;ik;ckNethov1gu,ktLnJrD;gGisFnD;ascoDds1;ni;ha;er,mD;ann;gtDit7nett;ss3;asD;hi;er,ham;b2ch,ez,hMiley,kk0nHrDu0;bEnDua;es,i0;ieDosa;ri;dDik;a8yopadhyD;ay;ra;er;k,ng;ic;cosZdYguilXkhtXlSnJrGsl4yD;aEd6;in;la;aEsl4;an;ujo,ya;dFgelD;ovD;!a;ersGov,reD;aDjL;ss1;en;en,on,s3;on;eksejGiyGmeiFvD;ar7es;ez;da;ev;ar;ams;ta",
	  "MaleName": "true0:E5;1:D6;2:DO;3:AY;4:D2;5:CG;6:B6;7:CW;8:C8;9:DK;A:DL;B:A6;C:C2;aCObBLcAJd9He8Nf85g7Ih6Ui6Ej5Ek52l4Dm35n2To2Np2Fqu2Dr1Ls11t0Eu0Dv07wTxSyIzD;aDor0;cDh9Tkaria,n5W;hEkD;!aCM;ar5WeCL;aLoFuD;sDu2KvBY;if,uf;nFsEusD;ouf,sD;ef;aDg;s,tD;an,h0;hli,nBMssX;avi3ho4;aMeKiFoDyaC2;jcie8Clfgang,odrow,utD;!er;lDnst1;bFey,frD1lD;aBDiD;am,e,s;e9Fur;i,nde6sD;!l8t1;de,lErrAyD;l1ne;lDt3;aAAy;aGiDladimir,ojte7Z;cEha0kt69nceDrgAJva0;!nt;e3Vt67;lentDnA5;in4Y;ghBVlyss5Cnax,sm0;aXeShOiMoHrFuEyD;!l3ro7s1;n9r5C;avAWeDist0oy,um0;ntAOv5Zy;bGdFmDny;!as,mDoharu;aCTie,y;!d;iBy;mDt5;!my,othy;adFeoEia8GomD;!as;!do8P;!de5;dGrD;en9LrD;an9KeDy;ll,n9J;!dy;dgh,ha,iDnn3req,tsu4T;cB5ka;aTcotRePhLiJoHpenc3tDur1Vylve9Kzym1;anFeDua8D;f0phBTvDwa8C;e62ie;!islaw,l8;lom1nBFuD;leyma7ta;dDlBm1yabonga;!dhart7Bn8;aFeD;lDrm0;d1t1;h7Une,qu10un,wn,y7;aDbasti0k2Al4Rrg4Oth,ymoAU;m5n;!tD;!ie,y;lEmDnti2Eq5Bul;!ke5MmCu4;ik,vato7X;aYeUheAAiQoHuEyD;an,ou;b7NdEf5pe7SssD;!elBZ;ol3Fy;an,bKcJdIel,geHh0landBQmGnFry,sEyD;!ce;coe,s;!aAHnC;an,eo;l47r;e5Og3n8olfo,ri7A;co,ky;bCeB7;cDl8;ar6Pc6OhEkDo;!ey,ie,y;a99ie;gEid,ubAx,yDza;an1InY;gA8iD;naA4s;ch70fa4lHmGndFpha4sEul,wi2HyD;an,mo82;h7Vm5;alBDol2Uy;iATon;f,ph;ent2inD;cy,t1;aIeGhilFier72ol,rD;aka16eD;m,st1;!ip,lip;dALrcy,tD;ar,e3Gr1X;b4Kdra7Ft4ZulD;!o17;ctav3Fi3liv3mAFndrej,rHsEtDum9wA;is,to;aEc9k9m0vD;al5Z;ma;i,l53vL;aLeJiFoDu3A;aDel,j5l0ma0r3K;h,m;cEg4i49kD;!au,h7Uola;holBkDolB;!olB;al,d,il,ls1vD;il8Y;hom,thD;anDy;!a4i4;aZeWiMoHuEyD;l2Jr1;hamEr6XstaD;fa,p5C;ed,mH;di0We,hamFis2FntEsDussa;es,he;e,y;ad,ed,mD;ad,ed;cIgu4hai,kGlFnEtchD;!e6;a8Aik;house,o0Bt1;ae5YeA4olD;aj;ah,hDk8;aEeD;al,l;el,l;hElv2rD;le,ri6v2;di,met;ay0ck,hTjd,ks2DlRmadWnQrKs1tFuricExD;!imilian9Nwe6;e,io;eGhEiBtDus,yB;!eo,hew,ia;eDis;us,w;j,o;cHio,kGlFqu7Dsha6tDv2;iDy;!m,n;in,on;!el,oPus;!el9IoOus;iGu4;achDcolm,ik;ai,y;amEdi,eDmoud;sh;adDm5T;ou;aXeQiOlo3EoKuEyD;le,nd1;cGiFkDth3uk;aDe;!s;gi,s,z;as,iaD;no;g0nn7SrenFuDv8Jwe6;!iD;e,s;!zo;am,oD;n4r;a8Cevi,la5JnIoGst3thaFvD;eDi;nte;bo;!nD;!a6Sel;!ny;mFnErDur5Hwr5H;ry,s;ce,d1;ar,o5A;aLeGhaled,iDrist5Iu4Vy6X;er0p,rD;by,k,ollD;os;en0iGnDrmit,v44;!dEnDt5Z;e1Ay;a6ri59;r,th;cp3j5m66na73rEsp9them,uD;ri;im,l;a02eUiSoGuD;an,lDst2;en,iD;an,en,o,us;aNeLhnKkubBnIrGsD;eEhDi8Bue;!ua;!ph;dDge;an,i,on;!aDny;h,s,th5I;!ath5Hie,nC;!l,sDy;ph;o,qu2;an,mD;!mC;d,ffIrFsD;sDus;!e;a6BemEmai7oDry;me,ni0Y;i7Ty;!e60rD;ey,y;cKdAkImHrFsEvi3yD;!dAs1;on,p3;ed,od,rDv56;e5Nod;al,es4Xis1;a,e,oDub;b,v;k,ob,quD;es;aWbQchiPgNkeMlija,nuLonut,rJsFtDv0;ai,suD;ki;aEha0i7DmaDsac;el,il;ac,iaD;h,s;a,vinDw2;!g;k,nngu5S;!r;nacDor;io;ka;ai,rahD;im;aPeJoIuDyd9;be2KgGmber4WsD;eyEsD;a2e2;in,n;h,o;m3ra3Gsse2wa4B;aHctGitGnrErD;be2Dm0;iDy;!q11;or;th;bMlLmza,nKo,rFsEyD;a4JdA;an,s0;lGo50rFuDv8;hi4Gki,tD;a,o;is1y;an,ey;k,s;!im;ib;aVeRiPlenOoLrHuD;ilEsD;!tavo;herme,lerD;mo;aFegDov3;!g,orD;io,y;dy,h5Wnt;nzaErD;an,d1;lo;!n;lbe5Ano,oD;rg3Hvan5A;ne,oFrD;aDry;ld,rd5H;ffr8rge;brElArDv2;la28r3Sth,y;e3EielD;!i5;aTePiNlLorr0NrD;anFedDitz;!dCeDri2B;ri2A;cFkD;!ie,lD;in,yn;esLisD;!co,z36;etch3oD;yd;d4lDnn,onn;ip;deriFliEng,rnD;an06;pe,x;co;bi0di,hd;ar04dZfrYit0lSmKnHo2rFsteb0th0uge7vDymAzra;an,eD;ns,re36;gi,i0DnDrol,v2w2;est4Pie;oEriqDzo;ue;ch;aJerIiEmD;aIe2Z;lErD;!h0;!iD;o,s;s1y;nu4;be0Cd1iGliFmEt1viDwood;n,s;er,o;ot1Ys;!as,j4NsD;ha;a2en;!dCg9mGoEuEwD;a2Din;arD;do;o0Wu0W;l,nD;est;a01eRiOoHrGuFwEylD;an,l0;ay7ight;a7dl8nc0st2;ag0ew;minGnEri0ugDvydBy2D;!lB;!a2MnDov0;e6ie,y;go,iDykB;cDk;!k;armuEeDll1on,rk;go;id;anKj0lbeJmetri5nHon,rGsFvEwDxt3;ay7ey;en,in;hawn,mo0B;ek,ri0I;is,nDv3;is,y;rt;!dD;re;an,lNmLnKrGvD;e,iD;! lucDd;as,ca;en,iFne6rDyl;eDin,yl;l3Bn;n,o,us;!e,i4ny;iDon;an,en,on;e,lB;as;a09e07hYiar0lNoIrGuEyrD;il,us;rtD;!is;aDistob0U;ig;dy,lGnErD;ey,neli5y;or,rD;ad;by,e,in,l2t1;aIeFiDyK;fDnt;fo0Ft1;meEt5velaD;nd;nt;rFuEyD;!t1;de;enD;ce;aIeGrisEuD;ck;!tD;i0oph3;st3;er;d,rDs;b4leD;s,y;cDdric,s9;il;lGmer1rD;ey,lEro6y;ll;!os,t1;eb,v2;a07eZiVlaUoRrEuDyr1;ddy,rtK;aLeGiFuEyD;an,ce,on;ce,no;an,ce;nEtD;!t;dEtD;!on;an,on;dEndD;en,on;!foDl8y;rd;bErDyd;is;!by;i7ke;bFlEshD;al;al,lC;ek;nHrDshoi;at,nEtD;!r1C;aDie;rd14;!edict,iEjam2nC;ie,y;to;kaMlazs,nHrD;n8rDt;eDy;tt;ey;dDeE;ar,iD;le;ar17b0Vd0Rf0Pgust2hm0Mi0Jja0Il04m00nSputsiRrIsaHuFveEyDziz;a0kh0;ry;gust5st2;us;hi;aKchJiIjun,maHnFon,tDy0;hDu09;ur;av,oD;ld;an,nd0H;!el,ki;ie;ta;aq;as,dIgel0CtD;hoGoD;i7nD;!i09y;ne;ny;er,reDy;!as,i,s,w;iFmaDos;nu4r;el;ne,r,t;an,bePdAeJfHi,lGonFphXt1vD;aNin;on;so,zo;an,en;onTrD;edU;c,jaGksandFssaGxD;!andD;er,ru;ar,er;ndD;ro;rtN;ni;dAm9;ar;en;ad,eD;d,t;in;onD;so;aEi,olfDri0vik;!o;mDn;!a;dHeGraEuD;!bakr,lfazl;hDm;am;!l;allIelFoulaye,ulD;!lDrF;ah,o;! rD;ahm0;an;ah;av,on",
	  "Person": "trueashton kutchTbScNdLeJgastOhHinez,jFkEleDmCnettKoBp9r4s3t2v0;a0irgin maH;lentino rossi,n go3;aylor,heresa may,iger woods,yra banks;addam hussain,carlett johanssKlobodan milosevic,uC;ay romano,e3o1ush limbau0;gh;d stewart,nald0;inho,o;ese witherspoFilly;a0ipJ;lmIris hiltD;prah winfrFra;essiaen,itt romnEubarek;bron james,e;anye west,iefer sutherland,obe bryant;aime,effers8k rowli0;ng;alle ber0itlBulk hogan;ry;ff0meril lagasse,zekiel;ie;a0enzel washingt2ick wolf;lt1nte;ar1lint0;on;dinal wols1son0;! palm2;ey;arack obama,rock;er",
	  "Verb": "trueawak9born,cannot,fr8g7h5k3le2m1s0wors9;e8h3;ake sure,sg;ngth6ss6;eep tabs,n0;own;as0e2;!t2;iv1onna;ight0;en",
	  "PhrasalVerb": "true0:7E;1:72;2:7Q;3:7G;4:6V;5:7T;6:7I;7:6O;8:71;9:6P;A:5T;B:7C;C:7J;D:6Q;E:7L;F:7D;G:7S;H:46;a7Yb6Jc5Sd5Oe5Mf4Lg43h3Miron0j3Ik3Dl2Xm2Ln2Jo2Hp1ZquietDr1Ms0FtVuTvacuum 1wLyammerBzI;eroAip JonI;e0k0;by,up;aOeLhKiJorIrit5H;d 1k35;mp0n2Xpe0r7s7;eel Fip G;aJiIn2L;gh 0Crd0;n Fr 3S;it 60k7lk6rm 6Bsh 7Lt6Ov53;rgeBsI;e 9herA;aXeVhTiPoNrKuIype 68;ckArn I;d2in,o3Vup;aJiIot0y 2L;ckleDp G;ckDde 02;neDp Is4Q;d2o71up;ck KdJe Igh69me0p o0Kre0;aw3ba4d2in,up;e 60y 1;by,oC;ink Irow 6B;ba4ov8up;aIe 4Vll52;m 1r 01;ckBke Jlk I;ov8u53;aIba4d2in,o3Fup;ba4ft8p58w3;a0Nc0Me0Gh0Ci09l05m04n03o02pXquare WtOuMwI;earKiI;ngJtch I;aw3ba4o75; by;ck Iit 1m 1ss0;in,up;aNe10iMoKrIucH;aigh1ZiI;ke 6En3C;p Irm22;by,in,oC;nHr 1tc3V;cHmp0nd Ir6Xve6y 1;ba4d2up;d2oCup;arHeLiKlJrIurB;ingBuc7;a3Hit 47;l16n 1;e5Qll0;be4Prt0;ap 4Row F;ash 5Doke0;eep JiIow 9;c3Yp 1;in,oI;ff,v8;gn 4WngJt Iz7;d2o5up; al52le0;aKoIu4S;ot Iut0w 6B;aw3ba4f3IoC;cHdeAk56ve6;e Mll0nd LtI; Itl4G;d2in,o5upI;!on;aw3ba4d2in,o2Aup;o5to;al4Zout0rap4Z;il6v7;aTeQiPoLuI;b 4Sle0n Istl7;aIba4d2in5Ho3Tt3Bu3R;c29w3;ll Kot JuI;g2Vnd6;a29f32o5;arEin,o5;ng 51p6;aIel6inAnt0;c5Bd I;o33u0L;cHt0;aVeUiTlRoPrMsyc2JuI;ll Kt I;aIba4d2in,o1Rt3Fup;p3Kw3;ap3Jd2in,o5t3Dup;attleBess JiLoI;p 1;ah1Ron;iIp 5Fr3XurDwer 5F;nt0;ay4BuI;gAmp 9;ck Gg0leBn 9p48;el 4JncilA;c41ir 2Rn0ss KtJy I;ba4oC; d2c27;aw3ba4o1C;pIw3W;e3Vt F;arrowDerd0oI;d6teD;aQeNiMoKuI;ddl7lI;l 3I;cHp 1uth6ve I;al3Md2in,o5up;ss0x 1;asur7lJss I;a1Jup;t 9;ke Jn 9rIs1Sx0;k 9ry6;do,o47up;aVeTiOoIuck0;aMc3Gg LoIse0;k Ise3E;aft8ba4d2forw2Jin45ov8uI;nd8p;in,o0Q;d 9;e LghtKnJsIv1Y;ten G;e 1k 1; 1e36;arEd2;av1Mt 36velI; o3T;c7p 1sh ItchBugh6y20;in3To5;eJick6nock I;d2o3P;eIyA;l 2Pp I;aw3ba4d2fXin,o0Bto,up;aKoJuI;ic7mpA;ke30tD;c39zz 1;aUePiMoJuI;nkerDrry 1s0Z;lIneArse2W;d Ie 1;ba4d2fast,o05up;de Jt I;ba4on,up;aw3o5;aIlp0;d Kl 2Ar It 1;fIof;rom;in,oXu1H;cHm 1nJve Iz25;it,to;d Ig 2EkerK;d2in,o5;aWeQive Oloss 22oKrJunI; f0Q;in3Gow 2A; Iof 0Y;aJb1Dit,oIrEt0Su18;ff,n,v8;bo5ft8hOw3;aw3ba4d2in,oIup,w3;ff,n,ut;a1Dek0t I;aJb17d2oIrEup;ff,n,ut,v8;cJhIl1WrEt,w3;ead;ross;d aJnI;g 1;bo5;a0Ce05iWlSoOrKuI;cHel 1;k 1;eJighten IownBy 1;aw3oC;eIshe1N; 1z7;lKol I;aIwi1G;bo5rE;d 9low 1;aJeIip0;sh0;g 9ke0mIrI;e G;gPlNnLrJsIzzle0;h G;e Im 1;aw3ba4up;d0isI;h 1;e Il 19;aw3fN;ht ba4ure0;eNnJsI;s 1;cKd I;fIoC;or;e F;dWl 1;cMll Irm0t0W;ap05bKd2in,oJtI;hrough;ff,ut,v8;a4ehi20;e J;at0dge0nd Iy7;oCup;oKrI;ess 9op I;aw3bUin,o1D; 0Eubl7;aYhVlean 9oIross Fut 10;me LoJuntI; o1T;k 1l I;d2oC;aObNforLin,oKtJuI;nd8;ogeth8;ut,v8;th,wI;ard;a4y;pIrEw3;art;eIipA;ck FeI;r 1;lOncel0rLsKtch JveA; in;o1Cup;h Ft6;ry JvI;e 01;aw3o18;l ImD;aIba4d2o16up;rEw3;a0Ne0El07oYrNuI;bblKcklZil05lk 9ndlZrn 0Bst JtIy Gzz6;t F;in,o5up;e I;ov8;anReaPiIush6;ghMng I;aJba4d2forIin,o5up;th;bo5lIrEw3;ong;teI;n 1;k I;d2in,o5up;ch0;arPgDil 9n7oLssKttlJunce Ix F;aw3ba4;e 9; arE;k Ft 1;e 1;d2up; d2;d 1;aNeed0oIurt0;cKw I;aw3ba4d2o5up;ck;k I;in,oP;ck0nk0st6; oOaLef 1nd I;d2ov8up;er;up;r0t I;d2in,oIup;ff,ut;ff,nI;to;ck Oil0nKrgJsI;h F;ainBe F;g FkB; on;in,o5; o5;aw3d2o5up;ay;cRdNsk Kuction6; oC;ff;arEo5;ouI;nd;d I;d2oIup;ff,n;own;t G;o5up;ut",
	  "Modal": "truec5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to,a;ay,ight,ust;an,o0;uld",
	  "Adjective": "true0:7P;1:84;2:83;3:8A;4:7W;5:5S;6:4N;7:4O;8:58;9:6I;A:81;a6Wb6Gc63d5Je54f4Hg49h3Wi39j37k36l2Vm2Ln2Bo1Wp1Dquack,r12s0Ft07uMvJwByear5;arp0eFholeEiDoB;man5oBu6P;d6Rzy;despr7Ls5S;!sa7;eClBste2A;co1Nl o4W;!k5;aCiBola4M;b89ce versa,ol5H;ca3gabo6Gnilla;ltUnHpCrb5Msu4tterB;!mo7G; Eb1SpDsBti1M;ca7etBide dKtairs;!ti2;er,i3U;f36to da1;aLbeco75convin29deIeHfair,ivers4knGprecedVrEsCwB;iel3Nritt6A;i1XuB;pervis0spec3Y;eBu5;cognHgul6Tl6T;own;ndi2v64xpect0;cid0rB;!grou5ZsB;iz0tood;b7pp0Dssu6UuthorB;iz0;i26ra;aGeEhDi6AoCrB;i1oubl0us3M;geth8p,rp6Vuc67;ough4Wril33;en60l32mpBrr2X;o6Ati2;boo,lBn;ent0;aWcVeThSiQmug,nobbi3LoOpNqueami3LtFuBymb6H;bDi gener5DpBrpri6D;erBre0N;! dup8b,i2C;du0seq52;anda77eGiFrBunni2y3F;aightCiB;ki2p0; fBfB;or5K;ll,r5S;aBreotyp0;dfa6Cmi2;a55ec2Gir1Hlend6Cot on; call0le,mb8phist1XrBu0Vvi48;d6Ary;gnifica3nB;ce51g7;am2Re8ocki2ut;cBda1em5lfi32ni1Wpa6Jre6;o1Er42;at5Gient28reec5G;cr0me;aJeEiCoB;bu60tt51uQy4;ghtBv4;!-2Bf9;ar,bel,condi1du6Dfres5AlEpublic42sCtard0vB;ea26;is4CoB;lu1na3;aQe1Cuc4A;b5TciBllyi2;al,st;aOeLicayu6lac5Ropuli5QrCuB;bl5Jmp0n51;eGiDoB;!b07fu5RmiBp8;ne3si2;mCor,sBva1;ti6;a53e;ci5MmB;a0EiB;er,um;ac20rBti1;feAma2XpleBv38;xi2;rBst;allelDtB;-tiBi4;me;!ed;bLffJkIld fashion0nHpGrg1Eth8utFvB;al,erB;!all,niCt,wB;eiBrouB;ght;do0Ter,g2Qsi4B;en,posi1; boa5Og2Oli6;!ay; gua5MbBli6;eat;eDsB;cBer0Eole1;e6u3O;d2Xse;aJeIiHoBua4X;nFrCtB;ab7;thB;!eB;rn;chala3descri58stop;ght5;arby,cessa44ighbor5xt;k0usia1A;aIeGiDoBultip7;bi7derBl0Vnth5ot,st;a1n;nBx0;dblo0RiaBor;tu37;ande3Qdi4NnaBre;ci2;cBgenta,in,j01keshift,le,mmoth,ny,sculi6;ab33ho;aKeFiCoBu15;uti14vi2;mCteraB;l,te;it0;ftEgBth4;al,eCitiB;ma1;nda3K;!-0C;ngu3Zst,tt8;ap1Xind5no0A;agg0uB;niMstifi0veni7;de4gno4Klleg4mQnEpso 20rB;a1rB;eleBita0J;va3; KaJbr0corIdGfluenQiQnFsEtCviB;go0Fti2;aAen3SoxB;ic3B;a6i2Vul0D;a1er,oce3;iCoB;or;reA;deq3Qppr33;fBsitu,vitro;ro3;mFpB;arDerfeAoBrop8;li1rtB;a3ed;ti4;eBi0S;d2Vn3C;aIeFiDoBumdr3I;ne36ok0rrBs08ur5;if2Z;ghfalut1QspB;an2X;aClB;liYpf9;li2;lEnDrB;d04roB;wi2;dy;f,low0;ainf9ener2Oiga24lHoGraDuB;ilBng ho;ty;cCtB;ef9is;ef9;ne,od;ea2Iob4;aTeNinMlKoFrB;a1VeDoz1MustB;raB;ti2;e2Gq10tf9;oDrB; keeps,eBm8tuna1;g03ign;liB;sh;aBue3;g31tte1P;al,i1;dFmCrB;ti7;a7ini6;ne;le; up;bl0i3l27r Cux,voB;ri1uri1;oBreac1E;ff;aLfficie3lKmHnFreAthere4veExB;aAcess,pe1QtraCuB;be2Nl0E;!va1E;n,ryday; BcouraEti0O;rou1sui1;erCiB;ne3;gi2;abo23dMe17i1;g8sB;t,ygB;oi2;er;aReJiDoBrea14ue;mina3ne,ubB;le,tf9;dact1Bfficu1OsCvB;er1K;creDeas0gruntl0hone1FordCtB;a3ressM;er5;et; HadpGfFgene1PliDrang0spe1PtCvoB;ut;ail0ermin0;be1Mca1ghB;tf9;ia3;an;facto;i5magBngeroUs0G;ed,i2;ly;ertaMhief,ivil,oDrB;aBowd0u0G;mp0vZz0;loImGnCrrBve0P;eAu1I;cre1fu0LgrDsCtB;empo0Dra0E;ta3;ue3;mer08pleB;te,x;ni4ss4;in;aNeIizarHlFoCrB;and new,isk,okN;gCna fiUttom,urgeoB;is;us;ank,indB;!i2;re;autif9hiDloCnBst,yoD;eUt;v0w;nd;ul;ckCnkru0WrrB;en;!wards; priori,b0Mc0Jd09fra08g04h03lYmWntiquVppSrMsIttracti06utheHvEwB;aCkB;wa0T;ke,re;ant garCerB;age;de;ntU;leep,piDsuDtonB;isB;hi2;ri2;ab,bitEroDtiB;fiB;ci4;ga3;raB;ry;are3etiNrB;oprB;ia1;at0;aJuB;si2;arEcohCeBiIl,oof;rt;olB;ic;mi2;ead;ainDgressiConiB;zi2;ve;st;id; IeGuFvB;aCerB;se;nc0;ed;lt;pt,qB;ua1;hoc,infinitB;um;cuCtu4u1;al;ra1;erLlKoIruHsCuB;nda3;e3oCtraA;ct;lu1rbi2;ng;te;pt;aBve;rd;aze,e;ra3;nt",
	  "Comparable": "true0:41;1:4I;2:45;3:2Y;4:4B;5:3X;a4Ob44c3Od3De35f2Rg2Fh24i1Vj1Uk1Rl1Jm1Dn17o15p0Vqu0Tr0KsTtMuIvFw7y6za13;ell27ou4;aBe9hi1Yi7r6;o4y;ck0Ode,l6n1ry,se;d,y;a6i4Mt;k,ry;n1Tr6sK;m,y;a7e6ulgar;nge5rda2xi4;g9in,st;g0n6pco3Mse5;like0t6;i1r6;ue;aAen9hi8i7ough,r6;anqu2Oen1ue;dy,g3Sme0ny,r09;ck,n,rs2P;d40se;ll,me,rt,s6wd45;te5;aVcarUeThRiQkin0FlMmKoHpGqua1FtAu7w6;eet,ift;b7dd13per0Gr6;e,re2H;sta2Ft3;aAe9iff,r7u6;pXr1;a6ict,o4;ig3Fn0U;a1ep,rn;le,rk;e22i3Fright0;ci28ft,l7o6re,ur;n,thi4;emn,id;a6el0ooth;ll,rt;e8i6ow,y;ck,g35m6;!y;ek,nd3D;ck,l0mp3;a6iTort,rill,y;dy,ll0Xrp;cu0Rve0Rxy;ce,ed,y;d,fe,int0l1Vv14;aBe9i8o6ude;mantic,o1Isy,u6;gh,nd;ch,pe,tzy;a6d,mo0H;dy,l;gg7ndom,p6re,w;id;ed;ai2i6;ck,et;aEhoDi1QlCoBr8u6;ny,r6;e,p3;egna2ic7o6;fouYud;ey,k0;li04or,te1B;ain,easa2;ny;in5le;dd,f6i0ld,ranQ;fi10;aAe8i7o6;b3isy,rm15sy;ce,mb3;a6w;r,t;ive,rr01;aAe8ild,o7u6;nda19te;ist,o1;a6ek,llX;n,s0ty;d,tuQ;aBeAi9o6ucky;f0Un7o1Du6ve0w17y0T;d,sy;e0g;g1Tke0tt3ve0;an,wd;me,r6te;ge;e7i6;nd;en;ol0ui1P;cy,ll,n6;sBt6;e6ima8;llege2r6;es7media6;te;ti4;ecu6ta2;re;aEeBiAo8u6;ge,m6ng1R;b3id;ll6me0t;ow;gh,l0;a6f04sita2;dy,v6;en0y;nd1Hppy,r6te5;d,sh;aGenFhDiClBoofy,r6;a9e8is0o6ue1E;o6ss;vy;at,en,y;nd,y;ad,ib,ooI;a2d1;a6o6;st0;t3uiY;u1y;aIeeb3iDlat,oAr8u6;ll,n6r14;!ny;aHe6iend0;e,sh;a7r6ul;get5mG;my;erce8n6rm;an6e;ciC;! ;le;ir,ke,n0Fr,st,t,ulA;aAerie,mp9sse7v6xtre0Q;il;nti6;al;ty;r7s6;tern,y;ly,th0;aFeCi9r7u6;ll,mb;u6y;nk;r7vi6;ne;e,ty;a6ep,nD;d6f,r;!ly;mp,pp03rk;aHhDlAo8r7u6;dd0r0te;isp,uel;ar6ld,mmon,ol,st0ward0zy;se;e6ou1;a6vW;n,r;ar8e6il0;ap,e6;sy;mi4;gey,lm8r6;e5i4;ful;!i4;aNiLlIoEr8u6;r0sy;ly;aAi7o6;ad,wn;ef,g7llia2;nt;ht;sh,ve;ld,r7un6;cy;ed,i4;ng;a7o6ue;nd,o1;ck,nd;g,tt6;er;d,ld,w1;dy;bsu9ng8we6;so6;me;ry;rd",
	  "TextOrdinal": "truebGeDf9hundredHmGnin7qu6s4t0zeroH;enGh1rFwe0;lfFn9;ir0ousandE;d,t4;e0ixt9;cond,ptAvent8xtA;adr9int9;et0th;e6ie8;i2o0;r0urt3;tie5;ft1rst;ight0lev1;e0h,ie2;en1;illion0;th",
	  "Cardinal": "truebHeEf8hundred,mHnineAone,qu6s4t0zero;en,h2rGw0;e0o;lve,n8;irt9ousandEree;e0ix5;pt1ven4xt1;adr0int0;illion;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illion0;!s",
	  "Expression": "truea02b01dXeVfuck,gShLlImHnGoDpBshAtsk,u7voi04w3y0;a1eLu0;ck,p;!a,hoo,y;h1ow,t0;af,f;e0oa;e,w;gh,h0;! 0h,m;huh,oh;eesh,hh,it;ff,hew,l0sst;ease,z;h1o0w,y;h,o,ps;!h;ah,ope;eh,mm;m1ol0;!s;ao,fao;a4e2i,mm,oly1urr0;ah;! mo6;e,ll0y;!o;ha0i;!ha;ah,ee,o0rr;l0odbye;ly;e0h,t cetera,ww;k,p;'oh,a0uh;m0ng;mit,n0;!it;ah,oo,ye; 1h0rgh;!em;la",
	  "Adverb": "truea08by 06d02eYfShQinPjustOkinda,mMnJoEpCquite,r9s5t2up1very,well,ye0;p,s; to,wards5;h1iny bit,o0wiO;o,t6ward;en,us;everal,o0uch;!me1rt0; of;hYtimes,w09;a1e0;alT;ndomSthN;ar excellDer0oint blank; Nhaps;f3n0;ce0ly;! 0;ag02moW; courIten;ewKo0; longEt 0;onIwithstanding;aybe,eanwhiAore0;!ovB;! aboU;deed,steV;en0;ce;or2u0;lArther0;!moJ; 0ev3;examp0good,suH;le;n1v0;er; mas0ough;se;e0irect1; 1finite0;ly;ju8trop;far,n0;ow; DbroCd nauseam,gBl6ny3part,s2t 0w4;be6l0mo6wor6;arge,ea5; soon,ide;mo1w0;ay;re;l 1mo0one,ready,so,ways;st;b1t0;hat;ut;ain;ad;lot,posteriori",
	  "Determiner": "trueaAboth,d8e5few,l3mu7neiCown,plenty,some,th2various,wh0;at0ich0;evB;at,e3is,ose;a,e0;!ast,s;a1i6l0very;!se;ch;e0u;!s;!n0;!o0y;th0;er"
	};

	var seq = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	    cache$1 = seq.split("").reduce(function (n, o, e) {
	  return n[o] = e, n;
	}, {}),
	    toAlphaCode = function toAlphaCode(n) {
	  if (void 0 !== seq[n]) return seq[n];
	  var o = 1,
	      e = 36,
	      t = "";

	  for (; n >= e; n -= e, o++, e *= 36) {
	  }

	  for (; o--;) {
	    var _o = n % 36;

	    t = String.fromCharCode((_o < 10 ? 48 : 55) + _o) + t, n = (n - _o) / 36;
	  }

	  return t;
	},
	    fromAlphaCode = function fromAlphaCode(n) {
	  if (void 0 !== cache$1[n]) return cache$1[n];
	  var o = 0,
	      e = 1,
	      t = 36,
	      r = 1;

	  for (; e < n.length; o += t, e++, t *= 36) {
	  }

	  for (var _e = n.length - 1; _e >= 0; _e--, r *= 36) {
	    var _t = n.charCodeAt(_e) - 48;

	    _t > 10 && (_t -= 7), o += _t * r;
	  }

	  return o;
	};

	var encoding = {
	  toAlphaCode: toAlphaCode,
	  fromAlphaCode: fromAlphaCode
	},
	    symbols = function symbols(n) {
	  var o = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");

	  for (var e = 0; e < n.nodes.length; e++) {
	    var t = o.exec(n.nodes[e]);

	    if (!t) {
	      n.symCount = e;
	      break;
	    }

	    n.syms[encoding.fromAlphaCode(t[1])] = encoding.fromAlphaCode(t[2]);
	  }

	  n.nodes = n.nodes.slice(n.symCount, n.nodes.length);
	};

	var indexFromRef = function indexFromRef(n, o, e) {
	  var t = encoding.fromAlphaCode(o);
	  return t < n.symCount ? n.syms[t] : e + t + 1 - n.symCount;
	},
	    toArray = function toArray(n) {
	  var o = [],
	      e = function e(t, r) {
	    var s = n.nodes[t];
	    "!" === s[0] && (o.push(r), s = s.slice(1));
	    var c = s.split(/([A-Z0-9,]+)/g);

	    for (var _s = 0; _s < c.length; _s += 2) {
	      var u = c[_s],
	          i = c[_s + 1];
	      if (!u) continue;
	      var l = r + u;

	      if ("," === i || void 0 === i) {
	        o.push(l);
	        continue;
	      }

	      var f = indexFromRef(n, i, t);
	      e(f, l);
	    }
	  };

	  return e(0, ""), o;
	},
	    unpack = function unpack(n) {
	  var o = {
	    nodes: n.split(";"),
	    syms: [],
	    symCount: 0
	  };
	  return n.match(":") && symbols(o), toArray(o);
	};

	var unpack_1$1 = unpack,
	    unpack_1$1$1 = function unpack_1$1$1(n) {
	  var o = n.split("|").reduce(function (n, o) {
	    var e = o.split("");
	    return n[e[0]] = e[1], n;
	  }, {}),
	      e = {};
	  return Object.keys(o).forEach(function (n) {
	    var t = unpack_1$1(o[n]);
	    "true" === n && (n = !0);

	    for (var _o2 = 0; _o2 < t.length; _o2++) {
	      var r = t[_o2];
	      !0 === e.hasOwnProperty(r) ? !1 === Array.isArray(e[r]) ? e[r] = [e[r], n] : e[r].push(n) : e[r] = n;
	    }
	  }), e;
	};

	var efrtUnpack_min = unpack_1$1$1;

	//words that can't be compressed, for whatever reason
	var misc = {
	  // numbers
	  '20th century fox': 'Organization',
	  // '3m': 'Organization',
	  '7 eleven': 'Organization',
	  'motel 6': 'Organization',
	  g8: 'Organization',
	  vh1: 'Organization',
	  q1: 'Date',
	  q2: 'Date',
	  q3: 'Date',
	  q4: 'Date',
	  her: ['Possessive', 'Pronoun'],
	  his: ['Possessive', 'Pronoun'],
	  their: ['Possessive', 'Pronoun'],
	  themselves: ['Possessive', 'Pronoun'],
	  your: ['Possessive', 'Pronoun'],
	  our: ['Possessive', 'Pronoun'],
	  my: ['Possessive', 'Pronoun'],
	  its: ['Possessive', 'Pronoun']
	};

	var fancy = {
	  Unit: function Unit(lex, w) {
	    lex[w] = ['Abbreviation', 'Unit'];
	  },
	  Cardinal: function Cardinal(lex, w) {
	    lex[w] = ['TextValue', 'Cardinal'];
	  },
	  TextOrdinal: function TextOrdinal(lex, w) {
	    lex[w] = ['Ordinal', 'TextValue'];
	    lex[w + 's'] = ['TextValue', 'Fraction']; // add 'millionths'
	  },
	  // add plural/singular forms
	  Singular: function Singular(lex, w, world) {
	    lex[w] = 'Singular';
	    var plural = world.transforms.toPlural(w, world);
	    lex[plural] = lex[plural] || 'Plural';
	  },
	  // conjugate these verbs
	  Infinitive: function Infinitive(lex, w, world) {
	    lex[w] = 'Infinitive';
	    var conj = world.transforms.conjugate(w, world);
	    var tags = Object.keys(conj);

	    for (var i = 0; i < tags.length; i++) {
	      var str = conj[tags[i]];
	      lex[str] = lex[str] || tags[i]; // only if it's safe
	    }
	  },
	  // conjugate other Adjectival forms
	  Comparable: function Comparable(lex, w, world) {
	    lex[w] = 'Comparable';
	    var conj = world.transforms.adjectives(w);
	    var tags = Object.keys(conj);

	    for (var i = 0; i < tags.length; i++) {
	      var word = conj[tags[i]];
	      lex[word] = lex[word] || tags[i]; // only if it's safe
	    }
	  },
	  //conjugate phrasal-verbs
	  PhrasalVerb: function PhrasalVerb(lex, w, world) {
	    // whole thing
	    lex[w] = ['PhrasalVerb', 'Infinitive']; //add original form

	    var words = w.split(' '); // lex[words[0]] = lex[words[0]] || 'Infinitive'
	    // //conjugate first word

	    var conj = world.transforms.conjugate(words[0], world);
	    var tags = Object.keys(conj);

	    for (var i = 0; i < tags.length; i++) {
	      var str = conj[tags[i]] + ' ' + words[1];
	      lex[str] = lex[str] || ['PhrasalVerb', tags[i]];
	      world.hasCompound[conj[tags[i]]] = true;
	    }
	  },
	  // inflect our demonyms - 'germans'
	  Demonym: function Demonym(lex, w, world) {
	    lex[w] = 'Demonym';
	    var plural = world.transforms.toPlural(w, world);
	    lex[plural] = lex[plural] || ['Demonym', 'Plural']; // only if it's safe
	  }
	}; // let a user explode their lexicon, too

	var addWords = function addWords(wordsObj, lex, world) {
	  Object.keys(wordsObj).forEach(function (word) {
	    var tag = wordsObj[word]; // abbreviation-words are used in our tokenizer

	    if (tag === 'Abbreviation' || tag === 'Unit') {
	      world.cache.abbreviations[word] = true;
	    } // cache multi-words


	    var multi = word.split(' ');

	    if (multi.length > 1) {
	      world.hasCompound[multi[0]] = true;
	    } // do some ad-hoc work before adding it


	    if (fancy[tag] !== undefined) {
	      fancy[tag](lex, word, world);
	      return;
	    } //set it in our lexicon, basic


	    if (lex[word] === undefined) {
	      lex[word] = tag;
	      return;
	    } // if we already have that word


	    if (typeof lex[word] === 'string') {
	      lex[word] = [lex[word]];
	    }

	    if (typeof tag === 'string') {
	      lex[word].push(tag);
	    } else {
	      lex[word] = lex[word].concat(tag);
	    }
	  });
	}; // we do some ad-hoc stuff here, building-up our word-list


	var buildOut = function buildOut(world) {
	  //our bag of words
	  var lexicon = Object.assign({}, misc); // start adding words to the lex

	  Object.keys(_data).forEach(function (tag) {
	    var wordsObj = efrtUnpack_min(_data[tag]); // this part sucks

	    Object.keys(wordsObj).forEach(function (w) {
	      wordsObj[w] = tag;
	    });
	    addWords(wordsObj, lexicon, world);
	  }); // console.log(Object.keys(lexicon).length)

	  return lexicon;
	};

	var unpack_1 = {
	  buildOut: buildOut,
	  addWords: addWords
	};

	// add words from plurals and conjugations data
	var addIrregulars = function addIrregulars(world) {
	  //add irregular plural nouns
	  var nouns = world.irregulars.nouns;
	  var words = Object.keys(nouns);

	  for (var i = 0; i < words.length; i++) {
	    var w = words[i];
	    world.words[w] = 'Singular';
	    world.words[nouns[w]] = 'Plural';
	  } // add irregular verb conjugations


	  var verbs = world.irregulars.verbs;
	  var keys = Object.keys(verbs);

	  var _loop = function _loop(_i) {
	    var inf = keys[_i]; //add only if it it's safe...

	    world.words[inf] = world.words[inf] || 'Infinitive';
	    var forms = world.transforms.conjugate(inf, world);
	    forms = Object.assign(forms, verbs[inf]); //add the others

	    Object.keys(forms).forEach(function (tag) {
	      world.words[forms[tag]] = world.words[forms[tag]] || tag; // lexicon should prefer other tags, over participle

	      if (world.words[forms[tag]] === 'Participle') {
	        world.words[forms[tag]] = tag;
	      }
	    });
	  };

	  for (var _i = 0; _i < keys.length; _i++) {
	    _loop(_i);
	  }
	};

	var addIrregulars_1 = addIrregulars;

	//nouns with irregular plural/singular forms
	//used in noun.inflect, and also in the lexicon.
	var plurals = {
	  addendum: 'addenda',
	  alga: 'algae',
	  alumna: 'alumnae',
	  alumnus: 'alumni',
	  analysis: 'analyses',
	  antenna: 'antennae',
	  appendix: 'appendices',
	  avocado: 'avocados',
	  axis: 'axes',
	  bacillus: 'bacilli',
	  barracks: 'barracks',
	  beau: 'beaux',
	  bus: 'buses',
	  cactus: 'cacti',
	  chateau: 'chateaux',
	  child: 'children',
	  circus: 'circuses',
	  clothes: 'clothes',
	  corpus: 'corpora',
	  criterion: 'criteria',
	  curriculum: 'curricula',
	  database: 'databases',
	  deer: 'deer',
	  diagnosis: 'diagnoses',
	  echo: 'echoes',
	  embargo: 'embargoes',
	  epoch: 'epochs',
	  foot: 'feet',
	  formula: 'formulae',
	  fungus: 'fungi',
	  genus: 'genera',
	  goose: 'geese',
	  halo: 'halos',
	  hippopotamus: 'hippopotami',
	  index: 'indices',
	  larva: 'larvae',
	  leaf: 'leaves',
	  libretto: 'libretti',
	  loaf: 'loaves',
	  man: 'men',
	  matrix: 'matrices',
	  memorandum: 'memoranda',
	  modulus: 'moduli',
	  mosquito: 'mosquitoes',
	  mouse: 'mice',
	  // move: 'moves',
	  nebula: 'nebulae',
	  nucleus: 'nuclei',
	  octopus: 'octopi',
	  opus: 'opera',
	  ovum: 'ova',
	  ox: 'oxen',
	  parenthesis: 'parentheses',
	  person: 'people',
	  phenomenon: 'phenomena',
	  prognosis: 'prognoses',
	  quiz: 'quizzes',
	  radius: 'radii',
	  referendum: 'referenda',
	  rodeo: 'rodeos',
	  sex: 'sexes',
	  shoe: 'shoes',
	  sombrero: 'sombreros',
	  stimulus: 'stimuli',
	  stomach: 'stomachs',
	  syllabus: 'syllabi',
	  synopsis: 'synopses',
	  tableau: 'tableaux',
	  thesis: 'theses',
	  thief: 'thieves',
	  tooth: 'teeth',
	  tornado: 'tornados',
	  tuxedo: 'tuxedos',
	  vertebra: 'vertebrae' // virus: 'viri',
	  // zero: 'zeros',

	};

	// a list of irregular verb conjugations
	// used in verbs().conjugate()
	// but also added to our lexicon
	//use shorter key-names
	var mapping$1 = {
	  g: 'Gerund',
	  prt: 'Participle',
	  perf: 'PerfectTense',
	  pst: 'PastTense',
	  fut: 'FuturePerfect',
	  pres: 'PresentTense',
	  pluperf: 'Pluperfect',
	  a: 'Actor'
	}; // '_' in conjugations is the infinitive form
	// (order matters, to the lexicon)

	var conjugations = {
	  act: {
	    a: '_or'
	  },
	  ache: {
	    pst: 'ached',
	    g: 'aching'
	  },
	  age: {
	    g: 'ageing',
	    pst: 'aged',
	    pres: 'ages'
	  },
	  aim: {
	    a: '_er',
	    g: '_ing',
	    pst: '_ed'
	  },
	  arise: {
	    prt: '_n',
	    pst: 'arose'
	  },
	  babysit: {
	    a: '_ter',
	    pst: 'babysat'
	  },
	  ban: {
	    a: '',
	    g: '_ning',
	    pst: '_ned'
	  },
	  be: {
	    a: '',
	    g: 'am',
	    prt: 'been',
	    pst: 'was',
	    pres: 'is'
	  },
	  beat: {
	    a: '_er',
	    g: '_ing',
	    prt: '_en'
	  },
	  become: {
	    prt: '_'
	  },
	  begin: {
	    g: '_ning',
	    prt: 'begun',
	    pst: 'began'
	  },
	  being: {
	    g: 'are',
	    pst: 'were',
	    pres: 'are'
	  },
	  bend: {
	    prt: 'bent'
	  },
	  bet: {
	    a: '_ter',
	    prt: '_'
	  },
	  bind: {
	    pst: 'bound'
	  },
	  bite: {
	    g: 'biting',
	    prt: 'bitten',
	    pst: 'bit'
	  },
	  bleed: {
	    pst: 'bled',
	    prt: 'bled'
	  },
	  blow: {
	    prt: '_n',
	    pst: 'blew'
	  },
	  boil: {
	    a: '_er'
	  },
	  brake: {
	    prt: 'broken'
	  },
	  "break": {
	    pst: 'broke'
	  },
	  breed: {
	    pst: 'bred'
	  },
	  bring: {
	    pst: 'brought',
	    prt: 'brought'
	  },
	  broadcast: {
	    pst: '_'
	  },
	  budget: {
	    pst: '_ed'
	  },
	  build: {
	    pst: 'built',
	    prt: 'built'
	  },
	  burn: {
	    prt: '_ed'
	  },
	  burst: {
	    prt: '_'
	  },
	  buy: {
	    pst: 'bought',
	    prt: 'bought'
	  },
	  can: {
	    a: '',
	    fut: '_',
	    g: '',
	    pst: 'could',
	    perf: 'could',
	    pluperf: 'could',
	    pres: '_'
	  },
	  "catch": {
	    pst: 'caught'
	  },
	  choose: {
	    g: 'choosing',
	    prt: 'chosen',
	    pst: 'chose'
	  },
	  cling: {
	    prt: 'clung'
	  },
	  come: {
	    prt: '_',
	    pst: 'came',
	    g: 'coming'
	  },
	  compete: {
	    a: 'competitor',
	    g: 'competing',
	    pst: '_d'
	  },
	  cost: {
	    pst: '_'
	  },
	  creep: {
	    prt: 'crept'
	  },
	  cut: {
	    prt: '_'
	  },
	  deal: {
	    pst: '_t',
	    prt: '_t'
	  },
	  develop: {
	    a: '_er',
	    g: '_ing',
	    pst: '_ed'
	  },
	  die: {
	    g: 'dying',
	    pst: '_d'
	  },
	  dig: {
	    g: '_ging',
	    pst: 'dug',
	    prt: 'dug'
	  },
	  dive: {
	    prt: '_d'
	  },
	  "do": {
	    pst: 'did',
	    pres: '_es'
	  },
	  draw: {
	    prt: '_n',
	    pst: 'drew'
	  },
	  dream: {
	    prt: '_t'
	  },
	  drink: {
	    prt: 'drunk',
	    pst: 'drank'
	  },
	  drive: {
	    g: 'driving',
	    prt: '_n',
	    pst: 'drove'
	  },
	  drop: {
	    g: '_ping',
	    pst: '_ped'
	  },
	  eat: {
	    a: '_er',
	    g: '_ing',
	    prt: '_en',
	    pst: 'ate'
	  },
	  edit: {
	    pst: '_ed',
	    g: '_ing'
	  },
	  egg: {
	    pst: '_ed'
	  },
	  fall: {
	    prt: '_en',
	    pst: 'fell'
	  },
	  feed: {
	    prt: 'fed',
	    pst: 'fed'
	  },
	  feel: {
	    a: '_er',
	    pst: 'felt'
	  },
	  fight: {
	    pst: 'fought',
	    prt: 'fought'
	  },
	  find: {
	    pst: 'found'
	  },
	  flee: {
	    g: '_ing',
	    prt: 'fled'
	  },
	  fling: {
	    prt: 'flung'
	  },
	  fly: {
	    prt: 'flown',
	    pst: 'flew'
	  },
	  forbid: {
	    pst: 'forbade'
	  },
	  forget: {
	    g: '_ing',
	    prt: 'forgotten',
	    pst: 'forgot'
	  },
	  forgive: {
	    g: 'forgiving',
	    prt: '_n',
	    pst: 'forgave'
	  },
	  free: {
	    a: '',
	    g: '_ing'
	  },
	  freeze: {
	    g: 'freezing',
	    prt: 'frozen',
	    pst: 'froze'
	  },
	  get: {
	    pst: 'got',
	    prt: 'gotten'
	  },
	  give: {
	    g: 'giving',
	    prt: '_n',
	    pst: 'gave'
	  },
	  go: {
	    prt: '_ne',
	    pst: 'went',
	    pres: 'goes'
	  },
	  grow: {
	    prt: '_n'
	  },
	  guide: {
	    pst: '_d'
	  },
	  hang: {
	    pst: 'hung',
	    prt: 'hung'
	  },
	  have: {
	    g: 'having',
	    pst: 'had',
	    prt: 'had',
	    pres: 'has'
	  },
	  hear: {
	    pst: '_d',
	    prt: '_d'
	  },
	  hide: {
	    prt: 'hidden',
	    pst: 'hid'
	  },
	  hit: {
	    prt: '_'
	  },
	  hold: {
	    pst: 'held',
	    prt: 'held'
	  },
	  hurt: {
	    pst: '_',
	    prt: '_'
	  },
	  ice: {
	    g: 'icing',
	    pst: '_d'
	  },
	  imply: {
	    pst: 'implied',
	    pres: 'implies'
	  },
	  is: {
	    a: '',
	    g: 'being',
	    pst: 'was',
	    pres: '_'
	  },
	  keep: {
	    prt: 'kept'
	  },
	  kneel: {
	    prt: 'knelt'
	  },
	  know: {
	    prt: '_n'
	  },
	  lay: {
	    pst: 'laid',
	    prt: 'laid'
	  },
	  lead: {
	    pst: 'led',
	    prt: 'led'
	  },
	  leap: {
	    prt: '_t'
	  },
	  leave: {
	    pst: 'left',
	    prt: 'left'
	  },
	  lend: {
	    prt: 'lent'
	  },
	  lie: {
	    g: 'lying',
	    pst: 'lay'
	  },
	  light: {
	    pst: 'lit',
	    prt: 'lit'
	  },
	  log: {
	    g: '_ging',
	    pst: '_ged'
	  },
	  loose: {
	    prt: 'lost'
	  },
	  lose: {
	    g: 'losing',
	    pst: 'lost'
	  },
	  make: {
	    pst: 'made',
	    prt: 'made'
	  },
	  mean: {
	    pst: '_t',
	    prt: '_t'
	  },
	  meet: {
	    a: '_er',
	    g: '_ing',
	    pst: 'met',
	    prt: 'met'
	  },
	  miss: {
	    pres: '_'
	  },
	  name: {
	    g: 'naming'
	  },
	  patrol: {
	    g: '_ling',
	    pst: '_led'
	  },
	  pay: {
	    pst: 'paid',
	    prt: 'paid'
	  },
	  prove: {
	    prt: '_n'
	  },
	  puke: {
	    g: 'puking'
	  },
	  put: {
	    prt: '_'
	  },
	  quit: {
	    prt: '_'
	  },
	  read: {
	    pst: '_',
	    prt: '_'
	  },
	  ride: {
	    prt: 'ridden'
	  },
	  reside: {
	    pst: '_d'
	  },
	  ring: {
	    pst: 'rang',
	    prt: 'rung'
	  },
	  rise: {
	    fut: 'will have _n',
	    g: 'rising',
	    prt: '_n',
	    pst: 'rose',
	    pluperf: 'had _n'
	  },
	  rub: {
	    g: '_bing',
	    pst: '_bed'
	  },
	  run: {
	    g: '_ning',
	    prt: '_',
	    pst: 'ran'
	  },
	  say: {
	    pst: 'said',
	    prt: 'said',
	    pres: '_s'
	  },
	  seat: {
	    pst: 'sat',
	    prt: 'sat'
	  },
	  see: {
	    g: '_ing',
	    prt: '_n',
	    pst: 'saw'
	  },
	  seek: {
	    prt: 'sought'
	  },
	  sell: {
	    pst: 'sold',
	    prt: 'sold'
	  },
	  send: {
	    prt: 'sent'
	  },
	  set: {
	    prt: '_'
	  },
	  sew: {
	    prt: '_n'
	  },
	  shake: {
	    prt: '_n'
	  },
	  shave: {
	    prt: '_d'
	  },
	  shed: {
	    g: '_ding',
	    pst: '_',
	    pres: '_s'
	  },
	  shine: {
	    pst: 'shone',
	    prt: 'shone'
	  },
	  shoot: {
	    pst: 'shot',
	    prt: 'shot'
	  },
	  show: {
	    pst: '_ed'
	  },
	  shut: {
	    prt: '_'
	  },
	  sing: {
	    prt: 'sung',
	    pst: 'sang'
	  },
	  sink: {
	    pst: 'sank',
	    pluperf: 'had sunk'
	  },
	  sit: {
	    pst: 'sat'
	  },
	  ski: {
	    pst: '_ied'
	  },
	  slay: {
	    prt: 'slain'
	  },
	  sleep: {
	    prt: 'slept'
	  },
	  slide: {
	    pst: 'slid',
	    prt: 'slid'
	  },
	  smash: {
	    pres: '_es'
	  },
	  sneak: {
	    prt: 'snuck'
	  },
	  speak: {
	    fut: 'will have spoken',
	    prt: 'spoken',
	    pst: 'spoke',
	    perf: 'have spoken',
	    pluperf: 'had spoken'
	  },
	  speed: {
	    prt: 'sped'
	  },
	  spend: {
	    prt: 'spent'
	  },
	  spill: {
	    prt: '_ed',
	    pst: 'spilt'
	  },
	  spin: {
	    g: '_ning',
	    pst: 'spun',
	    prt: 'spun'
	  },
	  spit: {
	    prt: 'spat'
	  },
	  split: {
	    prt: '_'
	  },
	  spread: {
	    pst: '_'
	  },
	  spring: {
	    prt: 'sprung'
	  },
	  stand: {
	    pst: 'stood'
	  },
	  steal: {
	    a: '_er',
	    pst: 'stole'
	  },
	  stick: {
	    pst: 'stuck'
	  },
	  sting: {
	    pst: 'stung'
	  },
	  stink: {
	    pst: 'stunk',
	    prt: 'stunk'
	  },
	  stream: {
	    a: '_er'
	  },
	  strew: {
	    prt: '_n'
	  },
	  strike: {
	    g: 'striking',
	    pst: 'struck'
	  },
	  suit: {
	    a: '_er',
	    g: '_ing',
	    pst: '_ed'
	  },
	  sware: {
	    prt: 'sworn'
	  },
	  swear: {
	    pst: 'swore'
	  },
	  sweep: {
	    prt: 'swept'
	  },
	  swim: {
	    g: '_ming',
	    pst: 'swam'
	  },
	  swing: {
	    pst: 'swung'
	  },
	  take: {
	    fut: 'will have _n',
	    pst: 'took',
	    perf: 'have _n',
	    pluperf: 'had _n'
	  },
	  teach: {
	    pst: 'taught',
	    pres: '_es'
	  },
	  tear: {
	    pst: 'tore'
	  },
	  tell: {
	    pst: 'told'
	  },
	  think: {
	    pst: 'thought'
	  },
	  thrive: {
	    prt: '_d'
	  },
	  tie: {
	    g: 'tying',
	    pst: '_d'
	  },
	  undergo: {
	    prt: '_ne'
	  },
	  understand: {
	    pst: 'understood'
	  },
	  upset: {
	    prt: '_'
	  },
	  wait: {
	    a: '_er',
	    g: '_ing',
	    pst: '_ed'
	  },
	  wake: {
	    pst: 'woke'
	  },
	  wear: {
	    pst: 'wore'
	  },
	  weave: {
	    prt: 'woven'
	  },
	  wed: {
	    pst: 'wed'
	  },
	  weep: {
	    prt: 'wept'
	  },
	  win: {
	    g: '_ning',
	    pst: 'won'
	  },
	  wind: {
	    prt: 'wound'
	  },
	  withdraw: {
	    pst: 'withdrew'
	  },
	  wring: {
	    prt: 'wrung'
	  },
	  write: {
	    g: 'writing',
	    prt: 'written',
	    pst: 'wrote'
	  }
	}; //uncompress our ad-hoc compression scheme

	var keys = Object.keys(conjugations);

	var _loop = function _loop(i) {
	  var inf = keys[i];
	  var _final = {};
	  Object.keys(conjugations[inf]).forEach(function (key) {
	    var str = conjugations[inf][key]; //swap-in infinitives for '_'

	    str = str.replace('_', inf);
	    var full = mapping$1[key];
	    _final[full] = str;
	  }); //over-write original

	  conjugations[inf] = _final;
	};

	for (var i = 0; i < keys.length; i++) {
	  _loop(i);
	}

	var conjugations_1 = conjugations;

	var endsWith$1 = {
	  b: [{
	    reg: /([^aeiou][aeiou])b$/i,
	    repl: {
	      pr: '$1bs',
	      pa: '$1bbed',
	      gr: '$1bbing'
	    }
	  }],
	  d: [{
	    reg: /(end)$/i,
	    repl: {
	      pr: '$1s',
	      pa: 'ent',
	      gr: '$1ing',
	      ar: '$1er'
	    }
	  }, {
	    reg: /(eed)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1ed',
	      gr: '$1ing',
	      ar: '$1er'
	    }
	  }, {
	    reg: /(ed)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1ded',
	      ar: '$1der',
	      gr: '$1ding'
	    }
	  }, {
	    reg: /([^aeiou][ou])d$/i,
	    repl: {
	      pr: '$1ds',
	      pa: '$1dded',
	      gr: '$1dding'
	    }
	  }],
	  e: [{
	    reg: /(eave)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1d',
	      gr: 'eaving',
	      ar: '$1r'
	    }
	  }, {
	    reg: /(ide)$/i,
	    repl: {
	      pr: '$1s',
	      pa: 'ode',
	      gr: 'iding',
	      ar: 'ider'
	    }
	  }, {
	    //shake
	    reg: /(t|sh?)(ake)$/i,
	    repl: {
	      pr: '$1$2s',
	      pa: '$1ook',
	      gr: '$1aking',
	      ar: '$1$2r'
	    }
	  }, {
	    //awake
	    reg: /w(ake)$/i,
	    repl: {
	      pr: 'w$1s',
	      pa: 'woke',
	      gr: 'waking',
	      ar: 'w$1r'
	    }
	  }, {
	    //make
	    reg: /m(ake)$/i,
	    repl: {
	      pr: 'm$1s',
	      pa: 'made',
	      gr: 'making',
	      ar: 'm$1r'
	    }
	  }, {
	    reg: /(a[tg]|i[zn]|ur|nc|gl|is)e$/i,
	    repl: {
	      pr: '$1es',
	      pa: '$1ed',
	      gr: '$1ing' // prt: '$1en',

	    }
	  }, {
	    reg: /([bd]l)e$/i,
	    repl: {
	      pr: '$1es',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }, {
	    reg: /(om)e$/i,
	    repl: {
	      pr: '$1es',
	      pa: 'ame',
	      gr: '$1ing'
	    }
	  }],
	  g: [{
	    reg: /([^aeiou][ou])g$/i,
	    repl: {
	      pr: '$1gs',
	      pa: '$1gged',
	      gr: '$1gging'
	    }
	  }],
	  h: [{
	    reg: /(..)([cs]h)$/i,
	    repl: {
	      pr: '$1$2es',
	      pa: '$1$2ed',
	      gr: '$1$2ing'
	    }
	  }],
	  k: [{
	    reg: /(ink)$/i,
	    repl: {
	      pr: '$1s',
	      pa: 'unk',
	      gr: '$1ing',
	      ar: '$1er'
	    }
	  }],
	  m: [{
	    reg: /([^aeiou][aeiou])m$/i,
	    repl: {
	      pr: '$1ms',
	      pa: '$1mmed',
	      gr: '$1mming'
	    }
	  }],
	  n: [{
	    reg: /(en)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }],
	  p: [{
	    reg: /(e)(ep)$/i,
	    repl: {
	      pr: '$1$2s',
	      pa: '$1pt',
	      gr: '$1$2ing',
	      ar: '$1$2er'
	    }
	  }, {
	    reg: /([^aeiou][aeiou])p$/i,
	    repl: {
	      pr: '$1ps',
	      pa: '$1pped',
	      gr: '$1pping'
	    }
	  }, {
	    reg: /([aeiu])p$/i,
	    repl: {
	      pr: '$1ps',
	      pa: '$1p',
	      gr: '$1pping'
	    }
	  }],
	  r: [{
	    reg: /([td]er)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }, {
	    reg: /(er)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }],
	  s: [{
	    reg: /(ish|tch|ess)$/i,
	    repl: {
	      pr: '$1es',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }],
	  t: [{
	    reg: /(ion|end|e[nc]t)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }, {
	    reg: /(.eat)$/i,
	    repl: {
	      pr: '$1s',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }, {
	    reg: /([aeiu])t$/i,
	    repl: {
	      pr: '$1ts',
	      pa: '$1t',
	      gr: '$1tting'
	    }
	  }, {
	    reg: /([^aeiou][aeiou])t$/i,
	    repl: {
	      pr: '$1ts',
	      pa: '$1tted',
	      gr: '$1tting'
	    }
	  }],
	  w: [{
	    reg: /(.llow)$/i,
	    //follow, allow
	    repl: {
	      pr: '$1s',
	      pa: '$1ed'
	    }
	  }, {
	    reg: /(..)(ow)$/i,
	    //grow
	    repl: {
	      pr: '$1$2s',
	      pa: '$1ew',
	      gr: '$1$2ing',
	      prt: '$1$2n'
	    }
	  }],
	  y: [{
	    reg: /([i|f|rr])y$/i,
	    repl: {
	      pr: '$1ies',
	      pa: '$1ied',
	      gr: '$1ying'
	    }
	  }],
	  z: [{
	    reg: /([aeiou]zz)$/i,
	    repl: {
	      pr: '$1es',
	      pa: '$1ed',
	      gr: '$1ing'
	    }
	  }]
	};
	var suffixes$1 = endsWith$1;

	var posMap = {
	  pr: 'PresentTense',
	  pa: 'PastTense',
	  gr: 'Gerund',
	  prt: 'Participle',
	  ar: 'Actor'
	};

	var doTransform = function doTransform(str, obj) {
	  var found = {};
	  var keys = Object.keys(obj.repl);

	  for (var i = 0; i < keys.length; i += 1) {
	    var pos = keys[i];
	    found[posMap[pos]] = str.replace(obj.reg, obj.repl[pos]);
	  }

	  return found;
	}; //look at the end of the word for clues


	var checkSuffix = function checkSuffix() {
	  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var c = str[str.length - 1];

	  if (suffixes$1.hasOwnProperty(c) === true) {
	    for (var r = 0; r < suffixes$1[c].length; r += 1) {
	      var reg = suffixes$1[c][r].reg;

	      if (reg.test(str) === true) {
	        return doTransform(str, suffixes$1[c][r]);
	      }
	    }
	  }

	  return {};
	};

	var _01Suffixes = checkSuffix;

	//non-specifc, 'hail-mary' transforms from infinitive, into other forms
	var hasY = /[bcdfghjklmnpqrstvwxz]y$/;
	var generic = {
	  Gerund: function Gerund(inf) {
	    if (inf.charAt(inf.length - 1) === 'e') {
	      return inf.replace(/e$/, 'ing');
	    }

	    return inf + 'ing';
	  },
	  PresentTense: function PresentTense(inf) {
	    if (inf.charAt(inf.length - 1) === 's') {
	      return inf + 'es';
	    }

	    if (hasY.test(inf) === true) {
	      return inf.slice(0, -1) + 'ies';
	    }

	    return inf + 's';
	  },
	  PastTense: function PastTense(inf) {
	    if (inf.charAt(inf.length - 1) === 'e') {
	      return inf + 'd';
	    }

	    if (inf.substr(-2) === 'ed') {
	      return inf;
	    }

	    if (hasY.test(inf) === true) {
	      return inf.slice(0, -1) + 'ied';
	    }

	    return inf + 'ed';
	  }
	};
	var _02Generic = generic;

	//we assume the input word is a proper infinitive

	var conjugate$2 = function conjugate() {
	  var inf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var world = arguments.length > 1 ? arguments[1] : undefined;
	  var found = {}; // 1. look at irregulars
	  //the lexicon doesn't pass this in

	  if (world && world.irregulars) {
	    if (world.irregulars.verbs.hasOwnProperty(inf) === true) {
	      found = Object.assign({}, world.irregulars.verbs[inf]);
	    }
	  } //2. rule-based regex


	  found = Object.assign({}, _01Suffixes(inf), found); //3. generic transformations
	  //'buzzing'

	  if (found.Gerund === undefined) {
	    found.Gerund = _02Generic.Gerund(inf);
	  } //'buzzed'


	  if (found.PastTense === undefined) {
	    found.PastTense = _02Generic.PastTense(inf);
	  } //'buzzes'


	  if (found.PresentTense === undefined) {
	    found.PresentTense = _02Generic.PresentTense(inf);
	  }

	  return found;
	};

	var conjugate_1$1 = conjugate$2; // console.log(conjugate('bake'))

	//turn 'quick' into 'quickest'
	var do_rules$1 = [/ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /oud$/, /...p$/];
	var dont_rules$1 = [/ary$/];
	var irregulars$5 = {
	  nice: 'nicest',
	  late: 'latest',
	  hard: 'hardest',
	  inner: 'innermost',
	  outer: 'outermost',
	  far: 'furthest',
	  worse: 'worst',
	  bad: 'worst',
	  good: 'best',
	  big: 'biggest',
	  large: 'largest'
	};
	var transforms$2 = [{
	  reg: /y$/i,
	  repl: 'iest'
	}, {
	  reg: /([aeiou])t$/i,
	  repl: '$1ttest'
	}, {
	  reg: /([aeou])de$/i,
	  repl: '$1dest'
	}, {
	  reg: /nge$/i,
	  repl: 'ngest'
	}, {
	  reg: /([aeiou])te$/i,
	  repl: '$1test'
	}];

	var to_superlative = function to_superlative(str) {
	  //irregulars
	  if (irregulars$5.hasOwnProperty(str)) {
	    return irregulars$5[str];
	  } //known transforms


	  for (var i = 0; i < transforms$2.length; i++) {
	    if (transforms$2[i].reg.test(str)) {
	      return str.replace(transforms$2[i].reg, transforms$2[i].repl);
	    }
	  } //dont-rules


	  for (var _i = 0; _i < dont_rules$1.length; _i++) {
	    if (dont_rules$1[_i].test(str) === true) {
	      return null;
	    }
	  } //do-rules


	  for (var _i2 = 0; _i2 < do_rules$1.length; _i2++) {
	    if (do_rules$1[_i2].test(str) === true) {
	      if (str.charAt(str.length - 1) === 'e') {
	        return str + 'st';
	      }

	      return str + 'est';
	    }
	  }

	  return str + 'est';
	};

	var toSuperlative = to_superlative;

	//turn 'quick' into 'quickly'
	var do_rules = [/ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /old$/, /oud$/, /e[ae]p$/];
	var dont_rules = [/ary$/, /ous$/];
	var irregulars$4 = {
	  grey: 'greyer',
	  gray: 'grayer',
	  green: 'greener',
	  yellow: 'yellower',
	  red: 'redder',
	  good: 'better',
	  well: 'better',
	  bad: 'worse',
	  sad: 'sadder',
	  big: 'bigger'
	};
	var transforms$1 = [{
	  reg: /y$/i,
	  repl: 'ier'
	}, {
	  reg: /([aeiou])t$/i,
	  repl: '$1tter'
	}, {
	  reg: /([aeou])de$/i,
	  repl: '$1der'
	}, {
	  reg: /nge$/i,
	  repl: 'nger'
	}];

	var to_comparative = function to_comparative(str) {
	  //known-irregulars
	  if (irregulars$4.hasOwnProperty(str)) {
	    return irregulars$4[str];
	  } //known-transforms


	  for (var i = 0; i < transforms$1.length; i++) {
	    if (transforms$1[i].reg.test(str) === true) {
	      return str.replace(transforms$1[i].reg, transforms$1[i].repl);
	    }
	  } //dont-patterns


	  for (var _i = 0; _i < dont_rules.length; _i++) {
	    if (dont_rules[_i].test(str) === true) {
	      return null;
	    }
	  } //do-patterns


	  for (var _i2 = 0; _i2 < do_rules.length; _i2++) {
	    if (do_rules[_i2].test(str) === true) {
	      return str + 'er';
	    }
	  } //easy-one


	  if (/e$/.test(str) === true) {
	    return str + 'r';
	  }

	  return str + 'er';
	};

	var toComparative = to_comparative;

	var fns = {
	  toSuperlative: toSuperlative,
	  toComparative: toComparative
	};
	/** conjugate an adjective into other forms */

	var conjugate$1 = function conjugate(w) {
	  var res = {}; // 'greatest'

	  var sup = fns.toSuperlative(w);

	  if (sup) {
	    res.Superlative = sup;
	  } // 'greater'


	  var comp = fns.toComparative(w);

	  if (comp) {
	    res.Comparative = comp;
	  }

	  return res;
	};

	var adjectives$2 = conjugate$1;

	/** patterns for turning 'bus' to 'buses'*/
	var suffixes = {
	  a: [[/(antenn|formul|nebul|vertebr|vit)a$/i, '$1ae'], [/([ti])a$/i, '$1a']],
	  e: [[/(kn|l|w)ife$/i, '$1ives'], [/(hive)$/i, '$1s'], [/([m|l])ouse$/i, '$1ice'], [/([m|l])ice$/i, '$1ice']],
	  f: [[/^(dwar|handkerchie|hoo|scar|whar)f$/i, '$1ves'], [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, '$1ves']],
	  i: [[/(octop|vir)i$/i, '$1i']],
	  m: [[/([ti])um$/i, '$1a']],
	  n: [[/^(oxen)$/i, '$1']],
	  o: [[/(al|ad|at|er|et|ed|ad)o$/i, '$1oes']],
	  s: [[/(ax|test)is$/i, '$1es'], [/(alias|status)$/i, '$1es'], [/sis$/i, 'ses'], [/(bu)s$/i, '$1ses'], [/(sis)$/i, 'ses'], [/^(?!talis|.*hu)(.*)man$/i, '$1men'], [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, '$1i']],
	  x: [[/(matr|vert|ind|cort)(ix|ex)$/i, '$1ices'], [/^(ox)$/i, '$1en']],
	  y: [[/([^aeiouy]|qu)y$/i, '$1ies']],
	  z: [[/(quiz)$/i, '$1zes']]
	};
	var _rules$2 = suffixes;

	var addE = /(x|ch|sh|s|z)$/;

	var trySuffix = function trySuffix(str) {
	  var c = str[str.length - 1];

	  if (_rules$2.hasOwnProperty(c) === true) {
	    for (var i = 0; i < _rules$2[c].length; i += 1) {
	      var reg = _rules$2[c][i][0];

	      if (reg.test(str) === true) {
	        return str.replace(reg, _rules$2[c][i][1]);
	      }
	    }
	  }

	  return null;
	};
	/** Turn a singular noun into a plural
	 * assume the given string is singular
	 */


	var pluralize = function pluralize() {
	  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var world = arguments.length > 1 ? arguments[1] : undefined;
	  var irregulars = world.irregulars.nouns; // check irregulars list

	  if (irregulars.hasOwnProperty(str)) {
	    return irregulars[str];
	  } //we have some rules to try-out


	  var plural = trySuffix(str);

	  if (plural !== null) {
	    return plural;
	  } //like 'church'


	  if (addE.test(str)) {
	    return str + 'es';
	  } // \_()_/


	  return str + 's';
	};

	var toPlural = pluralize;

	//patterns for turning 'dwarves' to 'dwarf'
	var _rules$1 = [[/([^v])ies$/i, '$1y'], [/ises$/i, 'isis'], [/(kn|[^o]l|w)ives$/i, '$1ife'], [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, '$1f'], [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, '$1f'], [/(antenn|formul|nebul|vertebr|vit)ae$/i, '$1a'], [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, '$1us'], [/(buffal|tomat|tornad)(oes)$/i, '$1o'], // [/(analy|diagno|parenthe|progno|synop|the)ses$/i, '$1sis'],
	[/(eas)es$/i, '$1e'], //diseases
	[/(..[aeiou]s)es$/i, '$1'], //geniouses
	[/(vert|ind|cort)(ices)$/i, '$1ex'], [/(matr|append)(ices)$/i, '$1ix'], [/(x|ch|ss|sh|z|o)es$/i, '$1'], [/men$/i, 'man'], [/(n)ews$/i, '$1ews'], [/([ti])a$/i, '$1um'], [/([^aeiouy]|qu)ies$/i, '$1y'], [/(s)eries$/i, '$1eries'], [/(m)ovies$/i, '$1ovie'], [/([m|l])ice$/i, '$1ouse'], [/(cris|ax|test)es$/i, '$1is'], [/(alias|status)es$/i, '$1'], [/(ss)$/i, '$1'], [/(ics)$/i, '$1'], [/s$/i, '']];

	var invertObj = function invertObj(obj) {
	  return Object.keys(obj).reduce(function (h, k) {
	    h[obj[k]] = k;
	    return h;
	  }, {});
	};

	var toSingular = function toSingular(str, world) {
	  var irregulars = world.irregulars.nouns;
	  var invert = invertObj(irregulars); //(not very efficient)
	  // check irregulars list

	  if (invert.hasOwnProperty(str)) {
	    return invert[str];
	  } // go through our regexes


	  for (var i = 0; i < _rules$1.length; i++) {
	    if (_rules$1[i][0].test(str) === true) {
	      str = str.replace(_rules$1[i][0], _rules$1[i][1]);
	      return str;
	    }
	  }

	  return str;
	};

	var toSingular_1 = toSingular;

	//rules for turning a verb into infinitive form
	var rules = {
	  Participle: [{
	    reg: /own$/i,
	    to: 'ow'
	  }, {
	    reg: /(.)un([g|k])$/i,
	    to: '$1in$2'
	  }],
	  Actor: [{
	    reg: /(er)er$/i,
	    to: '$1'
	  }],
	  PresentTense: [{
	    reg: /(..)(ies)$/i,
	    to: '$1y'
	  }, {
	    reg: /(tch|sh)es$/i,
	    to: '$1'
	  }, {
	    reg: /(ss|zz)es$/i,
	    to: '$1'
	  }, {
	    reg: /([tzlshicgrvdnkmu])es$/i,
	    to: '$1e'
	  }, {
	    reg: /(n[dtk]|c[kt]|[eo]n|i[nl]|er|a[ytrl])s$/i,
	    to: '$1'
	  }, {
	    reg: /(ow)s$/i,
	    to: '$1'
	  }, {
	    reg: /(op)s$/i,
	    to: '$1'
	  }, {
	    reg: /([eirs])ts$/i,
	    to: '$1t'
	  }, {
	    reg: /(ll)s$/i,
	    to: '$1'
	  }, {
	    reg: /(el)s$/i,
	    to: '$1'
	  }, {
	    reg: /(ip)es$/i,
	    to: '$1e'
	  }, {
	    reg: /ss$/i,
	    to: 'ss'
	  }, {
	    reg: /s$/i,
	    to: ''
	  }],
	  Gerund: [{
	    //popping -> pop
	    reg: /(..)(p|d|t|g){2}ing$/i,
	    to: '$1$2'
	  }, {
	    //fuzzing -> fuzz
	    reg: /(ll|ss|zz)ing$/i,
	    to: '$1'
	  }, {
	    reg: /([^aeiou])ying$/i,
	    to: '$1y'
	  }, {
	    reg: /([^ae]i.)ing$/i,
	    to: '$1e'
	  }, {
	    //eating, reading
	    reg: /(ea[dklnrtv])ing$/i,
	    to: '$1'
	  }, {
	    //washing -> wash
	    reg: /(ch|sh)ing$/i,
	    to: '$1'
	  }, //soft-e forms:
	  {
	    //z : hazing (not buzzing)
	    reg: /(z)ing$/i,
	    to: '$1e'
	  }, {
	    //a : baking, undulating
	    reg: /(a[gdkvtc])ing$/i,
	    to: '$1e'
	  }, {
	    //u : conjuring, tubing
	    reg: /(u[rtcbn])ing$/i,
	    to: '$1e'
	  }, {
	    //o : forboding, poking, hoping, boring (not hooping)
	    reg: /([^o]o[bdknprv])ing$/i,
	    to: '$1e'
	  }, {
	    //ling : tingling, wrinkling, circling, scrambling, bustling
	    reg: /([tbckg]l)ing$/i,
	    //dp
	    to: '$1e'
	  }, {
	    //cing : bouncing, denouncing
	    reg: /(c|s)ing$/i,
	    //dp
	    to: '$1e'
	  }, // {
	  //   //soft-e :
	  //   reg: /([ua]s|[dr]g|z|o[rlsp]|cre)ing$/i,
	  //   to: '$1e',
	  // },
	  {
	    //fallback
	    reg: /(..)ing$/i,
	    to: '$1'
	  }],
	  PastTense: [{
	    reg: /(ued)$/i,
	    to: 'ue'
	  }, {
	    reg: /a([^aeiouy])ed$/i,
	    to: 'a$1e'
	  }, {
	    reg: /([aeiou]zz)ed$/i,
	    to: '$1'
	  }, {
	    reg: /(e|i)lled$/i,
	    to: '$1ll'
	  }, {
	    reg: /(.)(sh|ch)ed$/i,
	    to: '$1$2'
	  }, {
	    reg: /(tl|gl)ed$/i,
	    to: '$1e'
	  }, {
	    reg: /(um?pt?)ed$/i,
	    to: '$1'
	  }, {
	    reg: /(ss)ed$/i,
	    to: '$1'
	  }, {
	    reg: /pped$/i,
	    to: 'p'
	  }, {
	    reg: /tted$/i,
	    to: 't'
	  }, {
	    reg: /(..)gged$/i,
	    to: '$1g'
	  }, {
	    reg: /(..)lked$/i,
	    to: '$1lk'
	  }, {
	    reg: /([^aeiouy][aeiou])ked$/i,
	    to: '$1ke'
	  }, {
	    reg: /(.[aeiou])led$/i,
	    to: '$1l'
	  }, {
	    reg: /(..)(h|ion|n[dt]|ai.|[cs]t|pp|all|ss|tt|int|ail|ld|en|oo.|er|k|pp|w|ou.|rt|ght|rm)ed$/i,
	    to: '$1$2'
	  }, {
	    reg: /(.ut)ed$/i,
	    to: '$1e'
	  }, {
	    reg: /(.pt)ed$/i,
	    to: '$1'
	  }, {
	    reg: /(us)ed$/i,
	    to: '$1e'
	  }, {
	    reg: /(dd)ed$/i,
	    to: '$1'
	  }, {
	    reg: /(..[^aeiouy])ed$/i,
	    to: '$1e'
	  }, {
	    reg: /(..)ied$/i,
	    to: '$1y'
	  }, {
	    reg: /(.o)ed$/i,
	    to: '$1o'
	  }, {
	    reg: /(..i)ed$/i,
	    to: '$1'
	  }, {
	    reg: /(.a[^aeiou])ed$/i,
	    to: '$1'
	  }, {
	    //owed, aced
	    reg: /([aeiou][^aeiou])ed$/i,
	    to: '$1e'
	  }, {
	    reg: /([rl])ew$/i,
	    to: '$1ow'
	  }, {
	    reg: /([pl])t$/i,
	    to: '$1t'
	  }]
	};
	var _transform = rules;

	var guessVerb = {
	  Gerund: ['ing'],
	  Actor: ['erer'],
	  Infinitive: ['ate', 'ize', 'tion', 'rify', 'then', 'ress', 'ify', 'age', 'nce', 'ect', 'ise', 'ine', 'ish', 'ace', 'ash', 'ure', 'tch', 'end', 'ack', 'and', 'ute', 'ade', 'ock', 'ite', 'ase', 'ose', 'use', 'ive', 'int', 'nge', 'lay', 'est', 'ain', 'ant', 'ent', 'eed', 'er', 'le', 'own', 'unk', 'ung', 'en'],
	  PastTense: ['ed', 'lt', 'nt', 'pt', 'ew', 'ld'],
	  PresentTense: ['rks', 'cks', 'nks', 'ngs', 'mps', 'tes', 'zes', 'ers', 'les', 'acks', 'ends', 'ands', 'ocks', 'lays', 'eads', 'lls', 'els', 'ils', 'ows', 'nds', 'ays', 'ams', 'ars', 'ops', 'ffs', 'als', 'urs', 'lds', 'ews', 'ips', 'es', 'ts', 'ns']
	}; //flip it into a lookup object

	guessVerb = Object.keys(guessVerb).reduce(function (h, k) {
	  guessVerb[k].forEach(function (a) {
	    return h[a] = k;
	  });
	  return h;
	}, {});
	var _guess = guessVerb;

	/** it helps to know what we're conjugating from */

	var guessTense = function guessTense(str) {
	  var three = str.substr(str.length - 3);

	  if (_guess.hasOwnProperty(three) === true) {
	    return _guess[three];
	  }

	  var two = str.substr(str.length - 2);

	  if (_guess.hasOwnProperty(two) === true) {
	    return _guess[two];
	  }

	  var one = str.substr(str.length - 1);

	  if (one === 's') {
	    return 'PresentTense';
	  }

	  return null;
	};

	var toInfinitive$1 = function toInfinitive(str, world, tense) {
	  if (!str) {
	    return '';
	  } //1. look at known irregulars


	  if (world.words.hasOwnProperty(str) === true) {
	    var irregs = world.irregulars.verbs;
	    var keys = Object.keys(irregs);

	    for (var i = 0; i < keys.length; i++) {
	      var forms = Object.keys(irregs[keys[i]]);

	      for (var o = 0; o < forms.length; o++) {
	        if (str === irregs[keys[i]][forms[o]]) {
	          return keys[i];
	        }
	      }
	    }
	  } // give'r!


	  tense = tense || guessTense(str);

	  if (tense && _transform[tense]) {
	    for (var _i = 0; _i < _transform[tense].length; _i++) {
	      var rule = _transform[tense][_i];

	      if (rule.reg.test(str) === true) {
	        // console.log(rule.reg)
	        return str.replace(rule.reg, rule.to);
	      }
	    }
	  }

	  return str;
	};

	var toInfinitive_1$1 = toInfinitive$1;

	var irregulars$3 = {
	  nouns: plurals,
	  verbs: conjugations_1
	}; //these behaviours are configurable & shared across some plugins

	var transforms = {
	  conjugate: conjugate_1$1,
	  adjectives: adjectives$2,
	  toPlural: toPlural,
	  toSingular: toSingular_1,
	  toInfinitive: toInfinitive_1$1
	};
	var _isVerbose = false;
	/** all configurable linguistic data */

	var World = /*#__PURE__*/function () {
	  function World() {
	    _classCallCheck(this, World);

	    // quiet these properties from a console.log
	    Object.defineProperty(this, 'words', {
	      enumerable: false,
	      value: {},
	      writable: true
	    });
	    Object.defineProperty(this, 'hasCompound', {
	      enumerable: false,
	      value: {},
	      writable: true
	    });
	    Object.defineProperty(this, 'irregulars', {
	      enumerable: false,
	      value: irregulars$3,
	      writable: true
	    });
	    Object.defineProperty(this, 'tags', {
	      enumerable: false,
	      value: Object.assign({}, tags),
	      writable: true
	    });
	    Object.defineProperty(this, 'transforms', {
	      enumerable: false,
	      value: transforms,
	      writable: true
	    });
	    Object.defineProperty(this, 'taggers', {
	      enumerable: false,
	      value: [],
	      writable: true
	    }); // cache our abbreviations for our sentence-parser

	    Object.defineProperty(this, 'cache', {
	      enumerable: false,
	      value: {
	        abbreviations: {}
	      }
	    }); // add our compressed data to lexicon

	    this.words = unpack_1.buildOut(this); // add our irregulars to lexicon

	    addIrregulars_1(this);
	  }
	  /** more logs for debugging */


	  _createClass(World, [{
	    key: "verbose",
	    value: function verbose(bool) {
	      _isVerbose = bool;
	      return this;
	    }
	  }, {
	    key: "isVerbose",
	    value: function isVerbose() {
	      return _isVerbose;
	    }
	    /** put new words into our lexicon, properly */

	  }, {
	    key: "addWords",
	    value: function addWords(wordObj) {
	      // clean them up a bit
	      var cleaned = {};
	      Object.keys(wordObj).forEach(function (w) {
	        var tag = wordObj[w];
	        w = w.toLowerCase().trim();
	        cleaned[w] = tag;
	      });
	      unpack_1.addWords(cleaned, this.words, this);
	    }
	    /** add new custom conjugations */

	  }, {
	    key: "addConjugations",
	    value: function addConjugations(obj) {
	      Object.assign(this.irregulars.verbs, obj);
	      return this;
	    }
	    /** add new custom plural/singular pairs */

	  }, {
	    key: "addPlurals",
	    value: function addPlurals(obj) {
	      Object.assign(this.irregulars.nouns, obj);
	      return this;
	    }
	    /** extend the compromise tagset */

	  }, {
	    key: "addTags",
	    value: function addTags(tags) {
	      tags = Object.assign({}, tags);
	      this.tags = Object.assign(this.tags, tags); // calculate graph implications for the new tags

	      this.tags = inference(this.tags);
	      return this;
	    }
	    /** call methods after tagger runs */

	  }, {
	    key: "postProcess",
	    value: function postProcess(fn) {
	      this.taggers.push(fn);
	      return this;
	    }
	    /** helper method for logging + debugging */

	  }, {
	    key: "stats",
	    value: function stats() {
	      return {
	        words: Object.keys(this.words).length,
	        plurals: Object.keys(this.irregulars.nouns).length,
	        conjugations: Object.keys(this.irregulars.verbs).length,
	        compounds: Object.keys(this.hasCompound).length,
	        postProcessors: this.taggers.length
	      };
	    }
	  }]);

	  return World;
	}(); //  \_(:/)_/


	var clone = function clone(obj) {
	  return JSON.parse(JSON.stringify(obj));
	};
	/** produce a deep-copy of all lingustic data */


	World.prototype.clone = function () {
	  var w2 = new World(); // these are simple to copy:

	  w2.words = Object.assign({}, this.words);
	  w2.hasCompound = Object.assign({}, this.hasCompound); //these ones are nested:

	  w2.irregulars = clone(this.irregulars);
	  w2.tags = clone(this.tags); // these are functions

	  w2.transforms = this.transforms;
	  w2.taggers = this.taggers;
	  return w2;
	};

	var World_1 = World;

	/** return the root, first document */

	var _01Utils = createCommonjsModule(function (module, exports) {
	  exports.all = function () {
	    return this.parents()[0] || this;
	  };
	  /** return the previous result */


	  exports.parent = function () {
	    if (this.from) {
	      return this.from;
	    }

	    return this;
	  };
	  /**  return a list of all previous results */


	  exports.parents = function (n) {
	    var arr = [];

	    var addParent = function addParent(doc) {
	      if (doc.from) {
	        arr.push(doc.from);
	        addParent(doc.from);
	      }
	    };

	    addParent(this);
	    arr = arr.reverse();

	    if (typeof n === 'number') {
	      return arr[n];
	    }

	    return arr;
	  };
	  /** deep-copy the document, so that no references remain */


	  exports.clone = function (doShallow) {
	    var list = this.list.map(function (ts) {
	      return ts.clone(doShallow);
	    });
	    var tmp = this.buildFrom(list);
	    return tmp;
	  };
	  /** how many seperate terms does the document have? */


	  exports.wordCount = function () {
	    return this.list.reduce(function (count, p) {
	      count += p.wordCount();
	      return count;
	    }, 0);
	  };

	  exports.wordcount = exports.wordCount;
	  /** turn on logging for decision-debugging */
	  // exports.verbose = function(bool) {
	  //   if (bool === undefined) {
	  //     bool = true
	  //   }
	  //   this.world.verbose = bool
	  // }
	});

	/** use only the first result(s) */

	var _02Accessors = createCommonjsModule(function (module, exports) {
	  exports.first = function (n) {
	    if (n === undefined) {
	      return this.get(0);
	    }

	    return this.slice(0, n);
	  };
	  /** use only the last result(s) */


	  exports.last = function (n) {
	    if (n === undefined) {
	      return this.get(this.list.length - 1);
	    }

	    var end = this.list.length;
	    return this.slice(end - n, end);
	  };
	  /** grab a given subset of the results*/


	  exports.slice = function (start, end) {
	    var list = this.list.slice(start, end);
	    return this.buildFrom(list);
	  };
	  /* grab nth result */


	  exports.eq = function (n) {
	    var p = this.list[n];

	    if (p === undefined) {
	      return this.buildFrom([]);
	    }

	    return this.buildFrom([p]);
	  };

	  exports.get = exports.eq;
	  /** grab term[0] for every match */

	  exports.firstTerms = function () {
	    return this.match('^.');
	  };

	  exports.firstTerm = exports.firstTerms;
	  /** grab the last term for every match  */

	  exports.lastTerms = function () {
	    return this.match('.$');
	  };

	  exports.lastTerm = exports.lastTerms;
	  /** return a flat array of term objects */

	  exports.termList = function (num) {
	    var arr = []; //'reduce' but faster

	    for (var i = 0; i < this.list.length; i++) {
	      var terms = this.list[i].terms();

	      for (var o = 0; o < terms.length; o++) {
	        arr.push(terms[o]); //support .termList(4)

	        if (num !== undefined && arr[num] !== undefined) {
	          return arr[num];
	        }
	      }
	    }

	    return arr;
	  };
	  /* grab named capture group terms as object */


	  var getGroups = function getGroups(doc) {
	    var res = {};
	    var allGroups = {};

	    var _loop = function _loop(i) {
	      var phrase = doc.list[i];
	      var groups = Object.keys(phrase.groups).map(function (k) {
	        return phrase.groups[k];
	      });

	      for (var j = 0; j < groups.length; j++) {
	        var _groups$j = groups[j],
	            group = _groups$j.group,
	            start = _groups$j.start,
	            length = _groups$j.length;

	        if (!allGroups[group]) {
	          allGroups[group] = [];
	        }

	        allGroups[group].push(phrase.buildFrom(start, length));
	      }
	    };

	    for (var i = 0; i < doc.list.length; i++) {
	      _loop(i);
	    }

	    var keys = Object.keys(allGroups);

	    for (var _i = 0; _i < keys.length; _i++) {
	      var key = keys[_i];
	      res[key] = doc.buildFrom(allGroups[key]);
	    }

	    return res;
	  };
	  /** lookup a named-group, by its name */


	  var getOneName = function getOneName(doc, name) {
	    var arr = [];

	    var _loop2 = function _loop2(i) {
	      var phrase = doc.list[i];
	      var keys = Object.keys(phrase.groups);
	      keys = keys.filter(function (id) {
	        return phrase.groups[id].group === name;
	      });
	      keys.forEach(function (id) {
	        arr.push(phrase.buildFrom(phrase.groups[id].start, phrase.groups[id].length));
	      });
	    };

	    for (var i = 0; i < doc.list.length; i++) {
	      _loop2(i);
	    }

	    return doc.buildFrom(arr);
	  };
	  /** grab named capture group results */


	  exports.groups = function (target) {
	    if (target === undefined) {
	      return getGroups(this);
	    }

	    if (typeof target === 'number') {
	      target = String(target);
	    }

	    return getOneName(this, target) || this.buildFrom([]);
	  };

	  exports.group = exports.groups;
	  /** get the full-sentence each phrase belongs to */

	  exports.sentences = function (n) {
	    var arr = [];
	    this.list.forEach(function (p) {
	      arr.push(p.fullSentence());
	    });

	    if (typeof n === 'number') {
	      return this.buildFrom([arr[n]]);
	    }

	    return this.buildFrom(arr);
	  };

	  exports.sentence = exports.sentences;
	});

	// cache the easier conditions up-front
	var cacheRequired$1 = function cacheRequired(reg) {
	  var needTags = [];
	  var needWords = [];
	  reg.forEach(function (obj) {
	    if (obj.optional === true || obj.negative === true) {
	      return;
	    }

	    if (obj.tag !== undefined) {
	      needTags.push(obj.tag);
	    }

	    if (obj.word !== undefined) {
	      needWords.push(obj.word);
	    }
	  });
	  return {
	    tags: needTags,
	    words: needWords
	  };
	}; // try to pre-fail as many matches as possible, without doing them


	var failFast = function failFast(doc, regs) {
	  if (doc._cache && doc._cache.set === true) {
	    var _cacheRequired = cacheRequired$1(regs),
	        words = _cacheRequired.words,
	        tags = _cacheRequired.tags; //check required words


	    for (var i = 0; i < words.length; i++) {
	      if (doc._cache.words[words[i]] === undefined) {
	        return false;
	      }
	    } //check required tags


	    for (var _i = 0; _i < tags.length; _i++) {
	      if (doc._cache.tags[tags[_i]] === undefined) {
	        return false;
	      }
	    }
	  }

	  return true;
	};

	var _failFast = failFast;

	var _03Match = createCommonjsModule(function (module, exports) {
	  /** return a new Doc, with this one as a parent */
	  exports.match = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    // support '0' shorthand for named-groups
	    if (typeof opts === 'string' || typeof opts === 'number' || opts === null) {
	      opts = {
	        group: opts
	      };
	    } //parse-up the input expression


	    var regs = matchSyntax(reg, opts);

	    if (regs.length === 0) {
	      return this.buildFrom([]);
	    } //check our cache, if it exists


	    if (_failFast(this, regs) === false) {
	      return this.buildFrom([]);
	    } //try expression on each phrase


	    var matches = this.list.reduce(function (arr, p) {
	      return arr.concat(p.match(regs));
	    }, []); // support returning named groups

	    if (opts.group !== undefined && opts.group !== null && opts.group !== '') {
	      return this.buildFrom(matches).groups(opts.group);
	    }

	    return this.buildFrom(matches);
	  };
	  /** return all results except for this */


	  exports.not = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    //parse-up the input expression
	    var regs = matchSyntax(reg, opts); //if it's empty, return them all!

	    if (regs.length === 0 || _failFast(this, regs) === false) {
	      return this;
	    } //try expression on each phrase


	    var matches = this.list.reduce(function (arr, p) {
	      return arr.concat(p.not(regs));
	    }, []);
	    return this.buildFrom(matches);
	  };
	  /** return only the first match */


	  exports.matchOne = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var regs = matchSyntax(reg, opts); //check our cache, if it exists

	    if (_failFast(this, regs) === false) {
	      return this.buildFrom([]);
	    }

	    for (var i = 0; i < this.list.length; i++) {
	      var match = this.list[i].match(regs, true);
	      return this.buildFrom(match);
	    }

	    return this.buildFrom([]);
	  };
	  /** return each current phrase, only if it contains this match */


	  exports["if"] = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var regs = matchSyntax(reg, opts); //consult our cache, if it exists

	    if (_failFast(this, regs) === false) {
	      return this.buildFrom([]);
	    }

	    var found = this.list.filter(function (p) {
	      return p.has(regs) === true;
	    });
	    return this.buildFrom(found);
	  };
	  /** Filter-out any current phrases that have this match*/


	  exports.ifNo = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var regs = matchSyntax(reg, opts);
	    var found = this.list.filter(function (p) {
	      return p.has(regs) === false;
	    });
	    return this.buildFrom(found);
	  };
	  /**Return a boolean if this match exists */


	  exports.has = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var regs = matchSyntax(reg, opts); //consult our cache, if it exists

	    if (_failFast(this, regs) === false) {
	      return false;
	    }

	    return this.list.some(function (p) {
	      return p.has(regs) === true;
	    });
	  };
	  /** match any terms after our matches, within the sentence */


	  exports.lookAhead = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    // find everything afterwards, by default
	    if (!reg) {
	      reg = '.*';
	    }

	    var regs = matchSyntax(reg, opts);
	    var matches = [];
	    this.list.forEach(function (p) {
	      matches = matches.concat(p.lookAhead(regs));
	    });
	    matches = matches.filter(function (p) {
	      return p;
	    });
	    return this.buildFrom(matches);
	  };

	  exports.lookAfter = exports.lookAhead;
	  /** match any terms before our matches, within the sentence */

	  exports.lookBehind = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    // find everything afterwards, by default
	    if (!reg) {
	      reg = '.*';
	    }

	    var regs = matchSyntax(reg, opts);
	    var matches = [];
	    this.list.forEach(function (p) {
	      matches = matches.concat(p.lookBehind(regs));
	    });
	    matches = matches.filter(function (p) {
	      return p;
	    });
	    return this.buildFrom(matches);
	  };

	  exports.lookBefore = exports.lookBehind;
	  /** return all terms before a match, in each phrase */

	  exports.before = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var regs = matchSyntax(reg, opts); //only the phrases we care about

	    var phrases = this["if"](regs).list;
	    var befores = phrases.map(function (p) {
	      var ids = p.terms().map(function (t) {
	        return t.id;
	      }); //run the search again

	      var m = p.match(regs)[0];
	      var index = ids.indexOf(m.start); //nothing is before a first-term match

	      if (index === 0 || index === -1) {
	        return null;
	      }

	      return p.buildFrom(p.start, index);
	    });
	    befores = befores.filter(function (p) {
	      return p !== null;
	    });
	    return this.buildFrom(befores);
	  };
	  /** return all terms after a match, in each phrase */


	  exports.after = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var regs = matchSyntax(reg, opts); //only the phrases we care about

	    var phrases = this["if"](regs).list;
	    var befores = phrases.map(function (p) {
	      var terms = p.terms();
	      var ids = terms.map(function (t) {
	        return t.id;
	      }); //run the search again

	      var m = p.match(regs)[0];
	      var index = ids.indexOf(m.start); //skip if nothing is after it

	      if (index === -1 || !terms[index + m.length]) {
	        return null;
	      } //create the new phrase, after our match.


	      var id = terms[index + m.length].id;
	      var len = p.length - index - m.length;
	      return p.buildFrom(id, len);
	    });
	    befores = befores.filter(function (p) {
	      return p !== null;
	    });
	    return this.buildFrom(befores);
	  };
	  /** return only results with this match afterwards */


	  exports.hasAfter = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    return this.filter(function (doc) {
	      return doc.lookAfter(reg, opts).found;
	    });
	  };
	  /** return only results with this match before it */


	  exports.hasBefore = function (reg) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    return this.filter(function (doc) {
	      return doc.lookBefore(reg, opts).found;
	    });
	  };
	});

	/** apply a tag, or tags to all terms */
	var tagTerms = function tagTerms(tag, doc, safe, reason) {
	  var tagList = [];

	  if (typeof tag === 'string') {
	    tagList = tag.split(' ');
	  } // doc.parents()[0].reasons.push(reason)
	  //do indepenent tags for each term:


	  doc.list.forEach(function (p) {
	    var terms = p.terms(); // tagSafe - apply only to fitting terms

	    if (safe === true) {
	      terms = terms.filter(function (t) {
	        return t.canBe(tag, doc.world);
	      });
	    }

	    terms.forEach(function (t, i) {
	      //fancy version:
	      if (tagList.length > 1) {
	        if (tagList[i] && tagList[i] !== '.') {
	          t.tag(tagList[i], reason, doc.world);
	        }
	      } else {
	        //non-fancy version (same tag for all terms)
	        t.tag(tag, reason, doc.world);
	      }
	    });
	  });
	  return;
	};

	var _setTag = tagTerms;

	/** Give all terms the given tag */

	var tag = function tag(tags, why) {
	  if (!tags) {
	    return this;
	  }

	  _setTag(tags, this, false, why);
	  return this;
	};
	/** Only apply tag to terms if it is consistent with current tags */


	var tagSafe = function tagSafe(tags, why) {
	  if (!tags) {
	    return this;
	  }

	  _setTag(tags, this, true, why);
	  return this;
	};
	/** Remove this term from the given terms */


	var unTag = function unTag(tags, why) {
	  var _this = this;

	  this.list.forEach(function (p) {
	    p.terms().forEach(function (t) {
	      return t.unTag(tags, why, _this.world);
	    });
	  });
	  return this;
	};
	/** return only the terms that can be this tag*/


	var canBe = function canBe(tag) {
	  if (!tag) {
	    return this;
	  }

	  var world = this.world;
	  var matches = this.list.reduce(function (arr, p) {
	    return arr.concat(p.canBe(tag, world));
	  }, []);
	  return this.buildFrom(matches);
	};

	var _04Tag = {
	  tag: tag,
	  tagSafe: tagSafe,
	  unTag: unTag,
	  canBe: canBe
	};

	/* run each phrase through a function, and create a new document */
	var map = function map(fn) {
	  var _this = this;

	  if (!fn) {
	    return this;
	  }

	  var list = this.list.map(function (p, i) {
	    var doc = _this.buildFrom([p]);

	    doc.from = null; //it's not a child/parent

	    var res = fn(doc, i); // if its a doc, return one result

	    if (res && res.list && res.list[0]) {
	      return res.list[0];
	    }

	    return res;
	  }); //remove nulls

	  list = list.filter(function (x) {
	    return x;
	  }); // return an empty response

	  if (list.length === 0) {
	    return this.buildFrom(list);
	  } // if it is not a list of Phrase objects, then don't try to make a Doc object


	  if (_typeof(list[0]) !== 'object' || list[0].isA !== 'Phrase') {
	    return list;
	  }

	  return this.buildFrom(list);
	};
	/** run a function on each phrase */


	var forEach = function forEach(fn, detachParent) {
	  var _this2 = this;

	  if (!fn) {
	    return this;
	  }

	  this.list.forEach(function (p, i) {
	    var sub = _this2.buildFrom([p]); // if we're doing fancy insertions, we may want to skip updating the parent each time.


	    if (detachParent === true) {
	      sub.from = null; //
	    }

	    fn(sub, i);
	  });
	  return this;
	};
	/** return only the phrases that return true */


	var filter = function filter(fn) {
	  var _this3 = this;

	  if (!fn) {
	    return this;
	  }

	  var list = this.list.filter(function (p, i) {
	    var doc = _this3.buildFrom([p]);

	    doc.from = null; //it's not a child/parent

	    return fn(doc, i);
	  });
	  return this.buildFrom(list);
	};
	/** return a document with only the first phrase that matches */


	var find = function find(fn) {
	  var _this4 = this;

	  if (!fn) {
	    return this;
	  }

	  var phrase = this.list.find(function (p, i) {
	    var doc = _this4.buildFrom([p]);

	    doc.from = null; //it's not a child/parent

	    return fn(doc, i);
	  });

	  if (phrase) {
	    return this.buildFrom([phrase]);
	  }

	  return undefined;
	};
	/** return true or false if there is one matching phrase */


	var some = function some(fn) {
	  var _this5 = this;

	  if (!fn) {
	    return this;
	  }

	  return this.list.some(function (p, i) {
	    var doc = _this5.buildFrom([p]);

	    doc.from = null; //it's not a child/parent

	    return fn(doc, i);
	  });
	};
	/** sample a subset of the results */


	var random = function random(n) {
	  if (!this.found) {
	    return this;
	  }

	  var r = Math.floor(Math.random() * this.list.length);

	  if (n === undefined) {
	    var list = [this.list[r]];
	    return this.buildFrom(list);
	  } //prevent it from going over the end


	  if (r + n > this.length) {
	    r = this.length - n;
	    r = r < 0 ? 0 : r;
	  }

	  return this.slice(r, r + n);
	};
	/** combine each phrase into a new data-structure */
	// exports.reduce = function(fn, h) {
	//   let list = this.list.reduce((_h, ts) => {
	//     let doc = this.buildFrom([ts])
	//     doc.from = null //it's not a child/parent
	//     return fn(_h, doc)
	//   }, h)
	//   return this.buildFrom(list)
	// }


	var _05Loops = {
	  map: map,
	  forEach: forEach,
	  filter: filter,
	  find: find,
	  some: some,
	  random: random
	};

	// const tokenize = require('../../01-tokenizer/02-words')
	var tokenize = function tokenize(str) {
	  return str.split(/[ -]/g);
	}; // take a list of strings
	// look them up in the document


	var buildTree = function buildTree(termList) {
	  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  var root = {}; // parse our input

	  termList.forEach(function (str, i) {
	    var val = true;

	    if (values[i] !== undefined) {
	      val = values[i];
	    } // some rough normalization


	    str = (str || '').toLowerCase();
	    str = str.replace(/[,;.!?]+$/, '');
	    var arr = tokenize(str).map(function (s) {
	      return s.trim();
	    });
	    root[arr[0]] = root[arr[0]] || {};

	    if (arr.length === 1) {
	      root[arr[0]].value = val;
	    } else {
	      root[arr[0]].more = root[arr[0]].more || [];
	      root[arr[0]].more.push({
	        rest: arr.slice(1),
	        value: val
	      });
	    }
	  }); // sort by longest-first?
	  // console.log(JSON.stringify(root, null, 2))

	  return root;
	};

	var fastLookup = function fastLookup(termList, values, doc) {
	  var root = buildTree(termList, values);
	  var found = []; // each phrase

	  var _loop = function _loop(i) {
	    var p = doc.list[i];
	    var terms = p.terms();
	    var words = terms.map(function (t) {
	      return t.reduced;
	    }); // each word

	    var _loop2 = function _loop2(w) {
	      if (root[words[w]] !== undefined) {
	        // is it a multi-word match?
	        if (root[words[w]].more !== undefined) {
	          root[words[w]].more.forEach(function (more) {
	            // is it too-long?
	            if (words[w + more.rest.length] === undefined) {
	              return;
	            } // compare each subsequent term


	            var everyTerm = more.rest.every(function (word, r) {
	              return word === words[w + r + 1];
	            });

	            if (everyTerm === true) {
	              found.push({
	                id: p.terms()[w].id,
	                value: more.value,
	                length: more.rest.length + 1
	              });
	            }
	          });
	        } // is it a single-word match?


	        if (root[words[w]].value !== undefined) {
	          found.push({
	            id: p.terms()[w].id,
	            value: root[words[w]].value,
	            length: 1
	          });
	        }
	      }
	    };

	    for (var w = 0; w < words.length; w++) {
	      _loop2(w);
	    }
	  };

	  for (var i = 0; i < doc.list.length; i++) {
	    _loop(i);
	  }

	  return found;
	};

	var _lookup = fastLookup;

	var _06Lookup = createCommonjsModule(function (module, exports) {
	  // compare one term and one match
	  // const doesMatch = function(term, str) {
	  //   if (str === '') {
	  //     return false
	  //   }
	  //   return term.reduced === str || term.implicit === str || term.root === str || term.text.toLowerCase() === str
	  // }
	  var isObject = function isObject(obj) {
	    return obj && Object.prototype.toString.call(obj) === '[object Object]';
	  };
	  /** lookup an array of words or phrases */


	  exports.lookup = function (arr) {
	    var _this = this;

	    var values = []; //is it a {key:val} object?

	    var isObj = isObject(arr);

	    if (isObj === true) {
	      arr = Object.keys(arr).map(function (k) {
	        values.push(arr[k]);
	        return k;
	      });
	    } // support .lookup('foo')


	    if (typeof arr === 'string') {
	      arr = [arr];
	    } //make sure we go fast.


	    if (this._cache.set !== true) {
	      this.cache();
	    }

	    var found = _lookup(arr, values, this);
	    var p = this.list[0]; // make object response

	    if (isObj === true) {
	      var byVal = {};
	      found.forEach(function (o) {
	        byVal[o.value] = byVal[o.value] || [];
	        byVal[o.value].push(p.buildFrom(o.id, o.length));
	      });
	      Object.keys(byVal).forEach(function (k) {
	        byVal[k] = _this.buildFrom(byVal[k]);
	      });
	      return byVal;
	    } // otherwise, make array response:


	    found = found.map(function (o) {
	      return p.buildFrom(o.id, o.length);
	    });
	    return this.buildFrom(found);
	  };

	  exports.lookUp = exports.lookup;
	});

	/** freeze the current state of the document, for speed-purposes*/
	var cache = function cache(options) {
	  var _this = this;

	  options = options || {};
	  var words = {};
	  var tags = {};
	  this._cache.words = words;
	  this._cache.tags = tags;
	  this._cache.set = true;
	  this.list.forEach(function (p, i) {
	    p.cache = p.cache || {}; //p.terms get cached automatically

	    var terms = p.terms(); // cache all the terms

	    terms.forEach(function (t) {
	      if (words[t.reduced] && !words.hasOwnProperty(t.reduced)) {
	        return; //skip prototype words
	      }

	      words[t.reduced] = words[t.reduced] || [];
	      words[t.reduced].push(i);
	      Object.keys(t.tags).forEach(function (tag) {
	        tags[tag] = tags[tag] || [];
	        tags[tag].push(i);
	      }); // cache root-form on Term, too

	      if (options.root) {
	        t.setRoot(_this.world);
	        words[t.root] = [i];
	      }
	    });
	  });
	  return this;
	};
	/** un-freezes the current state of the document, so it may be transformed */


	var uncache = function uncache() {
	  this._cache = {};
	  this.list.forEach(function (p) {
	    p.cache = {};
	  }); // do parents too?

	  this.parents().forEach(function (doc) {
	    doc._cache = {};
	    doc.list.forEach(function (p) {
	      p.cache = {};
	    });
	  });
	  return this;
	};

	var _07Cache = {
	  cache: cache,
	  uncache: uncache
	};

	var titleCase$1 = function titleCase(str) {
	  return str.charAt(0).toUpperCase() + str.substr(1);
	};
	/** substitute-in new content */


	var replaceWith = function replaceWith(replace) {
	  var _this = this;

	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  if (!replace) {
	    return this["delete"]();
	  } //support old-style params


	  if (options === true) {
	    options = {
	      keepTags: true
	    };
	  }

	  if (options === false) {
	    options = {
	      keepTags: false
	    };
	  }

	  options = options || {}; // clear the cache

	  this.uncache(); // return this

	  this.list.forEach(function (p) {
	    var input = replace; // accept a function for replace

	    if (typeof replace === 'function') {
	      input = replace(p);
	    }

	    var newPhrases; // accept a Doc object to replace

	    if (input && _typeof(input) === 'object' && input.isA === 'Doc') {
	      newPhrases = input.list;

	      _this.pool().merge(input.pool());
	    } else if (typeof input === 'string') {
	      //input is a string
	      if (options.keepCase !== false && p.terms(0).isTitleCase()) {
	        input = titleCase$1(input);
	      }

	      newPhrases = _01Tokenizer(input, _this.world, _this.pool()); //tag the new phrases

	      var tmpDoc = _this.buildFrom(newPhrases);

	      tmpDoc.tagger();
	      newPhrases = tmpDoc.list;
	    } else {
	      return; //don't even bother
	    } // try to keep its old tags, if appropriate


	    if (options.keepTags === true) {
	      var oldTags = p.json({
	        terms: {
	          tags: true
	        }
	      }).terms;
	      newPhrases[0].terms().forEach(function (t, i) {
	        if (oldTags[i]) {
	          t.tagSafe(oldTags[i].tags, 'keptTag', _this.world);
	        }
	      });
	    }

	    p.replace(newPhrases[0], _this); //Oneday: support multi-sentence replacements
	  });
	  return this;
	};
	/** search and replace match with new content */


	var replace = function replace(match, _replace, options) {
	  // if there's no 2nd param, use replaceWith
	  if (_replace === undefined) {
	    return this.replaceWith(match, options);
	  }

	  this.match(match).replaceWith(_replace, options);
	  return this;
	};

	var _01Replace = {
	  replaceWith: replaceWith,
	  replace: replace
	};

	var _02Insert = createCommonjsModule(function (module, exports) {
	  var isObject = function isObject(obj) {
	    return obj && Object.prototype.toString.call(obj) === '[object Object]';
	  }; // if it's empty, just create the phrase


	  var makeNew = function makeNew(str, doc) {
	    var phrase = _01Tokenizer(str, doc.world)[0]; //assume it's one sentence, for now

	    var tmpDoc = doc.buildFrom([phrase]);
	    tmpDoc.tagger();
	    doc.list = tmpDoc.list;
	    return doc;
	  };
	  /** add these new terms to the end*/


	  exports.append = function () {
	    var _this = this;

	    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	    if (!str) {
	      return this;
	    } // if it's empty, just create the phrase


	    if (!this.found) {
	      return makeNew(str, this);
	    } // clear the cache


	    this.uncache(); //add it to end of every phrase

	    this.list.forEach(function (p) {
	      //build it
	      var phrase;

	      if (isObject(str) && str.isA === 'Doc') {
	        phrase = str.list[0].clone(); //use the first phrase
	      } else if (typeof str === 'string') {
	        phrase = _01Tokenizer(str, _this.world, _this.pool())[0]; //assume it's one sentence, for now
	      } //tag it


	      var tmpDoc = _this.buildFrom([phrase]);

	      tmpDoc.tagger(); // push it onto the end

	      p.append(phrase, _this);
	    });
	    return this;
	  };

	  exports.insertAfter = exports.append;
	  exports.insertAt = exports.append;
	  /** add these new terms to the front*/

	  exports.prepend = function (str) {
	    var _this2 = this;

	    if (!str) {
	      return this;
	    } // if it's empty, just create the phrase


	    if (!this.found) {
	      return makeNew(str, this);
	    } // clear the cache


	    this.uncache(); //add it to start of every phrase

	    this.list.forEach(function (p) {
	      //build it
	      var phrase;

	      if (isObject(str) && str.isA === 'Doc') {
	        phrase = str.list[0].clone(); //use the first phrase
	      } else if (typeof str === 'string') {
	        phrase = _01Tokenizer(str, _this2.world, _this2.pool())[0]; //assume it's one sentence, for now
	      } //tag it


	      var tmpDoc = _this2.buildFrom([phrase]);

	      tmpDoc.tagger(); // add it to the start

	      p.prepend(phrase, _this2);
	    });
	    return this;
	  };

	  exports.insertBefore = exports.prepend;
	  /** add these new things to the end*/

	  exports.concat = function () {
	    // clear the cache
	    this.uncache();
	    var list = this.list.slice(0); //repeat for any number of params

	    for (var i = 0; i < arguments.length; i++) {
	      var arg = arguments[i]; //support a fresh string

	      if (typeof arg === 'string') {
	        var arr = _01Tokenizer(arg, this.world); //TODO: phrase.tagger()?

	        list = list.concat(arr);
	      } else if (arg.isA === 'Doc') {
	        list = list.concat(arg.list);
	      } else if (arg.isA === 'Phrase') {
	        list.push(arg);
	      }
	    }

	    return this.buildFrom(list);
	  };
	  /** fully remove these terms from the document */


	  exports["delete"] = function (match) {
	    var _this3 = this;

	    // clear the cache
	    this.uncache();
	    var toRemove = this;

	    if (match) {
	      toRemove = this.match(match);
	    }

	    toRemove.list.forEach(function (phrase) {
	      return phrase["delete"](_this3);
	    });
	    return this;
	  }; // aliases


	  exports.remove = exports["delete"];
	});

	var shouldTrim = {
	  clean: true,
	  reduced: true,
	  root: true
	};
	/** return the document as text */

	var text = function text(options) {
	  var _this = this;

	  options = options || {}; //are we showing every phrase?

	  var showFull = false;

	  if (this.parents().length === 0) {
	    showFull = true;
	  } // cache roots, if necessary


	  if (options === 'root' || _typeof(options) === 'object' && options.root) {
	    this.list.forEach(function (p) {
	      p.terms().forEach(function (t) {
	        if (t.root === null) {
	          t.setRoot(_this.world);
	        }
	      });
	    });
	  }

	  var txt = this.list.reduce(function (str, p, i) {
	    var trimPre = !showFull && i === 0;
	    var trimPost = !showFull && i === _this.list.length - 1;
	    return str + p.text(options, trimPre, trimPost);
	  }, ''); // clumsy final trim of leading/trailing whitespace

	  if (shouldTrim[options] === true || options.reduced === true || options.clean === true || options.root === true) {
	    txt = txt.trim();
	  }

	  return txt;
	};

	var _01Text = {
	  text: text
	};

	// get all character startings in doc
	var termOffsets = function termOffsets(doc) {
	  var elapsed = 0;
	  var index = 0;
	  var offsets = {};
	  doc.termList().forEach(function (term) {
	    offsets[term.id] = {
	      index: index,
	      start: elapsed + term.pre.length,
	      length: term.text.length
	    };
	    elapsed += term.pre.length + term.text.length + term.post.length;
	    index += 1;
	  });
	  return offsets;
	};

	var calcOffset = function calcOffset(doc, result, options) {
	  // calculate offsets for each term
	  var offsets = termOffsets(doc.all()); // add index values

	  if (options.terms.index || options.index) {
	    result.forEach(function (o) {
	      o.terms.forEach(function (t) {
	        t.index = offsets[t.id].index;
	      });
	      o.index = o.terms[0].index;
	    });
	  } // add offset values


	  if (options.terms.offset || options.offset) {
	    result.forEach(function (o) {
	      o.terms.forEach(function (t) {
	        t.offset = offsets[t.id] || {};
	      }); // let len = o.terms.reduce((n, t, i) => {
	      //   n += t.offset.length || 0
	      //   //add whitespace, too
	      //   console.log(t.post)
	      //   return n
	      // }, 0)
	      // The offset information for the entire doc starts at (or just before)
	      // the first term, and is as long as the whole text.  The code originally
	      // copied the entire offset value from terms[0], but since we're now
	      // overriding 2 of the three fields, it's cleaner to just create an all-
	      // new object and not pretend it's "just" the same as terms[0].

	      o.offset = {
	        index: o.terms[0].offset.index,
	        start: o.terms[0].offset.start - o.text.indexOf(o.terms[0].text),
	        length: o.text.length
	      };
	    });
	  }
	};

	var _offset = calcOffset;

	var _02Json = createCommonjsModule(function (module, exports) {
	  var jsonDefaults = {
	    text: true,
	    terms: true,
	    trim: true
	  }; //some options have dependents

	  var setOptions = function setOptions(options) {
	    options = Object.assign({}, jsonDefaults, options);

	    if (options.unique) {
	      options.reduced = true;
	    } //offset calculation requires these options to be on


	    if (options.offset) {
	      options.text = true;

	      if (!options.terms || options.terms === true) {
	        options.terms = {};
	      }

	      options.terms.offset = true;
	    }

	    if (options.index || options.terms.index) {
	      options.terms = options.terms === true ? {} : options.terms;
	      options.terms.id = true;
	    }

	    return options;
	  };
	  /** pull out desired metadata from the document */


	  exports.json = function () {
	    var _this = this;

	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    //support json(3) format
	    if (typeof options === 'number' && this.list[options]) {
	      return this.list[options].json(jsonDefaults);
	    }

	    options = setOptions(options); // cache root strings beforehand, if necessary

	    if (options.root === true) {
	      this.list.forEach(function (p) {
	        p.terms().forEach(function (t) {
	          if (t.root === null) {
	            t.setRoot(_this.world);
	          }
	        });
	      });
	    }

	    var result = this.list.map(function (p) {
	      return p.json(options, _this.world);
	    }); // add offset and index data for each term

	    if (options.terms.offset || options.offset || options.terms.index || options.index) {
	      _offset(this, result, options);
	    } // add frequency #s


	    if (options.frequency || options.freq || options.count) {
	      var obj = {};
	      this.list.forEach(function (p) {
	        var str = p.text('reduced');
	        obj[str] = obj[str] || 0;
	        obj[str] += 1;
	      });
	      this.list.forEach(function (p, i) {
	        result[i].count = obj[p.text('reduced')];
	      });
	    } // remove duplicates


	    if (options.unique) {
	      var already = {};
	      result = result.filter(function (o) {
	        if (already[o.reduced] === true) {
	          return false;
	        }

	        already[o.reduced] = true;
	        return true;
	      });
	    }

	    return result;
	  }; //aliases


	  exports.data = exports.json;
	});

	var _debug = createCommonjsModule(function (module) {
	  // https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color
	  var reset = '\x1b[0m';

	  var padEnd = function padEnd(str, width) {
	    str = str.toString();

	    while (str.length < width) {
	      str += ' ';
	    }

	    return str;
	  };

	  function isClientSide() {
	    return typeof window !== 'undefined' && window.document;
	  } // some nice colors for client-side debug


	  var css = {
	    green: '#7f9c6c',
	    red: '#914045',
	    blue: '#6699cc',
	    magenta: '#6D5685',
	    cyan: '#2D85A8',
	    yellow: '#e6d7b3',
	    black: '#303b50'
	  };

	  var logClientSide = function logClientSide(doc) {
	    var tagset = doc.world.tags;
	    doc.list.forEach(function (p) {
	      console.log('\n%c"' + p.text() + '"', 'color: #e6d7b3;');
	      var terms = p.terms();
	      terms.forEach(function (t) {
	        var tags = Object.keys(t.tags);
	        var text = t.text || '-';

	        if (t.implicit) {
	          text = '[' + t.implicit + ']';
	        }

	        var word = "'" + text + "'";
	        word = padEnd(word, 8);
	        var found = tags.find(function (tag) {
	          return tagset[tag] && tagset[tag].color;
	        });
	        var color = 'steelblue';

	        if (tagset[found]) {
	          color = tagset[found].color;
	          color = css[color];
	        }

	        console.log("   ".concat(word, "  -  %c").concat(tags.join(', ')), "color: ".concat(color || 'steelblue', ";"));
	      });
	    });
	  }; //cheaper than requiring chalk


	  var cli = {
	    green: function green(str) {
	      return '\x1b[32m' + str + reset;
	    },
	    red: function red(str) {
	      return '\x1b[31m' + str + reset;
	    },
	    blue: function blue(str) {
	      return '\x1b[34m' + str + reset;
	    },
	    magenta: function magenta(str) {
	      return '\x1b[35m' + str + reset;
	    },
	    cyan: function cyan(str) {
	      return '\x1b[36m' + str + reset;
	    },
	    yellow: function yellow(str) {
	      return '\x1b[33m' + str + reset;
	    },
	    black: function black(str) {
	      return '\x1b[30m' + str + reset;
	    }
	  };

	  var tagString = function tagString(tags, world) {
	    tags = tags.map(function (tag) {
	      if (!world.tags.hasOwnProperty(tag)) {
	        return tag;
	      }

	      var c = world.tags[tag].color || 'blue';
	      return cli[c](tag);
	    });
	    return tags.join(', ');
	  }; //output some helpful stuff to the console


	  var debug = function debug(doc) {
	    if (isClientSide()) {
	      logClientSide(doc);
	      return doc;
	    }

	    console.log(cli.blue('====='));
	    doc.list.forEach(function (p) {
	      console.log(cli.blue('  -----'));
	      var terms = p.terms();
	      terms.forEach(function (t) {
	        var tags = Object.keys(t.tags);
	        var text = t.text || '-';

	        if (t.implicit) {
	          text = '[' + t.implicit + ']';
	        }

	        {
	          text = cli.yellow(text);
	        }

	        var word = "'" + text + "'";
	        word = padEnd(word, 18);
	        var str = cli.blue('   ') + word + '  - ' + tagString(tags, doc.world);
	        console.log(str);
	      });
	    });
	    console.log('');
	    return doc;
	  };

	  module.exports = debug;
	});

	var topk = function topk(doc) {
	  var list = doc.json({
	    text: false,
	    terms: false,
	    reduced: true
	  }); // combine them

	  var obj = {};
	  list.forEach(function (o) {
	    if (!obj[o.reduced]) {
	      o.count = 0;
	      obj[o.reduced] = o;
	    }

	    obj[o.reduced].count += 1;
	  });
	  var arr = Object.keys(obj).map(function (k) {
	    return obj[k];
	  }); // sort them

	  arr.sort(function (a, b) {
	    if (a.count > b.count) {
	      return -1;
	    } else if (a.count < b.count) {
	      return 1;
	    }

	    return 0;
	  });
	  return arr;
	};

	var _topk = topk;

	/** pretty-print the current document and its tags */

	var debug_1 = function debug_1() {
	  _debug(this);
	  return this;
	};
	/** some named output formats */


	var out = function out(method) {
	  if (method === 'text') {
	    return this.text();
	  }

	  if (method === 'normal') {
	    return this.text('normal');
	  }

	  if (method === 'json') {
	    return this.json();
	  }

	  if (method === 'offset' || method === 'offsets') {
	    return this.json({
	      offset: true
	    });
	  }

	  if (method === 'array') {
	    return this.json({
	      terms: false
	    }).map(function (obj) {
	      return obj.text;
	    }).filter(function (str) {
	      return str;
	    });
	  }

	  if (method === 'freq' || method === 'frequency') {
	    return _topk(this);
	  }

	  if (method === 'terms') {
	    var list = [];
	    this.json({
	      text: false,
	      terms: {
	        text: true
	      }
	    }).forEach(function (obj) {
	      var terms = obj.terms.map(function (t) {
	        return t.text;
	      });
	      terms = terms.filter(function (t) {
	        return t;
	      });
	      list = list.concat(terms);
	    });
	    return list;
	  }

	  if (method === 'tags') {
	    return this.list.map(function (p) {
	      return p.terms().reduce(function (h, t) {
	        h[t.clean || t.implicit] = Object.keys(t.tags);
	        return h;
	      }, {});
	    });
	  }

	  if (method === 'debug') {
	    _debug(this);
	    return this;
	  }

	  return this.text();
	};

	var _03Out = {
	  debug: debug_1,
	  out: out
	};

	var methods$6 = {
	  /** alphabetical order */
	  alpha: function alpha(a, b) {
	    var left = a.text('clean');
	    var right = b.text('clean');

	    if (left < right) {
	      return -1;
	    }

	    if (left > right) {
	      return 1;
	    }

	    return 0;
	  },

	  /** count the # of characters of each match */
	  length: function length(a, b) {
	    var left = a.text().trim().length;
	    var right = b.text().trim().length;

	    if (left < right) {
	      return 1;
	    }

	    if (left > right) {
	      return -1;
	    }

	    return 0;
	  },

	  /** count the # of terms in each match */
	  wordCount: function wordCount(a, b) {
	    var left = a.wordCount();
	    var right = b.wordCount();

	    if (left < right) {
	      return 1;
	    }

	    if (left > right) {
	      return -1;
	    }

	    return 0;
	  }
	};
	/** sort by # of duplicates in the document*/

	var byFreq = function byFreq(doc) {
	  var counts = {};
	  var options = {
	    "case": true,
	    punctuation: false,
	    whitespace: true,
	    unicode: true
	  };
	  doc.list.forEach(function (p) {
	    var str = p.text(options);
	    counts[str] = counts[str] || 0;
	    counts[str] += 1;
	  }); // sort by freq

	  doc.list.sort(function (a, b) {
	    var left = counts[a.text(options)];
	    var right = counts[b.text(options)];

	    if (left < right) {
	      return 1;
	    }

	    if (left > right) {
	      return -1;
	    }

	    return 0;
	  });
	  return doc;
	}; // order results 'chronologically', or document-order


	var sortSequential = function sortSequential(doc) {
	  var order = {};
	  doc.json({
	    terms: {
	      offset: true
	    }
	  }).forEach(function (o) {
	    order[o.terms[0].id] = o.terms[0].offset.start;
	  });
	  doc.list = doc.list.sort(function (a, b) {
	    if (order[a.start] > order[b.start]) {
	      return 1;
	    } else if (order[a.start] < order[b.start]) {
	      return -1;
	    }

	    return 0;
	  });
	  return doc;
	}; //aliases


	methods$6.alphabetical = methods$6.alpha;
	methods$6.wordcount = methods$6.wordCount; // aliases for sequential ordering

	var seqNames = {
	  index: true,
	  sequence: true,
	  seq: true,
	  sequential: true,
	  chron: true,
	  chronological: true
	};
	/** re-arrange the order of the matches (in place) */

	var sort = function sort(input) {
	  input = input || 'alpha'; //do this one up-front

	  if (input === 'freq' || input === 'frequency' || input === 'topk') {
	    return byFreq(this);
	  }

	  if (seqNames.hasOwnProperty(input)) {
	    return sortSequential(this);
	  }

	  input = methods$6[input] || input; // apply sort method on each phrase

	  if (typeof input === 'function') {
	    this.list = this.list.sort(input);
	    return this;
	  }

	  return this;
	};
	/** reverse the order of the matches, but not the words */


	var reverse = function reverse() {
	  var list = [].concat(this.list);
	  list = list.reverse();
	  return this.buildFrom(list);
	};
	/** remove any duplicate matches */


	var unique$1 = function unique() {
	  var list = [].concat(this.list);
	  var obj = {};
	  list = list.filter(function (p) {
	    var str = p.text('reduced').trim() || p.text('implicit').trim();

	    if (obj.hasOwnProperty(str) === true) {
	      return false;
	    }

	    obj[str] = true;
	    return true;
	  });
	  return this.buildFrom(list);
	};

	var _01Sort = {
	  sort: sort,
	  reverse: reverse,
	  unique: unique$1
	};

	var isPunct = /[\[\]{}:,\-;\/*\^%=~|]/g;
	var quotes = /['"]+/g;
	var methods$5 = {
	  // cleanup newlines and extra spaces
	  whitespace: function whitespace(doc) {
	    var termArr = doc.list.map(function (ts) {
	      return ts.terms();
	    });
	    termArr.forEach(function (terms, o) {
	      terms.forEach(function (t, i) {
	        // keep dashes between words
	        if (t.hasDash() === true) {
	          t.post = ' - ';
	          return;
	        } // remove existing spaces


	        t.pre = t.pre.replace(/\s/g, '');
	        t.post = t.post.replace(/\s/g, ''); //last word? ensure there's a next sentence.

	        if (terms.length - 1 === i && !termArr[o + 1]) {
	          return;
	        } // no extra spaces for contractions


	        if (t.implicit && Boolean(t.text) === true) {
	          return;
	        } // no extra spaces for hyphenated words


	        if (t.hasHyphen() === true) {
	          return;
	        }

	        t.post += ' ';
	      });
	    });
	  },
	  punctuation: function punctuation(termList) {
	    termList.forEach(function (t) {
	      // space between hyphenated words
	      if (t.hasHyphen() === true) {
	        t.post = ' ';
	      }

	      t.pre = t.pre.replace(isPunct, '');
	      t.post = t.post.replace(isPunct, ''); // elipses

	      t.post = t.post.replace(/\.\.\./, ''); // only allow one exclamation

	      if (/!/.test(t.post) === true) {
	        t.post = t.post.replace(/!/g, '');
	        t.post = '!' + t.post;
	      } // only allow one question mark


	      if (/\?/.test(t.post) === true) {
	        t.post = t.post.replace(/[\?!]*/, '');
	        t.post = '?' + t.post;
	      }
	    });
	  },
	  unicode: function unicode(termList) {
	    termList.forEach(function (t) {
	      if (t.isImplicit() === true) {
	        return;
	      }

	      t.text = unicode_1(t.text);
	    });
	  },
	  quotations: function quotations(termList) {
	    termList.forEach(function (t) {
	      t.post = t.post.replace(quotes, '');
	      t.pre = t.pre.replace(quotes, '');
	    });
	  },
	  adverbs: function adverbs(doc) {
	    doc.match('#Adverb').not('(not|nary|seldom|never|barely|almost|basically|so)').remove();
	  },
	  // remove the '.' from 'Mrs.' (safely)
	  abbreviations: function abbreviations(doc) {
	    doc.list.forEach(function (ts) {
	      var terms = ts.terms();
	      terms.forEach(function (t, i) {
	        if (t.tags.Abbreviation === true && terms[i + 1]) {
	          t.post = t.post.replace(/^\./, '');
	        }
	      });
	    });
	  }
	};
	var _methods = methods$5;

	var defaults$1 = {
	  // light
	  whitespace: true,
	  unicode: true,
	  punctuation: true,
	  emoji: true,
	  acronyms: true,
	  abbreviations: true,
	  // medium
	  "case": false,
	  contractions: false,
	  parentheses: false,
	  quotations: false,
	  adverbs: false,
	  // heavy (loose legibility)
	  possessives: false,
	  verbs: false,
	  nouns: false,
	  honorifics: false // pronouns: true,

	};
	var mapping = {
	  light: {},
	  medium: {
	    "case": true,
	    contractions: true,
	    parentheses: true,
	    quotations: true,
	    adverbs: true
	  }
	};
	mapping.heavy = Object.assign({}, mapping.medium, {
	  possessives: true,
	  verbs: true,
	  nouns: true,
	  honorifics: true
	});
	/** common ways to clean-up the document, and reduce noise */

	var normalize = function normalize(options) {
	  options = options || {}; // support named forms

	  if (typeof options === 'string') {
	    options = mapping[options] || {};
	  } // set defaults


	  options = Object.assign({}, defaults$1, options); // clear the cache

	  this.uncache();
	  var termList = this.termList(); // lowercase things

	  if (options["case"]) {
	    this.toLowerCase();
	  } //whitespace


	  if (options.whitespace) {
	    _methods.whitespace(this);
	  } // unicode:  -> e


	  if (options.unicode) {
	    _methods.unicode(termList);
	  } //punctuation - keep sentence punctation, quotes, parenths


	  if (options.punctuation) {
	    _methods.punctuation(termList);
	  } // remove ':)'


	  if (options.emoji) {
	    this.remove('(#Emoji|#Emoticon)');
	  } // 'f.b.i.' -> 'FBI'


	  if (options.acronyms) {
	    this.acronyms().strip(); // .toUpperCase()
	  } // remove period from abbreviations


	  if (options.abbreviations) {
	    _methods.abbreviations(this);
	  } // --Medium methods--
	  // `isn't` -> 'is not'


	  if (options.contraction || options.contractions) {
	    this.contractions().expand();
	  } // '(word)' -> 'word'


	  if (options.parentheses) {
	    this.parentheses().unwrap();
	  } // remove "" punctuation


	  if (options.quotations || options.quotes) {
	    _methods.quotations(termList);
	  } // remove any un-necessary adverbs


	  if (options.adverbs) {
	    _methods.adverbs(this);
	  } // --Heavy methods--
	  // `cory hart's -> cory hart'


	  if (options.possessive || options.possessives) {
	    this.possessives().strip();
	  } // 'he walked' -> 'he walk'


	  if (options.verbs) {
	    this.verbs().toInfinitive();
	  } // 'three dogs' -> 'three dog'


	  if (options.nouns || options.plurals) {
	    this.nouns().toSingular();
	  } // remove 'Mr.' from 'Mr John Smith'


	  if (options.honorifics) {
	    this.remove('#Honorific');
	  }

	  return this;
	};

	var _02Normalize = {
	  normalize: normalize
	};

	var _03Split = createCommonjsModule(function (module, exports) {
	  /** return a Document with three parts for every match
	   * seperate everything before the word, as a new phrase
	   */
	  exports.splitOn = function (reg) {
	    // if there's no match, split parent, instead
	    if (!reg) {
	      var parent = this.parent();
	      return parent.splitOn(this);
	    } //start looking for a match..


	    var regs = matchSyntax(reg);
	    var matches = [];
	    this.list.forEach(function (p) {
	      var foundEm = p.match(regs); //no match here, add full sentence

	      if (foundEm.length === 0) {
	        matches.push(p);
	        return;
	      } // we found something here.


	      var carry = p;
	      foundEm.forEach(function (found) {
	        var parts = carry.splitOn(found); // add em in

	        if (parts.before) {
	          matches.push(parts.before);
	        }

	        if (parts.match) {
	          matches.push(parts.match);
	        } // start matching now on the end


	        carry = parts.after;
	      }); // add that last part

	      if (carry) {
	        matches.push(carry);
	      }
	    });
	    return this.buildFrom(matches);
	  };
	  /** return a Document with two parts for every match
	   * seperate everything after the word, as a new phrase
	   */


	  exports.splitAfter = function (reg) {
	    // if there's no match, split parent, instead
	    if (!reg) {
	      var parent = this.parent();
	      return parent.splitAfter(this);
	    } // start looking for our matches


	    var regs = matchSyntax(reg);
	    var matches = [];
	    this.list.forEach(function (p) {
	      var foundEm = p.match(regs); //no match here, add full sentence

	      if (foundEm.length === 0) {
	        matches.push(p);
	        return;
	      } // we found something here.


	      var carry = p;
	      foundEm.forEach(function (found) {
	        var parts = carry.splitOn(found); // add em in

	        if (parts.before && parts.match) {
	          // merge these two together
	          parts.before.length += parts.match.length;
	          matches.push(parts.before);
	        } else if (parts.match) {
	          matches.push(parts.match);
	        } // start matching now on the end


	        carry = parts.after;
	      }); // add that last part

	      if (carry) {
	        matches.push(carry);
	      }
	    });
	    return this.buildFrom(matches);
	  };

	  exports.split = exports.splitAfter; //i guess?

	  /** return a Document with two parts for every match */

	  exports.splitBefore = function (reg) {
	    // if there's no match, split parent, instead
	    if (!reg) {
	      var parent = this.parent();
	      return parent.splitBefore(this);
	    } //start looking for a match..


	    var regs = matchSyntax(reg);
	    var matches = [];
	    this.list.forEach(function (p) {
	      var foundEm = p.match(regs); //no match here, add full sentence

	      if (foundEm.length === 0) {
	        matches.push(p);
	        return;
	      } // we found something here.


	      var carry = p;
	      foundEm.forEach(function (found) {
	        var parts = carry.splitOn(found); // add before part in

	        if (parts.before) {
	          matches.push(parts.before);
	        } // merge match+after


	        if (parts.match && parts.after) {
	          parts.match.length += parts.after.length;
	        } // start matching now on the end


	        carry = parts.match;
	      }); // add that last part

	      if (carry) {
	        matches.push(carry);
	      }
	    });
	    return this.buildFrom(matches);
	  };
	  /** split a document into labeled sections */


	  exports.segment = function (regs, options) {
	    regs = regs || {};
	    options = options || {
	      text: true
	    };
	    var doc = this;
	    var keys = Object.keys(regs); // split em

	    keys.forEach(function (k) {
	      doc = doc.splitOn(k);
	    }); //add labels for each section

	    doc.list.forEach(function (p) {
	      for (var i = 0; i < keys.length; i += 1) {
	        if (p.has(keys[i])) {
	          p.segment = regs[keys[i]];
	          return;
	        }
	      }
	    });
	    return doc.list.map(function (p) {
	      var res = p.json(options);
	      res.segment = p.segment || null;
	      return res;
	    });
	  };
	});

	var eachTerm = function eachTerm(doc, fn) {
	  var world = doc.world;
	  doc.list.forEach(function (p) {
	    p.terms().forEach(function (t) {
	      return t[fn](world);
	    });
	  });
	  return doc;
	};
	/** turn every letter of every term to lower-cse */


	var toLowerCase = function toLowerCase() {
	  return eachTerm(this, 'toLowerCase');
	};
	/** turn every letter of every term to upper case */


	var toUpperCase = function toUpperCase() {
	  return eachTerm(this, 'toUpperCase');
	};
	/** upper-case the first letter of each term */


	var toTitleCase = function toTitleCase() {
	  return eachTerm(this, 'toTitleCase');
	};
	/** remove whitespace and title-case each term */


	var toCamelCase = function toCamelCase() {
	  this.list.forEach(function (p) {
	    //remove whitespace
	    var terms = p.terms();
	    terms.forEach(function (t, i) {
	      if (i !== 0) {
	        t.toTitleCase();
	      }

	      if (i !== terms.length - 1) {
	        t.post = '';
	      }
	    });
	  }); // this.tag('#CamelCase', 'toCamelCase')

	  return this;
	};

	var _04Case = {
	  toLowerCase: toLowerCase,
	  toUpperCase: toUpperCase,
	  toTitleCase: toTitleCase,
	  toCamelCase: toCamelCase
	};

	/** add this punctuation or whitespace before each match: */

	var _05Whitespace = createCommonjsModule(function (module, exports) {
	  exports.pre = function (str, concat) {
	    if (str === undefined) {
	      return this.list[0].terms(0).pre;
	    }

	    this.list.forEach(function (p) {
	      var term = p.terms(0);

	      if (concat === true) {
	        term.pre += str;
	      } else {
	        term.pre = str;
	      }
	    });
	    return this;
	  };
	  /** add this punctuation or whitespace after each match: */


	  exports.post = function (str, concat) {
	    // return array of post strings
	    if (str === undefined) {
	      return this.list.map(function (p) {
	        var terms = p.terms();
	        var term = terms[terms.length - 1];
	        return term.post;
	      });
	    } // set post string on all ends


	    this.list.forEach(function (p) {
	      var terms = p.terms();
	      var term = terms[terms.length - 1];

	      if (concat === true) {
	        term.post += str;
	      } else {
	        term.post = str;
	      }
	    });
	    return this;
	  };
	  /** remove start and end whitespace */


	  exports.trim = function () {
	    this.list = this.list.map(function (p) {
	      return p.trim();
	    });
	    return this;
	  };
	  /** connect words with hyphen, and remove whitespace */


	  exports.hyphenate = function () {
	    this.list.forEach(function (p) {
	      var terms = p.terms(); //remove whitespace

	      terms.forEach(function (t, i) {
	        if (i !== 0) {
	          t.pre = '';
	        }

	        if (terms[i + 1]) {
	          t.post = '-';
	        }
	      });
	    });
	    return this;
	  };
	  /** remove hyphens between words, and set whitespace */


	  exports.dehyphenate = function () {
	    var hasHyphen = /(-||)/;
	    this.list.forEach(function (p) {
	      var terms = p.terms(); //remove whitespace

	      terms.forEach(function (t) {
	        if (hasHyphen.test(t.post)) {
	          t.post = ' ';
	        }
	      });
	    });
	    return this;
	  };

	  exports.deHyphenate = exports.dehyphenate;
	  /** add quotations around these matches */

	  exports.toQuotations = function (start, end) {
	    start = start || "\"";
	    end = end || "\"";
	    this.list.forEach(function (p) {
	      var terms = p.terms();
	      terms[0].pre = start + terms[0].pre;
	      var last = terms[terms.length - 1];
	      last.post = end + last.post;
	    });
	    return this;
	  };

	  exports.toQuotation = exports.toQuotations;
	  /** add brackets around these matches */

	  exports.toParentheses = function (start, end) {
	    start = start || "(";
	    end = end || ")";
	    this.list.forEach(function (p) {
	      var terms = p.terms();
	      terms[0].pre = start + terms[0].pre;
	      var last = terms[terms.length - 1];
	      last.post = end + last.post;
	    });
	    return this;
	  };
	});

	/** make all phrases into one phrase */
	var join = function join(str) {
	  // clear the cache
	  this.uncache(); // make one large phrase - 'main'

	  var main = this.list[0];
	  var before = main.length;
	  var removed = {};

	  for (var i = 1; i < this.list.length; i++) {
	    var p = this.list[i];
	    removed[p.start] = true;
	    var term = main.lastTerm(); // add whitespace between them

	    if (str) {
	      term.post += str;
	    } //  main -> p


	    term.next = p.start; // main <- p

	    p.terms(0).prev = term.id;
	    main.length += p.length;
	    main.cache = {};
	  } // parents are bigger than than their children.
	  // when we increase a child, we increase their parent too.


	  var increase = main.length - before;
	  this.parents().forEach(function (doc) {
	    // increase length on each effected phrase
	    doc.list.forEach(function (p) {
	      var terms = p.terms();

	      for (var _i = 0; _i < terms.length; _i++) {
	        if (terms[_i].id === main.start) {
	          p.length += increase;
	          break;
	        }
	      }

	      p.cache = {};
	    }); // remove redundant phrases now

	    doc.list = doc.list.filter(function (p) {
	      return removed[p.start] !== true;
	    });
	  }); // return one major phrase

	  return this.buildFrom([main]);
	};

	var _06Join = {
	  join: join
	};

	var postPunct = /[,\)"';:\-\.]/; // const irregulars = {
	//   'will not': `won't`,
	//   'i am': `i'm`,
	// }

	var setContraction = function setContraction(m, suffix) {
	  if (!m.found) {
	    return;
	  }

	  var terms = m.termList(); //avoid any problematic punctuation

	  for (var i = 0; i < terms.length - 1; i++) {
	    var t = terms[i];

	    if (postPunct.test(t.post)) {
	      return;
	    }
	  } // set them as implict


	  terms.forEach(function (t) {
	    t.implicit = t.clean;
	  }); // perform the contraction

	  terms[0].text += suffix; // clean-up the others

	  terms.slice(1).forEach(function (t) {
	    t.text = '';
	  });

	  for (var _i = 0; _i < terms.length - 1; _i++) {
	    var _t = terms[_i];
	    _t.post = _t.post.replace(/ /, '');
	  }
	};
	/** turn 'i am' into i'm */


	var contract = function contract() {
	  var doc = this.not('@hasContraction'); // we are -> we're

	  var m = doc.match('(we|they|you) are');
	  setContraction(m, "'re"); // they will -> they'll

	  m = doc.match('(he|she|they|it|we|you) will');
	  setContraction(m, "'ll"); // she is -> she's

	  m = doc.match('(he|she|they|it|we) is');
	  setContraction(m, "'s"); // spencer is -> spencer's

	  m = doc.match('#Person is');
	  setContraction(m, "'s"); // spencer would -> spencer'd

	  m = doc.match('#Person would');
	  setContraction(m, "'d"); // would not -> wouldn't

	  m = doc.match('(is|was|had|would|should|could|do|does|have|has|can) not');
	  setContraction(m, "n't"); // i have -> i've

	  m = doc.match('(i|we|they) have');
	  setContraction(m, "'ve"); // would have -> would've

	  m = doc.match('(would|should|could) have');
	  setContraction(m, "'ve"); // i am -> i'm

	  m = doc.match('i am');
	  setContraction(m, "'m"); // going to -> gonna

	  m = doc.match('going to');
	  return this;
	};

	var _07Contract = {
	  contract: contract
	};

	var methods$4 = Object.assign({}, _01Utils, _02Accessors, _03Match, _04Tag, _05Loops, _06Lookup, _07Cache, _01Replace, _02Insert, _01Text, _02Json, _03Out, _01Sort, _02Normalize, _03Split, _04Case, _05Whitespace, _06Join, _07Contract);

	var methods$3 = {}; // allow helper methods like .adjectives() and .adverbs()

	var arr = [['terms', '.'], ['hyphenated', '@hasHyphen .'], ['adjectives', '#Adjective'], ['hashTags', '#HashTag'], ['emails', '#Email'], ['emoji', '#Emoji'], ['emoticons', '#Emoticon'], ['atMentions', '#AtMention'], ['urls', '#Url'], ['adverbs', '#Adverb'], ['pronouns', '#Pronoun'], ['conjunctions', '#Conjunction'], ['prepositions', '#Preposition']];
	arr.forEach(function (a) {
	  methods$3[a[0]] = function (n) {
	    var m = this.match(a[1]);

	    if (typeof n === 'number') {
	      m = m.get(n);
	    }

	    return m;
	  };
	}); // aliases

	methods$3.emojis = methods$3.emoji;
	methods$3.atmentions = methods$3.atMentions;
	methods$3.words = methods$3.terms;
	/** return anything tagged as a phone number */

	methods$3.phoneNumbers = function (n) {
	  var m = this.splitAfter('@hasComma');
	  m = m.match('#PhoneNumber+');

	  if (typeof n === 'number') {
	    m = m.get(n);
	  }

	  return m;
	};
	/** Deprecated: please use compromise-numbers plugin */


	methods$3.money = function (n) {
	  var m = this.match('#Money #Currency?');

	  if (typeof n === 'number') {
	    m = m.get(n);
	  }

	  return m;
	};
	/** return all cities, countries, addresses, and regions */


	methods$3.places = function (n) {
	  // don't split 'paris, france'
	  var keep = this.match('(#City && @hasComma) (#Region|#Country)'); // but split the other commas

	  var m = this.not(keep).splitAfter('@hasComma'); // combine them back together

	  m = m.concat(keep);
	  m.sort('index');
	  m = m.match('#Place+');

	  if (typeof n === 'number') {
	    m = m.get(n);
	  }

	  return m;
	};
	/** return all schools, businesses and institutions */


	methods$3.organizations = function (n) {
	  var m = this.clauses();
	  m = m.match('#Organization+');

	  if (typeof n === 'number') {
	    m = m.get(n);
	  }

	  return m;
	}; //combine them with .topics() method


	methods$3.entities = function (n) {
	  var r = this.clauses(); // Find people, places, and organizations

	  var yup = r.people();
	  yup = yup.concat(r.places());
	  yup = yup.concat(r.organizations());
	  var ignore = ['someone', 'man', 'woman', 'mother', 'brother', 'sister', 'father'];
	  yup = yup.not(ignore); //return them to normal ordering

	  yup.sort('sequence'); // yup.unique() //? not sure

	  if (typeof n === 'number') {
	    yup = yup.get(n);
	  }

	  return yup;
	}; //aliases


	methods$3.things = methods$3.entities;
	methods$3.topics = methods$3.entities;
	var _simple = methods$3;

	var underOver = /^(under|over)-?/;
	/** match a word-sequence, like 'super bowl' in the lexicon */

	var tryMultiple = function tryMultiple(terms, t, world) {
	  var lex = world.words; //try a two-word version

	  var txt = terms[t].reduced + ' ' + terms[t + 1].reduced;

	  if (lex[txt] !== undefined && lex.hasOwnProperty(txt) === true) {
	    terms[t].tag(lex[txt], 'lexicon-two', world);
	    terms[t + 1].tag(lex[txt], 'lexicon-two', world);
	    return 1;
	  } //try a three-word version?


	  if (t + 2 < terms.length) {
	    txt += ' ' + terms[t + 2].reduced;

	    if (lex[txt] !== undefined && lex.hasOwnProperty(txt) === true) {
	      terms[t].tag(lex[txt], 'lexicon-three', world);
	      terms[t + 1].tag(lex[txt], 'lexicon-three', world);
	      terms[t + 2].tag(lex[txt], 'lexicon-three', world);
	      return 2;
	    }
	  } //try a four-word version?


	  if (t + 3 < terms.length) {
	    txt += ' ' + terms[t + 3].reduced;

	    if (lex[txt] !== undefined && lex.hasOwnProperty(txt) === true) {
	      terms[t].tag(lex[txt], 'lexicon-four', world);
	      terms[t + 1].tag(lex[txt], 'lexicon-four', world);
	      terms[t + 2].tag(lex[txt], 'lexicon-four', world);
	      terms[t + 3].tag(lex[txt], 'lexicon-four', world);
	      return 3;
	    }
	  }

	  return 0;
	};
	/** look at each word in our list of known-words */


	var checkLexicon = function checkLexicon(terms, world) {
	  var lex = world.words;
	  var hasCompound = world.hasCompound; // use reduced?
	  //go through each term, and check the lexicon

	  for (var t = 0; t < terms.length; t += 1) {
	    var str = terms[t].clean; //is it the start of a compound word, like 'super bowl'?

	    if (hasCompound[str] === true && t + 1 < terms.length) {
	      var foundWords = tryMultiple(terms, t, world);

	      if (foundWords > 0) {
	        t += foundWords; //skip any already-found words

	        continue;
	      }
	    } //try one-word lexicon


	    if (lex[str] !== undefined && lex.hasOwnProperty(str) === true) {
	      terms[t].tag(lex[str], 'lexicon', world);
	      continue;
	    } // look at reduced version of term, too


	    if (str !== terms[t].reduced && lex.hasOwnProperty(terms[t].reduced) === true) {
	      terms[t].tag(lex[terms[t].reduced], 'lexicon', world);
	      continue;
	    } // prefix strip: try to match 'take' for 'undertake'


	    if (underOver.test(str) === true) {
	      var noPrefix = str.replace(underOver, '');

	      if (lex.hasOwnProperty(noPrefix) === true) {
	        terms[t].tag(lex[noPrefix], 'noprefix-lexicon', world);
	      }
	    }
	  }

	  return terms;
	};

	var _01Lexicon = checkLexicon;

	var apostrophes = /[\'`]$/;
	var perSec = /^(m|k|cm|km|m)\/(s|h|hr)$/; // '5 k/m'
	//

	var checkPunctuation = function checkPunctuation(terms, i, world) {
	  var term = terms[i]; //check hyphenation
	  // if (term.post.indexOf('-') !== -1 && terms[i + 1] && terms[i + 1].pre === '') {
	  //   term.tag('Hyphenated', 'has-hyphen', world)
	  // }
	  // support 'head-over'
	  // if (term.hasHyphen() === true) {
	  //   console.log(term.tags)
	  // }
	  // console.log(term.hasHyphen(), term.text)
	  //an end-tick (trailing apostrophe) - flanders', or Carlos'

	  if (apostrophes.test(term.text)) {
	    if (!apostrophes.test(term.pre) && !apostrophes.test(term.post) && term.clean.length > 2) {
	      var endChar = term.clean[term.clean.length - 2]; //flanders'

	      if (endChar === 's') {
	        term.tag(['Possessive', 'Noun'], 'end-tick', world);
	        return;
	      } //chillin'


	      if (endChar === 'n') {
	        term.tag(['Gerund'], 'chillin', world);
	      }
	    }
	  } // '5 km/s'


	  if (perSec.test(term.text)) {
	    term.tag('Unit', 'per-sec', world);
	  } // 'NASA' is, but not 'i REALLY love it.'
	  // if (term.tags.Noun === true && isAcronym(term, world)) {
	  //   term.tag('Acronym', 'acronym-step', world)
	  //   term.tag('Noun', 'acronym-infer', world)
	  // } else if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym.test(term.text)) {
	  //   term.tag('Acronym', 'one-letter-acronym', world)
	  //   term.tag('Noun', 'one-letter-infer', world)
	  // }

	};

	var _02Punctuation = checkPunctuation;

	//these are regexes applied to t.text, instead of t.clean
	// order matters.
	var startsWith = [//web tags
	[/^[\w\.]+@[\w\.]+\.[a-z]{2,3}$/, 'Email'], //not fancy
	[/^#[a-z0-9_\u00C0-\u00FF]{2,}$/, 'HashTag'], [/^@1?[0-9](am|pm)$/i, 'Time'], // @6pm
	[/^@1?[0-9]:[0-9]{2}(am|pm)?$/i, 'Time'], // @6:30
	[/^@\w{2,}$/, 'AtMention'], //@spencermountain
	[/^(https?:\/\/|www\.)\w+\.[a-z]{2,3}/, 'Url'], //with http/www
	[/^[\w./]+\.(com|net|gov|org|ly|edu|info|biz|ru|jp|de|in|uk|br)/, 'Url'], //http://mostpopularwebsites.net/top-level-domain
	//dates/times
	[/^'[0-9]{2}$/, 'Year'], //like '97
	[/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/, 'Time'], //4:32:32
	[/^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/i, 'Time'], //4pm
	[/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/i, 'Time'], //4:00pm
	[/^[PMCE]ST$/, 'Time'], //PST, time zone abbrevs
	[/^utc ?[+-]?[0-9]+?$/, 'Time'], //UTC 8+
	[/^[a-z0-9]*? o\'?clock$/, 'Time'], //3 oclock
	[/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}/i, 'Date'], // 2020-03-02T00:00:00.000Z
	[/^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/, 'Date'], // 03-02-89
	[/^[0-9]{1,4}\/[0-9]{1,2}\/[0-9]{1,4}$/, 'Date'], // 03/02/89
	[/^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i, 'Date'], // 03-March-89
	//names
	[/^ma?c\'.*/, 'LastName'], //mc'adams
	[/^o\'[drlkn].*/, 'LastName'], //o'douggan
	[/^ma?cd[aeiou]/, 'LastName'], //macdonell - Last patterns https://en.wikipedia.org/wiki/List_of_family_name_affixes
	//slang things
	[/^(lol)+[sz]$/, 'Expression'], //lol
	[/^woo+a*?h?$/, 'Expression'], //whoaa, wooo
	[/^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/, 'Verb'], // [/^(over|under)[a-z]{2,}/, 'Adjective'],
	[/^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/, 'Date'], // 03-02-89
	//phone numbers
	[/^[0-9]{3}-[0-9]{4}$/, 'PhoneNumber'], //589-3809
	[/^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/, 'PhoneNumber'], //632-589-3809
	//money
	// currency regex
	// /[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]
	//like $5.30
	[/^[-+]?[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6][-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(k|m|b|bn)?\+?$/, ['Money', 'Value']], //like 5.30$
	[/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]\+?$/, ['Money', 'Value']], //like $400usd
	[/^[-+]?[\$]?[0-9]([0-9,.])+?(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i, ['Money', 'Value']], //numbers
	// 50 | -50 | 3.23  | 5,999.0  | 10+
	[/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/, ['Cardinal', 'NumericValue']], [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|r?th)$/, ['Ordinal', 'NumericValue']], // .73th
	[/^\.[0-9]+\+?$/, ['Cardinal', 'NumericValue']], //percent
	[/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/, ['Percent', 'Cardinal', 'NumericValue']], //7%  ..
	[/^\.[0-9]+%$/, ['Percent', 'Cardinal', 'NumericValue']], //.7%  ..
	//fraction
	[/^[0-9]{1,4}\/[0-9]{1,4}(st|nd|rd|th)?s?$/, ['Fraction', 'NumericValue']], //3/2ths
	//range
	[/^[0-9.]{1,2}[-][0-9]{1,2}$/, ['Value', 'NumberRange']], //7-8
	[/^[0-9.]{1,3}(st|nd|rd|th)?[-][0-9\.]{1,3}(st|nd|rd|th)?$/, 'NumberRange'], //5-7
	//with unit
	[/^[0-9.]+([a-z]{1,4})$/, 'Value'] //like 5tbsp
	//ordinal
	// [/^[0-9][0-9,.]*(st|nd|rd|r?th)$/, ['NumericValue', 'Ordinal']], //like 5th
	// [/^[0-9]+(st|nd|rd|th)$/, 'Ordinal'], //like 5th
	];

	var romanNumeral = /^[IVXLCDM]{2,}$/;
	var romanNumValid = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/; //  https://stackoverflow.com/a/267405/168877
	//try each of the ^regexes in our list

	var checkRegex$1 = function checkRegex(term, world) {
	  var str = term.text; // do them all!

	  for (var r = 0; r < startsWith.length; r += 1) {
	    if (startsWith[r][0].test(str) === true) {
	      term.tagSafe(startsWith[r][1], 'prefix #' + r, world);
	      break;
	    }
	  } // do some more!
	  //roman numberals - XVII


	  if (term.text.length >= 2 && romanNumeral.test(str) && romanNumValid.test(str)) {
	    term.tag('RomanNumeral', 'xvii', world);
	  }
	};

	var _03Prefixes = checkRegex$1;

	//regex suffix patterns and their most common parts of speech,
	//built using wordnet, by spencer kelly.
	//this mapping shrinks-down the uglified build
	var Adj$1 = 'Adjective';
	var Inf$1 = 'Infinitive';
	var Pres$1 = 'PresentTense';
	var Sing$1 = 'Singular';
	var Past$1 = 'PastTense';
	var Adverb = 'Adverb';
	var Exp = 'Expression';
	var Actor$1 = 'Actor';
	var Verb = 'Verb';
	var Noun$1 = 'Noun';
	var Last$1 = 'LastName'; //the order here matters.
	//regexes indexed by mandated last-character

	var endsWith = {
	  a: [[/.[aeiou]na$/, Noun$1], [/.[oau][wvl]ska$/, Last$1], //polish (female)
	  [/.[^aeiou]ica$/, Sing$1], [/^([hyj]a)+$/, Exp] //hahah
	  ],
	  c: [[/.[^aeiou]ic$/, Adj$1]],
	  d: [//==-ed==
	  //double-consonant
	  [/[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/, Past$1], //popped, planned
	  //double-vowel
	  [/.[aeo]{2}[bdgmnprvz]ed$/, Past$1], //beeped, mooned, veered
	  //-hed
	  [/.[aeiou][sg]hed$/, Past$1], //stashed, sighed
	  //-rd
	  [/.[aeiou]red$/, Past$1], //stored
	  [/.[aeiou]r?ried$/, Past$1], //buried
	  //-led
	  [/.[bcdgtr]led$/, Past$1], //startled, rumbled
	  [/.[aoui]f?led$/, Past$1], //impaled, stifled
	  //-sed
	  [/.[iao]sed$/, Past$1], //franchised
	  [/[aeiou]n?[cs]ed$/, Past$1], //laced, lanced
	  //-med
	  [/[aeiou][rl]?[mnf]ed$/, Past$1], //warmed, attained, engulfed
	  //-ked
	  [/[aeiou][ns]?c?ked$/, Past$1], //hooked, masked
	  //-ged
	  [/[aeiou][nl]?ged$/, Past$1], //engaged
	  //-ted
	  [/.[tdbwxz]ed$/, Past$1], //bribed, boxed
	  [/[^aeiou][aeiou][tvx]ed$/, Past$1], //boxed
	  //-ied
	  [/.[cdlmnprstv]ied$/, Past$1], //rallied
	  [/[^aeiou]ard$/, Sing$1], //card
	  [/[aeiou][^aeiou]id$/, Adj$1], [/.[vrl]id$/, Adj$1]],
	  e: [[/.[lnr]ize$/, Inf$1], [/.[^aeiou]ise$/, Inf$1], [/.[aeiou]te$/, Inf$1], [/.[^aeiou][ai]ble$/, Adj$1], [/.[^aeiou]eable$/, Adj$1], [/.[ts]ive$/, Adj$1]],
	  h: [[/.[^aeiouf]ish$/, Adj$1], [/.v[iy]ch$/, Last$1], //east-europe
	  [/^ug?h+$/, Exp], //uhh
	  [/^uh[ -]?oh$/, Exp] //uhoh
	  ],
	  i: [[/.[oau][wvl]ski$/, Last$1] //polish (male)
	  ],
	  k: [[/^(k){2}$/, Exp] //kkkk
	  ],
	  l: [[/.[gl]ial$/, Adj$1], [/.[^aeiou]ful$/, Adj$1], [/.[nrtumcd]al$/, Adj$1], [/.[^aeiou][ei]al$/, Adj$1]],
	  m: [[/.[^aeiou]ium$/, Sing$1], [/[^aeiou]ism$/, Sing$1], [/^h*u*m+$/, Exp], //mmmmmmm / ummmm / huuuuuummmmmm
	  [/^\d+ ?[ap]m$/, 'Date']],
	  n: [[/.[lsrnpb]ian$/, Adj$1], [/[^aeiou]ician$/, Actor$1], [/[aeiou][ktrp]in$/, 'Gerund'] // 'cookin', 'hootin'
	  ],
	  o: [[/^no+$/, Exp], //noooo
	  [/^(yo)+$/, Exp], //yoyo
	  [/^woo+[pt]?$/, Exp] //woo
	  ],
	  r: [[/.[bdfklmst]ler$/, 'Noun'], [/[aeiou][pns]er$/, Sing$1], [/[^i]fer$/, Inf$1], [/.[^aeiou][ao]pher$/, Actor$1], [/.[lk]er$/, 'Noun'], [/.ier$/, 'Comparative']],
	  t: [[/.[di]est$/, 'Superlative'], [/.[icldtgrv]ent$/, Adj$1], [/[aeiou].*ist$/, Adj$1], [/^[a-z]et$/, Verb]],
	  s: [[/.[^aeiou]ises$/, Pres$1], [/.[rln]ates$/, Pres$1], [/.[^z]ens$/, Verb], [/.[lstrn]us$/, Sing$1], [/.[aeiou]sks$/, Pres$1], //masks
	  [/.[aeiou]kes$/, Pres$1], //bakes
	  [/[aeiou][^aeiou]is$/, Sing$1], [/[a-z]\'s$/, Noun$1], [/^yes+$/, Exp] //yessss
	  ],
	  v: [[/.[^aeiou][ai][kln]ov$/, Last$1] //east-europe
	  ],
	  y: [[/.[cts]hy$/, Adj$1], [/.[st]ty$/, Adj$1], [/.[gk]y$/, Adj$1], [/.[tnl]ary$/, Adj$1], [/.[oe]ry$/, Sing$1], [/[rdntkbhs]ly$/, Adverb], [/...lly$/, Adverb], [/[bszmp]{2}y$/, Adj$1], [/.(gg|bb|zz)ly$/, Adj$1], [/.[ai]my$/, Adj$1], [/[ea]{2}zy$/, Adj$1], [/.[^aeiou]ity$/, Sing$1]]
	};

	//just a foolish lookup of known suffixes
	var Adj = 'Adjective';
	var Inf = 'Infinitive';
	var Pres = 'PresentTense';
	var Sing = 'Singular';
	var Past = 'PastTense';
	var Avb = 'Adverb';
	var Plrl = 'Plural';
	var Actor = 'Actor';
	var Vb = 'Verb';
	var Noun = 'Noun';
	var Last = 'LastName';
	var Modal = 'Modal';
	var Place = 'Place'; // find any issues - https://observablehq.com/@spencermountain/suffix-word-lookup

	var suffixMap = [null, //0
	null, //1
	{
	  //2-letter
	  ea: Sing,
	  ia: Noun,
	  ic: Adj,
	  ly: Avb,
	  "'n": Vb,
	  "'t": Vb
	}, {
	  //3-letter
	  oed: Past,
	  ued: Past,
	  xed: Past,
	  ' so': Avb,
	  "'ll": Modal,
	  "'re": 'Copula',
	  azy: Adj,
	  eer: Noun,
	  end: Vb,
	  ped: Past,
	  ffy: Adj,
	  ify: Inf,
	  ing: 'Gerund',
	  //likely to be converted to Adj after lexicon pass
	  ize: Inf,
	  lar: Adj,
	  mum: Adj,
	  nes: Pres,
	  nny: Adj,
	  oid: Adj,
	  ous: Adj,
	  que: Adj,
	  rol: Sing,
	  sis: Sing,
	  zes: Pres
	}, {
	  //4-letter
	  amed: Past,
	  aped: Past,
	  ched: Past,
	  lked: Past,
	  nded: Past,
	  cted: Past,
	  dged: Past,
	  akis: Last,
	  //greek
	  cede: Inf,
	  chuk: Last,
	  //east-europe
	  czyk: Last,
	  //polish (male)
	  ects: Pres,
	  ends: Vb,
	  enko: Last,
	  //east-europe
	  ette: Sing,
	  fies: Pres,
	  fore: Avb,
	  gate: Inf,
	  gone: Adj,
	  ices: Plrl,
	  ints: Plrl,
	  ines: Plrl,
	  ions: Plrl,
	  less: Avb,
	  llen: Adj,
	  made: Adj,
	  nsen: Last,
	  //norway
	  oses: Pres,
	  ould: Modal,
	  some: Adj,
	  sson: Last,
	  //swedish male
	  tage: Inf,
	  teen: 'Value',
	  tion: Sing,
	  tive: Adj,
	  tors: Noun,
	  vice: Sing
	}, {
	  //5-letter
	  tized: Past,
	  urned: Past,
	  eased: Past,
	  ances: Plrl,
	  bound: Adj,
	  ettes: Plrl,
	  fully: Avb,
	  ishes: Pres,
	  ities: Plrl,
	  marek: Last,
	  //polish (male)
	  nssen: Last,
	  //norway
	  ology: Noun,
	  ports: Plrl,
	  rough: Adj,
	  tches: Pres,
	  tieth: 'Ordinal',
	  tures: Plrl,
	  wards: Avb,
	  where: Avb
	}, {
	  //6-letter
	  auskas: Last,
	  //lithuania
	  keeper: Actor,
	  logist: Actor,
	  teenth: 'Value'
	}, {
	  //7-letter
	  opoulos: Last,
	  //greek
	  borough: Place,
	  //Hillsborough
	  sdottir: Last //swedish female

	}];

	var endRegexs = function endRegexs(term, world) {
	  var str = term.clean;
	  var _char = str[str.length - 1];

	  if (endsWith.hasOwnProperty(_char) === true) {
	    var regs = endsWith[_char];

	    for (var r = 0; r < regs.length; r += 1) {
	      if (regs[r][0].test(str) === true) {
	        term.tagSafe(regs[r][1], "endReg ".concat(_char, " #").concat(r), world);
	        break;
	      }
	    }
	  }
	}; //sweep-through all suffixes


	var knownSuffixes = function knownSuffixes(term, world) {
	  var len = term.clean.length;
	  var max = 7;

	  if (len <= max) {
	    max = len - 1;
	  }

	  for (var i = max; i > 1; i -= 1) {
	    var str = term.clean.substr(len - i, len);

	    if (suffixMap[str.length].hasOwnProperty(str) === true) {
	      var tag = suffixMap[str.length][str];
	      term.tagSafe(tag, 'suffix -' + str, world);
	      break;
	    }
	  }
	}; //all-the-way-down!


	var checkRegex = function checkRegex(term, world) {
	  knownSuffixes(term, world);
	  endRegexs(term, world);
	};

	var _04Suffixes = checkRegex;

	//just some of the most common emoticons
	//faster than
	//http://stackoverflow.com/questions/28077049/regex-matching-emoticons
	var emoticons = {
	  ':(': true,
	  ':)': true,
	  ':P': true,
	  ':p': true,
	  ':O': true,
	  ':3': true,
	  ':|': true,
	  ':/': true,
	  ':\\': true,
	  ':$': true,
	  ':*': true,
	  ':@': true,
	  ':-(': true,
	  ':-)': true,
	  ':-P': true,
	  ':-p': true,
	  ':-O': true,
	  ':-3': true,
	  ':-|': true,
	  ':-/': true,
	  ':-\\': true,
	  ':-$': true,
	  ':-*': true,
	  ':-@': true,
	  ':^(': true,
	  ':^)': true,
	  ':^P': true,
	  ':^p': true,
	  ':^O': true,
	  ':^3': true,
	  ':^|': true,
	  ':^/': true,
	  ':^\\': true,
	  ':^$': true,
	  ':^*': true,
	  ':^@': true,
	  '):': true,
	  '(:': true,
	  '$:': true,
	  '*:': true,
	  ')-:': true,
	  '(-:': true,
	  '$-:': true,
	  '*-:': true,
	  ')^:': true,
	  '(^:': true,
	  '$^:': true,
	  '*^:': true,
	  '<3': true,
	  '</3': true,
	  '<\\3': true
	};

	var emojiReg = /^(\u00a9|\u00ae|[\u2319-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/; //for us, there's three types -
	// * ;) - emoticons
	// *  - unicode emoji
	// * :smiling_face: - asci-represented emoji
	//test for forms like ':woman_tone2::ear_of_rice:'
	//https://github.com/Kikobeats/emojis-keywords/blob/master/index.js

	var isCommaEmoji = function isCommaEmoji(raw) {
	  if (raw.charAt(0) === ':') {
	    //end comma can be last or second-last ':haircut_tone3:'
	    if (raw.match(/:.?$/) === null) {
	      return false;
	    } //ensure no spaces


	    if (raw.match(' ')) {
	      return false;
	    } //reasonably sized


	    if (raw.length > 35) {
	      return false;
	    }

	    return true;
	  }

	  return false;
	}; //check against emoticon whitelist


	var isEmoticon = function isEmoticon(str) {
	  str = str.replace(/^[:;]/, ':'); //normalize the 'eyes'

	  return emoticons.hasOwnProperty(str);
	};

	var tagEmoji = function tagEmoji(term, world) {
	  var raw = term.pre + term.text + term.post;
	  raw = raw.trim(); //dont double-up on ending periods

	  raw = raw.replace(/[.!?,]$/, ''); //test for :keyword: emojis

	  if (isCommaEmoji(raw) === true) {
	    term.tag('Emoji', 'comma-emoji', world);
	    term.text = raw;
	    term.pre = term.pre.replace(':', '');
	    term.post = term.post.replace(':', '');
	  } //test for unicode emojis


	  if (term.text.match(emojiReg)) {
	    term.tag('Emoji', 'unicode-emoji', world);
	    term.text = raw;
	  } //test for emoticon ':)' emojis


	  if (isEmoticon(raw) === true) {
	    term.tag('Emoticon', 'emoticon-emoji', world);
	    term.text = raw;
	  }
	};

	var _05Emoji = tagEmoji;

	var steps = {
	  lexicon: _01Lexicon,
	  punctuation: _02Punctuation,
	  regex: _03Prefixes,
	  suffix: _04Suffixes,
	  emoji: _05Emoji
	}; //'lookups' look at a term by itself

	var lookups = function lookups(doc, terms) {
	  var world = doc.world; //our list of known-words

	  steps.lexicon(terms, world); //try these other methods

	  for (var i = 0; i < terms.length; i += 1) {
	    var term = terms[i]; //or maybe some helpful punctuation

	    steps.punctuation(terms, i, world); //mostly prefix checks

	    steps.regex(term, world); //maybe we can guess

	    steps.suffix(term, world); //emoji and emoticons

	    steps.emoji(term, world);
	  }

	  return doc;
	};

	var _01Init = lookups;

	//markov-like stats about co-occurance, for hints about unknown terms
	//basically, a little-bit better than the noun-fallback
	//just top n-grams from nlp tags, generated from nlp-corpus
	//after this word, here's what happens usually
	var afterThisWord = {
	  i: 'Verb',
	  //44% //i walk..
	  first: 'Noun',
	  //50% //first principles..
	  it: 'Verb',
	  //33%
	  there: 'Verb',
	  //35%
	  not: 'Verb',
	  //33%
	  because: 'Noun',
	  //31%
	  "if": 'Noun',
	  //32%
	  but: 'Noun',
	  //26%
	  who: 'Verb',
	  //40%
	  "this": 'Noun',
	  //37%
	  his: 'Noun',
	  //48%
	  when: 'Noun',
	  //33%
	  you: 'Verb',
	  //35%
	  very: 'Adjective',
	  // 39%
	  old: 'Noun',
	  //51%
	  never: 'Verb',
	  //42%
	  before: 'Noun' //28%

	}; //in advance of this word, this is what happens usually

	var beforeThisWord = {
	  there: 'Verb',
	  //23% // be there
	  me: 'Verb',
	  //31% //see me
	  man: 'Adjective',
	  // 80% //quiet man
	  only: 'Verb',
	  //27% //sees only
	  him: 'Verb',
	  //32% //show him
	  were: 'Noun',
	  //48% //we were
	  took: 'Noun',
	  //38% //he took
	  himself: 'Verb',
	  //31% //see himself
	  went: 'Noun',
	  //43% //he went
	  who: 'Noun',
	  //47% //person who
	  jr: 'Person'
	}; //following this POS, this is likely

	var afterThisPOS = {
	  Adjective: 'Noun',
	  //36% //blue dress
	  Possessive: 'Noun',
	  //41% //his song
	  Determiner: 'Noun',
	  //47%
	  Adverb: 'Verb',
	  //20%
	  Pronoun: 'Verb',
	  //40%
	  Value: 'Noun',
	  //47%
	  Ordinal: 'Noun',
	  //53%
	  Modal: 'Verb',
	  //35%
	  Superlative: 'Noun',
	  //43%
	  Demonym: 'Noun',
	  //38%
	  Honorific: 'Person' //

	}; //in advance of this POS, this is likely

	var beforeThisPOS = {
	  Copula: 'Noun',
	  //44% //spencer is
	  PastTense: 'Noun',
	  //33% //spencer walked
	  Conjunction: 'Noun',
	  //36%
	  Modal: 'Noun',
	  //38%
	  Pluperfect: 'Noun',
	  //40%
	  PerfectTense: 'Verb' //32%

	};
	var markov = {
	  beforeThisWord: beforeThisWord,
	  afterThisWord: afterThisWord,
	  beforeThisPos: beforeThisPOS,
	  afterThisPos: afterThisPOS
	};

	var afterKeys = Object.keys(markov.afterThisPos);
	var beforeKeys = Object.keys(markov.beforeThisPos);

	var checkNeighbours = function checkNeighbours(terms, world) {
	  var _loop = function _loop(i) {
	    var term = terms[i]; //do we still need a tag?

	    if (term.isKnown() === true) {
	      return "continue";
	    } //ok, this term needs a tag.
	    //look at previous word for clues..


	    var lastTerm = terms[i - 1];

	    if (lastTerm) {
	      // 'foobar term'
	      if (markov.afterThisWord.hasOwnProperty(lastTerm.clean) === true) {
	        var tag = markov.afterThisWord[lastTerm.clean];
	        term.tag(tag, 'after-' + lastTerm.clean, world);
	        return "continue";
	      } // 'Tag term'
	      // (look at previous POS tags for clues..)


	      var foundTag = afterKeys.find(function (tag) {
	        return lastTerm.tags[tag];
	      });

	      if (foundTag !== undefined) {
	        var _tag = markov.afterThisPos[foundTag];
	        term.tag(_tag, 'after-' + foundTag, world);
	        return "continue";
	      }
	    } //look at next word for clues..


	    var nextTerm = terms[i + 1];

	    if (nextTerm) {
	      // 'term foobar'
	      if (markov.beforeThisWord.hasOwnProperty(nextTerm.clean) === true) {
	        var _tag2 = markov.beforeThisWord[nextTerm.clean];
	        term.tag(_tag2, 'before-' + nextTerm.clean, world);
	        return "continue";
	      } // 'term Tag'
	      // (look at next POS tags for clues..)


	      var _foundTag = beforeKeys.find(function (tag) {
	        return nextTerm.tags[tag];
	      });

	      if (_foundTag !== undefined) {
	        var _tag3 = markov.beforeThisPos[_foundTag];
	        term.tag(_tag3, 'before-' + _foundTag, world);
	        return "continue";
	      }
	    }
	  };

	  for (var i = 0; i < terms.length; i += 1) {
	    var _ret = _loop(i);

	    if (_ret === "continue") continue;
	  }
	};

	var _01Neighbours = checkNeighbours;

	var titleCase = /^[A-Z][a-z'\u00C0-\u00FF]/;
	var hasNumber = /[0-9]/;
	/** look for any grammar signals based on capital/lowercase */

	var checkCase = function checkCase(doc) {
	  var world = doc.world;
	  doc.list.forEach(function (p) {
	    var terms = p.terms();

	    for (var i = 1; i < terms.length; i++) {
	      var term = terms[i];

	      if (titleCase.test(term.text) === true && hasNumber.test(term.text) === false && term.tags.Date === undefined) {
	        term.tag('ProperNoun', 'titlecase-noun', world);
	      }
	    }
	  });
	};

	var _02Case = checkCase;

	var hasPrefix = /^(re|un)-?[a-z\u00C0-\u00FF]/;
	var prefix = /^(re|un)-?/;
	/** check 'rewatch' in lexicon as 'watch' */

	var checkPrefix = function checkPrefix(terms, world) {
	  var lex = world.words;
	  terms.forEach(function (term) {
	    // skip if we have a good tag already
	    if (term.isKnown() === true) {
	      return;
	    } //does it start with 'un|re'


	    if (hasPrefix.test(term.clean) === true) {
	      // look for the root word in the lexicon:
	      var stem = term.clean.replace(prefix, '');

	      if (stem && stem.length > 3 && lex[stem] !== undefined && lex.hasOwnProperty(stem) === true) {
	        term.tag(lex[stem], 'stem-' + stem, world);
	      }
	    }
	  });
	};

	var _03Stem = checkPrefix;

	//similar to plural/singularize rules, but not the same
	var isPlural$3 = [/(^v)ies$/i, /ises$/i, /ives$/i, /(antenn|formul|nebul|vertebr|vit)ae$/i, /(octop|vir|radi|nucle|fung|cact|stimul)i$/i, /(buffal|tomat|tornad)oes$/i, /(analy|ba|diagno|parenthe|progno|synop|the)ses$/i, /(vert|ind|cort)ices$/i, /(matr|append)ices$/i, /(x|ch|ss|sh|s|z|o)es$/i, /is$/i, /men$/i, /news$/i, /.tia$/i, /(^f)ves$/i, /(lr)ves$/i, /(^aeiouy|qu)ies$/i, /(m|l)ice$/i, /(cris|ax|test)es$/i, /(alias|status)es$/i, /ics$/i]; //similar to plural/singularize rules, but not the same

	var isSingular$1 = [/(ax|test)is$/i, /(octop|vir|radi|nucle|fung|cact|stimul)us$/i, /(octop|vir)i$/i, /(rl)f$/i, /(alias|status)$/i, /(bu)s$/i, /(al|ad|at|er|et|ed|ad)o$/i, /(ti)um$/i, /(ti)a$/i, /sis$/i, /(?:(^f)fe|(lr)f)$/i, /hive$/i, /s[aeiou]+ns$/i, // sans, siens
	/(^aeiouy|qu)y$/i, /(x|ch|ss|sh|z)$/i, /(matr|vert|ind|cort)(ix|ex)$/i, /(m|l)ouse$/i, /(m|l)ice$/i, /(antenn|formul|nebul|vertebr|vit)a$/i, /.sis$/i, /^(?!talis|.*hu)(.*)man$/i];
	var isPlural_1$2 = {
	  isSingular: isSingular$1,
	  isPlural: isPlural$3
	};

	var noPlurals = ['Uncountable', 'Pronoun', 'Place', 'Value', 'Person', 'Month', 'WeekDay', 'Holiday'];
	var notPlural = [/ss$/, /sis$/, /[^aeiou][uo]s$/, /'s$/];
	var notSingular = [/i$/, /ae$/];
	/** turn nouns into singular/plural */

	var checkPlural = function checkPlural(t, world) {
	  if (t.tags.Noun && !t.tags.Acronym) {
	    var str = t.clean; //skip existing tags, fast

	    if (t.tags.Singular || t.tags.Plural) {
	      return;
	    } //too short


	    if (str.length <= 3) {
	      t.tag('Singular', 'short-singular', world);
	      return;
	    } //is it impossible to be plural?


	    if (noPlurals.find(function (tag) {
	      return t.tags[tag];
	    })) {
	      return;
	    } // isPlural suffix rules


	    if (isPlural_1$2.isPlural.find(function (reg) {
	      return reg.test(str);
	    })) {
	      t.tag('Plural', 'plural-rules', world);
	      return;
	    } // isSingular suffix rules


	    if (isPlural_1$2.isSingular.find(function (reg) {
	      return reg.test(str);
	    })) {
	      t.tag('Singular', 'singular-rules', world);
	      return;
	    } // finally, fallback 'looks plural' rules..


	    if (/s$/.test(str) === true) {
	      //avoid anything too sketchy to be plural
	      if (notPlural.find(function (reg) {
	        return reg.test(str);
	      })) {
	        return;
	      }

	      t.tag('Plural', 'plural-fallback', world);
	      return;
	    } //avoid anything too sketchy to be singular


	    if (notSingular.find(function (reg) {
	      return reg.test(str);
	    })) {
	      return;
	    }

	    t.tag('Singular', 'singular-fallback', world);
	  }
	};

	var _04Plurals = checkPlural;

	//nouns that also signal the title of an unknown organization
	//todo remove/normalize plural forms
	var orgWords = ['academy', 'administration', 'agence', 'agences', 'agencies', 'agency', 'airlines', 'airways', 'army', 'assoc', 'associates', 'association', 'assurance', 'authority', 'autorite', 'aviation', 'bank', 'banque', 'board', 'boys', 'brands', 'brewery', 'brotherhood', 'brothers', 'building society', 'bureau', 'cafe', 'caisse', 'capital', 'care', 'cathedral', 'center', 'central bank', 'centre', 'chemicals', 'choir', 'chronicle', 'church', 'circus', 'clinic', 'clinique', 'club', 'co', 'coalition', 'coffee', 'collective', 'college', 'commission', 'committee', 'communications', 'community', 'company', 'comprehensive', 'computers', 'confederation', 'conference', 'conseil', 'consulting', 'containers', 'corporation', 'corps', 'corp', 'council', 'crew', 'daily news', 'data', 'departement', 'department', 'department store', 'departments', 'design', 'development', 'directorate', 'division', 'drilling', 'education', 'eglise', 'electric', 'electricity', 'energy', 'ensemble', 'enterprise', 'enterprises', 'entertainment', 'estate', 'etat', 'evening news', 'faculty', 'federation', 'financial', 'fm', 'foundation', 'fund', 'gas', 'gazette', 'girls', 'government', 'group', 'guild', 'health authority', 'herald', 'holdings', 'hospital', 'hotel', 'hotels', 'inc', 'industries', 'institut', 'institute', 'institute of technology', 'institutes', 'insurance', 'international', 'interstate', 'investment', 'investments', 'investors', 'journal', 'laboratory', 'labs', // 'law',
	'liberation army', 'limited', 'local authority', 'local health authority', 'machines', 'magazine', 'management', 'marine', 'marketing', 'markets', 'media', 'memorial', 'mercantile exchange', 'ministere', 'ministry', 'military', 'mobile', 'motor', 'motors', 'musee', 'museum', // 'network',
	'news', 'news service', 'observatory', 'office', 'oil', 'optical', 'orchestra', 'organization', 'partners', 'partnership', // 'party',
	"people's party", 'petrol', 'petroleum', 'pharmacare', 'pharmaceutical', 'pharmaceuticals', 'pizza', 'plc', 'police', 'polytechnic', 'post', 'power', 'press', 'productions', 'quartet', 'radio', 'regional authority', 'regional health authority', 'reserve', 'resources', 'restaurant', 'restaurants', 'savings', 'school', 'securities', 'service', 'services', 'social club', 'societe', 'society', 'sons', 'standard', 'state police', 'state university', 'stock exchange', 'subcommittee', 'syndicat', 'systems', 'telecommunications', 'telegraph', 'television', 'times', 'tribunal', 'tv', 'union', 'university', 'utilities', 'workers'];
	var organizations = orgWords.reduce(function (h, str) {
	  h[str] = 'Noun';
	  return h;
	}, {});

	var maybeOrg = function maybeOrg(t) {
	  //must be a noun
	  if (!t.tags.Noun) {
	    return false;
	  } //can't be these things


	  if (t.tags.Pronoun || t.tags.Comma || t.tags.Possessive) {
	    return false;
	  } //must be one of these


	  if (t.tags.Organization || t.tags.Acronym || t.tags.Place || t.titleCase()) {
	    return true;
	  }

	  return false;
	};

	var tagOrgs = function tagOrgs(terms, world) {
	  for (var i = 0; i < terms.length; i += 1) {
	    var t = terms[i];

	    if (organizations[t.clean] !== undefined && organizations.hasOwnProperty(t.clean) === true) {
	      // look-backward - eg. 'Toronto University'
	      var lastTerm = terms[i - 1];

	      if (lastTerm !== undefined && maybeOrg(lastTerm) === true) {
	        lastTerm.tagSafe('Organization', 'org-word-1', world);
	        t.tagSafe('Organization', 'org-word-2', world);
	        continue;
	      } //look-forward - eg. University of Toronto


	      var nextTerm = terms[i + 1];

	      if (nextTerm !== undefined && nextTerm.clean === 'of') {
	        if (terms[i + 2] && maybeOrg(terms[i + 2])) {
	          t.tagSafe('Organization', 'org-of-word-1', world);
	          nextTerm.tagSafe('Organization', 'org-of-word-2', world);
	          terms[i + 2].tagSafe('Organization', 'org-of-word-3', world);
	          continue;
	        }
	      }
	    }
	  }
	};

	var _05Organizations = tagOrgs;

	var oneLetterAcronym = /^[A-Z]('s|,)?$/;
	var periodSeperated = /([A-Z]\.){2}[A-Z]?/i;
	var oneLetterWord = {
	  I: true,
	  A: true
	};

	var isAcronym = function isAcronym(term, world) {
	  var str = term.reduced; // a known acronym like fbi

	  if (term.tags.Acronym) {
	    return true;
	  } // if (term.tags.Adverb || term.tags.Verb || term.tags.Value || term.tags.Plural) {
	  //   return false
	  // }
	  // known-words, like 'PIZZA' is not an acronym.


	  if (world.words[str]) {
	    return false;
	  } // long capitalized words are not usually either


	  if (str.length > 5) {
	    return false;
	  }

	  return term.isAcronym();
	}; // F.B.I., NBC, - but not 'NO COLLUSION'


	var checkAcronym = function checkAcronym(terms, world) {
	  terms.forEach(function (term) {
	    //these are not acronyms
	    if (term.tags.RomanNumeral === true) {
	      return;
	    } //period-ones F.D.B.


	    if (periodSeperated.test(term.text) === true) {
	      term.tag('Acronym', 'period-acronym', world);
	    } //non-period ones are harder


	    if (term.isUpperCase() && isAcronym(term, world)) {
	      term.tag('Acronym', 'acronym-step', world);
	      term.tag('Noun', 'acronym-infer', world);
	    } else if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym.test(term.text)) {
	      term.tag('Acronym', 'one-letter-acronym', world);
	      term.tag('Noun', 'one-letter-infer', world);
	    } //if it's a organization,


	    if (term.tags.Organization && term.text.length <= 3) {
	      term.tag('Acronym', 'acronym-org', world);
	    }

	    if (term.tags.Organization && term.isUpperCase() && term.text.length <= 6) {
	      term.tag('Acronym', 'acronym-org-case', world);
	    }
	  });
	};

	var _06Acronyms = checkAcronym;

	var step = {
	  neighbours: _01Neighbours,
	  "case": _02Case,
	  stem: _03Stem,
	  plural: _04Plurals,
	  organizations: _05Organizations,
	  acronyms: _06Acronyms
	}; //

	var fallbacks = function fallbacks(doc, terms) {
	  var world = doc.world; // if it's empty, consult it's neighbours, first

	  step.neighbours(terms, world); // is there a case-sensitive clue?

	  step["case"](doc); // check 'rewatch' as 'watch'

	  step.stem(terms, world); // ... fallback to a noun!

	  terms.forEach(function (t) {
	    if (t.isKnown() === false) {
	      t.tag('Noun', 'noun-fallback', doc.world);
	    }
	  }); // turn 'Foo University' into an Org

	  step.organizations(terms, world); //turn 'FBD' into an acronym

	  step.acronyms(terms, world); //are the nouns singular or plural?

	  terms.forEach(function (t) {
	    step.plural(t, doc.world);
	  });
	  return doc;
	};

	var _02Fallbacks = fallbacks;

	var hasNegative = /n't$/;
	var irregulars$2 = {
	  "won't": ['will', 'not'],
	  wont: ['will', 'not'],
	  "can't": ['can', 'not'],
	  cant: ['can', 'not'],
	  cannot: ['can', 'not'],
	  "shan't": ['should', 'not'],
	  dont: ['do', 'not'],
	  dun: ['do', 'not'] // "ain't" is ambiguous for is/was

	}; // either 'is not' or 'are not'

	var doAint = function doAint(term, phrase) {
	  var terms = phrase.terms();
	  var index = terms.indexOf(term);
	  var before = terms.slice(0, index); //look for the preceding noun

	  var noun = before.find(function (t) {
	    return t.tags.Noun;
	  });

	  if (noun && noun.tags.Plural) {
	    return ['are', 'not'];
	  }

	  return ['is', 'not'];
	};

	var checkNegative = function checkNegative(term, phrase) {
	  //check named-ones
	  if (irregulars$2.hasOwnProperty(term.clean) === true) {
	    return irregulars$2[term.clean];
	  } //this word needs it's own logic:


	  if (term.clean === "ain't" || term.clean === 'aint') {
	    return doAint(term, phrase);
	  } //try it normally


	  if (hasNegative.test(term.clean) === true) {
	    var main = term.clean.replace(hasNegative, '');
	    return [main, 'not'];
	  }

	  return null;
	};

	var _01Negative = checkNegative;

	var contraction$1 = /([a-z\u00C0-\u00FF]+)[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]([a-z]{1,2})$/i; //these ones don't seem to be ambiguous

	var easy = {
	  ll: 'will',
	  ve: 'have',
	  re: 'are',
	  m: 'am',
	  "n't": 'not'
	}; //

	var checkApostrophe = function checkApostrophe(term) {
	  var parts = term.text.match(contraction$1);

	  if (parts === null) {
	    return null;
	  }

	  if (easy.hasOwnProperty(parts[2])) {
	    return [parts[1], easy[parts[2]]];
	  }

	  return null;
	};

	var _02Simple = checkApostrophe;

	var irregulars$1 = {
	  wanna: ['want', 'to'],
	  gonna: ['going', 'to'],
	  im: ['i', 'am'],
	  alot: ['a', 'lot'],
	  ive: ['i', 'have'],
	  imma: ['I', 'will'],
	  "where'd": ['where', 'did'],
	  whered: ['where', 'did'],
	  "when'd": ['when', 'did'],
	  whend: ['when', 'did'],
	  // "how'd": ['how', 'did'], //'how would?'
	  // "what'd": ['what', 'did'], //'what would?'
	  howd: ['how', 'did'],
	  whatd: ['what', 'did'],
	  // "let's": ['let', 'us'], //too weird
	  //multiple word contractions
	  dunno: ['do', 'not', 'know'],
	  brb: ['be', 'right', 'back'],
	  gtg: ['got', 'to', 'go'],
	  irl: ['in', 'real', 'life'],
	  tbh: ['to', 'be', 'honest'],
	  imo: ['in', 'my', 'opinion'],
	  til: ['today', 'i', 'learned'],
	  rn: ['right', 'now'],
	  twas: ['it', 'was'],
	  '@': ['at']
	}; //

	var checkIrregulars = function checkIrregulars(term) {
	  //check white-list
	  if (irregulars$1.hasOwnProperty(term.clean)) {
	    return irregulars$1[term.clean];
	  }

	  return null;
	};

	var _03Irregulars = checkIrregulars;

	var hasApostropheS = /([a-z\u00C0-\u00FF]+)[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]s$/i;
	var banList = {
	  that: true,
	  there: true
	};
	var hereThere = {
	  here: true,
	  there: true,
	  everywhere: true
	};

	var isPossessive = function isPossessive(term, pool) {
	  // if we already know it
	  if (term.tags.Possessive) {
	    return true;
	  } //a pronoun can't be possessive - "he's house"


	  if (term.tags.Pronoun || term.tags.QuestionWord) {
	    return false;
	  }

	  if (banList.hasOwnProperty(term.reduced)) {
	    return false;
	  } //if end of sentence, it is possessive - "was spencer's"


	  var nextTerm = pool.get(term.next);

	  if (!nextTerm) {
	    return true;
	  } //a gerund suggests 'is walking'


	  if (nextTerm.tags.Verb) {
	    //fix 'jamie's bite'
	    if (nextTerm.tags.Infinitive) {
	      return true;
	    } //fix 'spencer's runs'


	    if (nextTerm.tags.PresentTense) {
	      return true;
	    }

	    return false;
	  } //spencer's house


	  if (nextTerm.tags.Noun) {
	    // 'spencer's here'
	    if (hereThere.hasOwnProperty(nextTerm.reduced) === true) {
	      return false;
	    }

	    return true;
	  } //rocket's red glare


	  var twoTerm = pool.get(nextTerm.next);

	  if (twoTerm && twoTerm.tags.Noun && !twoTerm.tags.Pronoun) {
	    return true;
	  } //othwerwise, an adjective suggests 'is good'


	  if (nextTerm.tags.Adjective || nextTerm.tags.Adverb || nextTerm.tags.Verb) {
	    return false;
	  }

	  return false;
	};

	var isHas = function isHas(term, phrase) {
	  var terms = phrase.terms();
	  var index = terms.indexOf(term);
	  var after = terms.slice(index + 1, index + 3); //look for a past-tense verb

	  return after.find(function (t) {
	    return t.tags.PastTense;
	  });
	};

	var checkPossessive = function checkPossessive(term, phrase, world) {
	  //the rest of 's
	  var found = term.text.match(hasApostropheS);

	  if (found !== null) {
	    //spencer's thing vs spencer-is
	    if (isPossessive(term, phrase.pool) === true) {
	      term.tag('#Possessive', 'isPossessive', world);
	      return null;
	    } //'spencer is'


	    if (found !== null) {
	      if (isHas(term, phrase)) {
	        return [found[1], 'has'];
	      }

	      return [found[1], 'is'];
	    }
	  }

	  return null;
	};

	var _04Possessive = checkPossessive;

	var hasPerfect = /[a-z\u00C0-\u00FF]'d$/;
	var useDid = {
	  how: true,
	  what: true
	};
	/** split `i'd` into 'i had',  or 'i would'  */

	var checkPerfect = function checkPerfect(term, phrase) {
	  if (hasPerfect.test(term.clean)) {
	    var root = term.clean.replace(/'d$/, ''); //look at the next few words

	    var terms = phrase.terms();
	    var index = terms.indexOf(term);
	    var after = terms.slice(index + 1, index + 4); //is it before a past-tense verb? - 'i'd walked'

	    for (var i = 0; i < after.length; i++) {
	      var t = after[i];

	      if (t.tags.Verb) {
	        if (t.tags.PastTense) {
	          return [root, 'had'];
	        } //what'd you see


	        if (useDid[root] === true) {
	          return [root, 'did'];
	        }

	        return [root, 'would'];
	      }
	    } //otherwise, 'i'd walk'


	    return [root, 'would'];
	  }

	  return null;
	};

	var _05PerfectTense = checkPerfect;

	var isRange = /^([0-9]{1,3}(?:st|nd|rd|th)?)[-]([0-9]{1,3}(?:st|nd|rd|th)?)$/i; //split '2-4' into '2 to 4'

	var checkRange = function checkRange(term) {
	  if (term.tags.PhoneNumber === true) {
	    return null;
	  }

	  var parts = term.text.match(isRange);

	  if (parts !== null) {
	    return [parts[1], 'to', parts[2]];
	  }

	  return null;
	};

	var _06Ranges = checkRange;

	var contraction = /^(l|c|d|j|m|n|qu|s|t)[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]([a-z\u00C0-\u00FF]+)$/i; // basic support for ungendered french contractions
	// not perfect, but better than nothing, to support matching on french text.

	var french = {
	  l: 'le',
	  // l'amour
	  c: 'ce',
	  // c'est
	  d: 'de',
	  // d'amerique
	  j: 'je',
	  // j'aime
	  m: 'me',
	  // m'appelle
	  n: 'ne',
	  // n'est
	  qu: 'que',
	  // qu'il
	  s: 'se',
	  // s'appelle
	  t: 'tu' // t'aime

	};

	var checkFrench = function checkFrench(term) {
	  var parts = term.text.match(contraction);

	  if (parts === null || french.hasOwnProperty(parts[1]) === false) {
	    return null;
	  }

	  var arr = [french[parts[1]], parts[2]];

	  if (arr[0] && arr[1]) {
	    return arr;
	  }

	  return null;
	};

	var _07French = checkFrench;

	var isNumber = /^[0-9]+$/;
	var isOrdinal = /^[0-9]+(st|nd|rd|th)$/;

	var createPhrase = function createPhrase(found, doc) {
	  //create phrase from ['would', 'not']
	  var phrase = _01Tokenizer(found.join(' '), doc.world, doc.pool())[0]; //tag it

	  var terms = phrase.terms();
	  _01Lexicon(terms, doc.world); //make these terms implicit

	  terms.forEach(function (t) {
	    t.implicit = t.text;
	    t.text = '';
	    t.clean = ''; // remove whitespace for implicit terms

	    t.pre = '';
	    t.post = ''; // tag number-ranges

	    if (isNumber.test(t.implicit)) {
	      t.tag('Cardinal', 'num-range', doc.world);
	    } else if (isOrdinal.test(t.implicit)) {
	      t.tag('Ordinal', 'ord-range', doc.world);
	    } else if (Object.keys(t.tags).length === 0) {
	      t.tags.Noun = true; // if no tag, give it a noun
	    }
	  });
	  return phrase;
	};

	var contractions = function contractions(doc) {
	  var world = doc.world;
	  doc.list.forEach(function (p) {
	    var terms = p.terms();

	    for (var i = 0; i < terms.length; i += 1) {
	      var term = terms[i];
	      var found = _01Negative(term, p);
	      found = found || _02Simple(term);
	      found = found || _03Irregulars(term);
	      found = found || _04Possessive(term, p, world);
	      found = found || _05PerfectTense(term, p);
	      found = found || _06Ranges(term);
	      found = found || _07French(term); //add them in

	      if (found !== null) {
	        var newPhrase = createPhrase(found, doc); // keep tag NumberRange, if we had it

	        if (p.has('#NumberRange') === true) {
	          doc.buildFrom([newPhrase]).tag('NumberRange');
	        } //set text as contraction


	        var firstTerm = newPhrase.terms(0);
	        firstTerm.text = term.text; //grab sub-phrase to remove

	        var match = p.buildFrom(term.id, 1, doc.pool());
	        match.replace(newPhrase, doc, true);
	      }
	    }
	  });
	  return doc;
	};

	var _03Contractions = contractions;

	var hasWord = function hasWord(doc, word) {
	  var arr = doc._cache.words[word] || [];
	  arr = arr.map(function (i) {
	    return doc.list[i];
	  });
	  return doc.buildFrom(arr);
	};

	var hasTag = function hasTag(doc, tag) {
	  var arr = doc._cache.tags[tag] || [];
	  arr = arr.map(function (i) {
	    return doc.list[i];
	  });
	  return doc.buildFrom(arr);
	}; //mostly pos-corections here


	var miscCorrection = function miscCorrection(doc) {
	  // imperative-form
	  var m = hasTag(doc, 'Infinitive');

	  if (m.found) {
	    // you eat?
	    m = m.ifNo('@hasQuestionMark'); // i speak

	    m = m.ifNo('(i|we|they)'); // shut the door!

	    m.match('[#Infinitive] (#Determiner|#Possessive) #Noun', 0).tag('Imperative', 'shut-the'); // go-fast

	    m.match('^[#Infinitive] #Adverb?$', 0).tag('Imperative', 'go-fast'); // do not go

	    m.match('[(do && #Infinitive)] not? #Verb', 0).tag('Imperative', 'do-not'); // do it

	    m.match('[#Infinitive] (it|some)', 0).tag('Imperative', 'do-it');
	  } //exactly like


	  m = hasWord(doc, 'like');
	  m.match('#Adverb like').notIf('(really|generally|typically|usually|sometimes|often|just) [like]').tag('Adverb', 'adverb-like'); //the orange.

	  m = hasTag(doc, 'Adjective');
	  m.match('#Determiner #Adjective$').notIf('(#Comparative|#Superlative)').terms(1).tag('Noun', 'the-adj-1'); // Firstname x (dangerous)

	  m = hasTag(doc, 'FirstName');
	  m.match('#FirstName (#Noun|@titleCase)').ifNo('^#Possessive').ifNo('(#Pronoun|#Plural)').ifNo('@hasComma .').lastTerm().tag('#LastName', 'firstname-noun'); //three trains / one train

	  m = hasTag(doc, 'Value');
	  m = m.match('#Value #PresentTense').ifNo('#Copula');

	  if (m.found) {
	    if (m.has('(one|1)') === true) {
	      m.terms(1).tag('Singular', 'one-presentTense');
	    } else {
	      m.terms(1).tag('Plural', 'value-presentTense');
	    }
	  } // well i've been...


	  doc.match('^(well|so|okay)').tag('Expression', 'well-'); // 10th of a second

	  doc.match('#Value [of a second]', 0).unTag('Value', 'of-a-second'); // 30 seconds

	  doc.match('#Value [seconds]', 0).unTag('Value', '30-seconds').tag(['Unit', 'Plural']); //been walking

	  m = hasTag(doc, 'Gerund');
	  m.match("(be|been) (#Adverb|not)+? #Gerund").not('#Verb$').tag('Auxiliary', 'be-walking'); // directive verb - 'use reverse'

	  doc.match('(try|use|attempt|build|make) #Verb').ifNo('(@hasComma|#Negative|#PhrasalVerb|#Copula|will|be)').lastTerm().tag('#Noun', 'do-verb'); //possessives
	  //'her match' vs 'let her match'

	  m = hasTag(doc, 'Possessive');
	  m = m.match('#Possessive [#Infinitive]', 0);

	  if (!m.lookBehind('(let|made|make|force|ask)').found) {
	    m.tag('Noun', 'her-match');
	  }

	  return doc;
	};

	var fixMisc = miscCorrection;

	var unique = function unique(arr) {
	  var obj = {};

	  for (var i = 0; i < arr.length; i++) {
	    obj[arr[i]] = true;
	  }

	  return Object.keys(obj);
	};

	var _unique = unique;

	// order matters
	var list$5 = [// ==== Mutliple tags ====
	{
	  match: 'too much',
	  tag: 'Adverb Adjective',
	  reason: 'bit-4'
	}, // u r cool
	{
	  match: 'u r',
	  tag: 'Pronoun Copula',
	  reason: 'u r'
	}, //sometimes adverbs - 'pretty good','well above'
	{
	  match: '#Copula (pretty|dead|full|well|sure) (#Adjective|#Noun)',
	  tag: '#Copula #Adverb #Adjective',
	  reason: 'sometimes-adverb'
	}, //i better ..
	{
	  match: '(#Pronoun|#Person) (had|#Adverb)? [better] #PresentTense',
	  group: 0,
	  tag: 'Modal',
	  reason: 'i-better'
	}, //walking is cool
	{
	  match: '[#Gerund] #Adverb? not? #Copula',
	  group: 0,
	  tag: 'Activity',
	  reason: 'gerund-copula'
	}, //walking should be fun
	{
	  match: '[#Gerund] #Modal',
	  group: 0,
	  tag: 'Activity',
	  reason: 'gerund-modal'
	}, //swear-words as non-expression POS
	{
	  match: 'holy (shit|fuck|hell)',
	  tag: 'Expression',
	  reason: 'swears-expression'
	}, //Aircraft designer
	{
	  match: '#Noun #Actor',
	  tag: 'Actor',
	  reason: 'thing-doer'
	}, {
	  match: '#Conjunction [u]',
	  group: 0,
	  tag: 'Pronoun',
	  reason: 'u-pronoun-2'
	}, //'u' as pronoun
	{
	  match: '[u] #Verb',
	  group: 0,
	  tag: 'Pronoun',
	  reason: 'u-pronoun-1'
	}, // ==== Determiners ====
	{
	  match: '#Noun [(who|whom)]',
	  group: 0,
	  tag: 'Determiner',
	  reason: 'captain-who'
	}, //that car goes
	// { match: 'that #Noun [#PresentTense]', group: 0, tag: 'Determiner', reason: 'that-determiner' },
	{
	  match: 'a bit much',
	  tag: 'Determiner Adverb Adjective',
	  reason: 'bit-3'
	}, // ==== Propositions ====
	//all students
	{
	  match: '#Verb #Adverb? #Noun [(that|which)]',
	  group: 0,
	  tag: 'Preposition',
	  reason: 'that-prep'
	}, //work, which has been done.
	{
	  match: '@hasComma [which] (#Pronoun|#Verb)',
	  group: 0,
	  tag: 'Preposition',
	  reason: 'which-copula'
	}, {
	  match: '#Copula just [like]',
	  group: 0,
	  tag: 'Preposition',
	  reason: 'like-preposition'
	}, //folks like her
	{
	  match: '#Noun [like] #Noun',
	  group: 0,
	  tag: 'Preposition',
	  reason: 'noun-like'
	}, //fix for busted-up phrasalVerbs
	// { match: '#Noun [#Particle]', group: 0, tag: 'Preposition', reason: 'repair-noPhrasal' },
	// ==== Conditions ====
	// had he survived,
	{
	  match: '[had] #Noun+ #PastTense',
	  group: 0,
	  tag: 'Condition',
	  reason: 'had-he'
	}, // were he to survive
	{
	  match: '[were] #Noun+ to #Infinitive',
	  group: 0,
	  tag: 'Condition',
	  reason: 'were-he'
	}, // ==== Questions ====
	//the word 'how'
	{
	  match: '^how',
	  tag: 'QuestionWord',
	  reason: 'how-question'
	}, {
	  match: '[how] (#Determiner|#Copula|#Modal|#PastTense)',
	  group: 0,
	  tag: 'QuestionWord',
	  reason: 'how-is'
	}, // //the word 'which'
	{
	  match: '^which',
	  tag: 'QuestionWord',
	  reason: 'which-question'
	}, // { match: '[which] . (#Noun)+ #Pronoun', group: 0, tag: 'QuestionWord', reason: 'which-question2' },
	// { match: 'which', tag: 'QuestionWord', reason: 'which-question3' },
	// ==== Conjunctions ====
	{
	  match: '[so] #Noun',
	  group: 0,
	  tag: 'Conjunction',
	  reason: 'so-conj'
	}, //how he is driving
	{
	  match: '[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)',
	  group: 0,
	  tag: 'Conjunction',
	  reason: 'how-he-is-x'
	} // {
	//   match: '[(who|what|where|why|how|when)] #Noun #Adverb? #Infinitive not? #Gerund',
	//   group: 0,
	//   tag: 'Conjunction',
	//   reason: 'when-i-go-fishing',
	// },
	];
	var _01Misc = list$5;

	var _ambig = {
	  // adverbs than can be adjectives
	  adverbAdjective: ['dark', 'bright', 'flat', 'light', 'soft', 'pale', 'dead', 'dim', 'faux', 'little', 'wee', 'sheer', 'most', 'near', 'good', 'extra', 'all'],
	  // names that are dates
	  personDate: ['april', 'june', 'may', 'jan', 'august', 'eve'],
	  // names that may be months
	  personMonth: ['january', 'april', 'may', 'june', 'jan', 'sep'],
	  // names that are adjectives
	  personAdjective: ['misty', 'rusty', 'dusty', 'rich', 'randy', 'young'],
	  // names that are verbs
	  personVerb: ['pat', 'wade', 'ollie', 'will', 'rob', 'buck', 'bob', 'mark', 'jack'],
	  // names that are verbs
	  personPlace: ['darwin', 'hamilton', 'paris', 'alexandria', 'houston', 'kobe', 'santiago', 'salvador', 'sydney', 'victoria'],
	  // names that are nouns
	  personNoun: ['art', 'baker', 'berg', 'bill', 'brown', 'charity', 'chin', 'christian', 'cliff', 'daisy', 'dawn', 'dick', 'dolly', 'faith', 'franco', 'gene', 'green', 'hall', 'hill', 'holly', 'hope', 'jean', 'jewel', 'joy', 'kelvin', 'king', 'kitty', 'lane', 'lily', 'melody', 'mercedes', 'miles', 'olive', 'penny', 'ray', 'reed', 'robin', 'rod', 'rose', 'sky', 'summer', 'trinity', 'van', 'viola', 'violet', 'wang', 'white']
	};

	var dates = "(".concat(_ambig.personDate.join('|'), ")");
	var list$4 = [// ==== Holiday ====
	{
	  match: '#Holiday (day|eve)',
	  tag: 'Holiday',
	  reason: 'holiday-day'
	}, // the captain who
	// ==== WeekDay ====
	// sun the 5th
	{
	  match: '[sun] the #Ordinal',
	  tag: 'WeekDay',
	  reason: 'sun-the-5th'
	}, //sun feb 2
	{
	  match: '[sun] #Date',
	  group: 0,
	  tag: 'WeekDay',
	  reason: 'sun-feb'
	}, //1pm next sun
	{
	  match: '#Date (on|this|next|last|during)? [sun]',
	  group: 0,
	  tag: 'WeekDay',
	  reason: '1pm-sun'
	}, //this sat
	{
	  match: "(in|by|before|during|on|until|after|of|within|all) [sat]",
	  group: 0,
	  tag: 'WeekDay',
	  reason: 'sat'
	}, {
	  match: "(in|by|before|during|on|until|after|of|within|all) [wed]",
	  group: 0,
	  tag: 'WeekDay',
	  reason: 'wed'
	}, {
	  match: "(in|by|before|during|on|until|after|of|within|all) [march]",
	  group: 0,
	  tag: 'Month',
	  reason: 'march'
	}, //sat november
	{
	  match: '[sat] #Date',
	  group: 0,
	  tag: 'WeekDay',
	  reason: 'sat-feb'
	}, // ==== Month ====
	//all march
	{
	  match: "#Preposition [(march|may)]",
	  group: 0,
	  tag: 'Month',
	  reason: 'in-month'
	}, //this march
	{
	  match: "this [(march|may)]",
	  group: 0,
	  tag: 'Month',
	  reason: 'this-month'
	}, {
	  match: "next [(march|may)]",
	  group: 0,
	  tag: 'Month',
	  reason: 'this-month'
	}, {
	  match: "last [(march|may)]",
	  group: 0,
	  tag: 'Month',
	  reason: 'this-month'
	}, // march 5th
	{
	  match: "[(march|may)] the? #Value",
	  group: 0,
	  tag: 'Month',
	  reason: 'march-5th'
	}, // 5th of march
	{
	  match: "#Value of? [(march|may)]",
	  group: 0,
	  tag: 'Month',
	  reason: '5th-of-march'
	}, // march and feb
	{
	  match: "[(march|may)] .? #Date",
	  group: 0,
	  tag: 'Month',
	  reason: 'march-and-feb'
	}, // feb to march
	{
	  match: "#Date .? [(march|may)]",
	  group: 0,
	  tag: 'Month',
	  reason: 'feb-and-march'
	}, //quickly march
	{
	  match: "#Adverb [(march|may)]",
	  group: 0,
	  tag: 'Verb',
	  reason: 'quickly-march'
	}, //march quickly
	{
	  match: "[(march|may)] #Adverb",
	  group: 0,
	  tag: 'Verb',
	  reason: 'march-quickly'
	}, //5th of March
	{
	  match: '#Value of #Month',
	  tag: 'Date',
	  reason: 'value-of-month'
	}, //5 March
	{
	  match: '#Cardinal #Month',
	  tag: 'Date',
	  reason: 'cardinal-month'
	}, //march 5 to 7
	{
	  match: '#Month #Value to #Value',
	  tag: 'Date',
	  reason: 'value-to-value'
	}, //march the 12th
	{
	  match: '#Month the #Value',
	  tag: 'Date',
	  reason: 'month-the-value'
	}, //june 7
	{
	  match: '(#WeekDay|#Month) #Value',
	  tag: 'Date',
	  reason: 'date-value'
	}, //7 june
	{
	  match: '#Value (#WeekDay|#Month)',
	  tag: 'Date',
	  reason: 'value-date'
	}, //may twenty five
	{
	  match: '(#TextValue && #Date) #TextValue',
	  tag: 'Date',
	  reason: 'textvalue-date'
	}, // in june
	{
	  match: "in [".concat(dates, "]"),
	  group: 0,
	  tag: 'Date',
	  reason: 'in-june'
	}, {
	  match: "during [".concat(dates, "]"),
	  group: 0,
	  tag: 'Date',
	  reason: 'in-june'
	}, {
	  match: "on [".concat(dates, "]"),
	  group: 0,
	  tag: 'Date',
	  reason: 'in-june'
	}, {
	  match: "by [".concat(dates, "]"),
	  group: 0,
	  tag: 'Date',
	  reason: 'by-june'
	}, {
	  match: "after [".concat(dates, "]"),
	  group: 0,
	  tag: 'Date',
	  reason: 'after-june'
	}, {
	  match: "#Date [".concat(dates, "]"),
	  group: 0,
	  tag: 'Date',
	  reason: 'in-june'
	}, // june 1992
	{
	  match: "".concat(dates, " #Value"),
	  tag: 'Date',
	  reason: 'june-5th'
	}, {
	  match: "".concat(dates, " #Date"),
	  tag: 'Date',
	  reason: 'june-5th'
	}, // June Smith
	{
	  match: "".concat(dates, " #ProperNoun"),
	  tag: 'Person',
	  reason: 'june-smith',
	  safe: true
	}, // june m. Cooper
	{
	  match: "".concat(dates, " #Acronym? (#ProperNoun && !#Month)"),
	  tag: 'Person',
	  reason: 'june-smith-jr'
	}, // 'second'
	{
	  match: "#Cardinal [second]",
	  tag: 'Unit',
	  reason: 'one-second'
	}, // second quarter
	// { match: `#Ordinal quarter`, tag: 'Date', reason: 'second-quarter' },
	// 'aug 20-21'
	{
	  match: "#Month #NumberRange",
	  tag: 'Date',
	  reason: 'aug 20-21'
	}];
	var _02Dates = list$4;

	var adjectives$1 = "(".concat(_ambig.personAdjective.join('|'), ")");
	var list$3 = [// all fell apart
	{
	  match: '[all] #Determiner? #Noun',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'all-noun'
	}, // very rusty
	{
	  match: "#Adverb [".concat(adjectives$1, "]"),
	  group: 0,
	  tag: 'Adjective',
	  reason: 'really-rich'
	}, // rusty smith
	{
	  match: "".concat(adjectives$1, " #Person"),
	  tag: 'Person',
	  reason: 'randy-smith'
	}, // rusty a. smith
	{
	  match: "".concat(adjectives$1, " #Acronym? #ProperNoun"),
	  tag: 'Person',
	  reason: 'rusty-smith'
	}, //sometimes not-adverbs
	{
	  match: '#Copula [(just|alone)]$',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'not-adverb'
	}, //jack is guarded
	{
	  match: '#Singular is #Adverb? [#PastTense$]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'is-filled'
	}, // smoked poutine is
	{
	  match: '[#PastTense] #Singular is',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'smoked-poutine'
	}, // baked onions are
	{
	  match: '[#PastTense] #Plural are',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'baked-onions'
	}, // well made
	{
	  match: 'well [#PastTense]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'well-made'
	}, // is f*ed up
	{
	  match: '#Copula [fucked up?]',
	  tag: 'Adjective',
	  reason: 'swears-adjective'
	}, //jack seems guarded
	{
	  match: '#Singular (seems|appears) #Adverb? [#PastTense$]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'seems-filled'
	}, // Gerund-Adjectives - 'amusing, annoying'
	//a staggering cost
	{
	  match: '(a|an) [#Gerund]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'a|an'
	}, //as amusing as
	{
	  match: 'as [#Gerund] as',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'as-gerund-as'
	}, // more amusing than
	{
	  match: 'more [#Gerund] than',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'more-gerund-than'
	}, // very amusing
	{
	  match: '(so|very|extremely) [#Gerund]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'so-gerund'
	}, // it was amusing
	{
	  match: '(it|he|she|everything|something) #Adverb? was #Adverb? [#Gerund]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'it-was-gerund'
	}, // found it amusing
	{
	  match: '(found|found) it #Adverb? [#Gerund]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'found-it-gerund'
	}, // a bit amusing
	{
	  match: 'a (little|bit|wee) bit? [#Gerund]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'a-bit-gerund'
	}, // jury is out - preposition  adjective
	{
	  match: '#Copula #Adjective? [(out|in|through)]$',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'still-out'
	}, // shut the door
	{
	  match: '^[#Adjective] (the|your) #Noun',
	  group: 0,
	  tag: 'Infinitive',
	  reason: 'shut-the'
	}];
	var _03Adjective = list$3;

	var _04Noun = [// ==== Plural ====
	//there are reasons
	{
	  match: 'there (are|were) #Adjective? [#PresentTense]',
	  group: 0,
	  tag: 'Plural',
	  reason: 'there-are'
	}, // ==== Singular ====
	//the sun
	{
	  match: '#Determiner [sun]',
	  group: 0,
	  tag: 'Singular',
	  reason: 'the-sun'
	}, //did a 900, paid a 20
	{
	  match: '#Verb (a|an) [#Value]',
	  group: 0,
	  tag: 'Singular',
	  reason: 'did-a-value'
	}, //'the can'
	{
	  match: 'the [(can|will|may)]',
	  group: 0,
	  tag: 'Singular',
	  reason: 'the can'
	}, // ==== Possessive ====
	//spencer kelly's
	{
	  match: '#FirstName #Acronym? (#Possessive && #LastName)',
	  tag: 'Possessive',
	  reason: 'name-poss'
	}, //Super Corp's fundraiser
	{
	  match: '#Organization+ #Possessive',
	  tag: 'Possessive',
	  reason: 'org-possessive'
	}, //Los Angeles's fundraiser
	{
	  match: '#Place+ #Possessive',
	  tag: 'Possessive',
	  reason: 'place-possessive'
	}, // assign all tasks
	{
	  match: '(#Verb && !#Modal) (all|every|each|most|some|no) [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'all-presentTense'
	}, //the above is clear
	{
	  match: '#Determiner [#Adjective] #Copula',
	  group: 0,
	  tag: 'Noun',
	  reason: 'the-adj-is'
	}, //real evil is
	{
	  match: '#Adjective [#Adjective] #Copula',
	  group: 0,
	  tag: 'Noun',
	  reason: 'adj-adj-is'
	}, // PresentTense/Noun ambiguities
	// big dreams, critical thinking
	// have big dreams
	{
	  match: '(had|have|#PastTense) #Adjective [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'adj-presentTense'
	}, // excellent answer spencer
	{
	  match: '^#Adjective [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'start adj-presentTense'
	}, // one big reason
	{
	  match: '#Value #Adjective [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'one-big-reason'
	}, // won widespread support
	{
	  match: '#PastTense #Adjective+ [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'won-wide-support'
	}, // many poses
	{
	  match: '(many|few|several|couple) [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'many-poses'
	}, // very big dreams
	{
	  match: '#Adverb #Adjective [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'very-big-dream'
	}, // good wait staff
	{
	  match: '#Adjective [#Infinitive] #Noun',
	  group: 0,
	  tag: 'Noun',
	  reason: 'good-wait-staff'
	}, // adorable little store
	{
	  match: '#Adjective #Adjective [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'adorable-little-store'
	}, // of basic training
	{
	  match: '#Preposition #Adjective [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'of-basic-training'
	}, // early warning
	{
	  match: '#Adjective [#Gerund]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'early-warning'
	}, // justifiying higher costs
	{
	  match: '#Gerund #Adverb? #Comparative [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'higher-costs'
	}, // do the dance
	{
	  match: '#Infinitive (this|that|the) [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'do-this-dance'
	}, //his fine
	{
	  match: '(his|her|its) [#Adjective]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'his-fine'
	}, //some pressing issues
	{
	  match: 'some [#Verb] #Plural',
	  group: 0,
	  tag: 'Noun',
	  reason: 'determiner6'
	}, //'more' is not always an adverb
	{
	  match: 'more #Noun',
	  tag: 'Noun',
	  reason: 'more-noun'
	}, {
	  match: '(#Noun && @hasComma) #Noun (and|or) [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'noun-list'
	}, //3 feet
	{
	  match: '(right|rights) of .',
	  tag: 'Noun',
	  reason: 'right-of'
	}, // a bit
	{
	  match: 'a [bit]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'bit-2'
	}, // my first thought
	{
	  match: '#Possessive #Ordinal [#PastTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'first-thought'
	}, //running-a-show
	{
	  match: '#Gerund #Determiner [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'running-a-show'
	}, //the-only-reason
	{
	  match: '#Determiner #Adverb [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'the-reason'
	}, //the nice swim
	{
	  match: '(the|this|those|these) #Adjective [#Verb]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'the-adj-verb'
	}, // the truly nice swim
	{
	  match: '(the|this|those|these) #Adverb #Adjective [#Verb]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'determiner4'
	}, //the orange is
	{
	  match: '#Determiner [#Adjective] (#Copula|#PastTense|#Auxiliary)',
	  group: 0,
	  tag: 'Noun',
	  reason: 'the-adj-2'
	}, // a stream runs
	{
	  match: '(the|this|a|an) [#Infinitive] #Adverb? #Verb',
	  group: 0,
	  tag: 'Noun',
	  reason: 'determiner5'
	}, //the test string
	{
	  match: '#Determiner [#Infinitive] #Noun',
	  group: 0,
	  tag: 'Noun',
	  reason: 'determiner7'
	}, //a nice deal
	{
	  match: '#Determiner #Adjective #Adjective? [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'a-nice-inf'
	}, //the wait to vote
	{
	  match: 'the [#Verb] #Preposition .',
	  group: 0,
	  tag: 'Noun',
	  reason: 'determiner1'
	}, //a sense of
	{
	  match: '#Determiner [#Verb] of',
	  group: 0,
	  tag: 'Noun',
	  reason: 'the-verb-of'
	}, //next career move
	{
	  match: '#Adjective #Noun+ [#Infinitive] #Copula',
	  group: 0,
	  tag: 'Noun',
	  reason: 'career-move'
	}, //the threat of force
	{
	  match: '#Determiner #Noun of [#Verb]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'noun-of-noun'
	}, //the western line
	{
	  match: '#Determiner [(western|eastern|northern|southern|central)] #Noun',
	  group: 0,
	  tag: 'Noun',
	  reason: 'western-line'
	}, //her polling
	{
	  match: '#Possessive [#Gerund]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'her-polling'
	}, //her fines
	{
	  match: '(his|her|its) [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'its-polling'
	}, //linear algebra
	{
	  match: '(#Determiner|#Value) [(linear|binary|mobile|lexical|technical|computer|scientific|formal)] #Noun',
	  group: 0,
	  tag: 'Noun',
	  reason: 'technical-noun'
	}, // a blown motor
	{
	  match: '(the|those|these|a|an) [#Participle] #Noun',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'blown-motor'
	}, // walk the walk
	{
	  match: '(the|those|these|a|an) #Adjective? [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'det-inf'
	}, {
	  match: '(the|those|these|a|an) #Adjective? [#PresentTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'det-pres'
	}, {
	  match: '(the|those|these|a|an) #Adjective? [#PastTense]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'det-past'
	}, // this swimming
	{
	  match: '(this|that) [#Gerund]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'this-gerund'
	}, // at some point
	{
	  match: 'at some [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'at-some-inf'
	}, //air-flow
	{
	  match: '(#Noun && @hasHyphen) #Verb',
	  tag: 'Noun',
	  reason: 'hyphen-verb'
	}, //is no walk
	{
	  match: 'is no [#Verb]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'is-no-verb'
	}, //different views than
	{
	  match: '[#Verb] than',
	  group: 0,
	  tag: 'Noun',
	  reason: 'correction'
	}, // goes to sleep
	{
	  match: '(go|goes|went) to [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'goes-to-verb'
	}, //a close watch on
	{
	  match: '(a|an) #Noun [#Infinitive] (#Preposition|#Noun)',
	  group: 0,
	  tag: 'Noun',
	  reason: 'a-noun-inf'
	}, //a tv show
	{
	  match: '(a|an) #Noun [#Infinitive]$',
	  group: 0,
	  tag: 'Noun',
	  reason: 'a-noun-inf2'
	}, //do so
	{
	  match: 'do [so]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'so-noun'
	}, //is mark hughes
	{
	  match: '#Copula [#Infinitive] #Noun',
	  group: 0,
	  tag: 'Noun',
	  reason: 'is-pres-noun'
	}, //a close
	{
	  match: '#Determiner #Adverb? [close]',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'a-close'
	}, // what the hell
	{
	  match: '#Determiner [(shit|damn|hell)]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'swears-noun'
	}, // the staff were
	{
	  match: '(the|these) [#Singular] (were|are)',
	  group: 0,
	  tag: 'Plural',
	  reason: 'singular-were'
	}, // running for congress
	{
	  match: '#Gerund #Adjective? for [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'running-for'
	}, // running to work
	{
	  match: '#Gerund #Adjective to [#Infinitive]',
	  group: 0,
	  tag: 'Noun',
	  reason: 'running-to'
	}, // any questions for
	{
	  match: '(many|any|some|several) [#PresentTense] for',
	  group: 0,
	  tag: 'Noun',
	  reason: 'any-verbs-for'
	}, // have fun
	{
	  match: "(have|had) [#Adjective] #Preposition .",
	  group: 0,
	  tag: 'Noun',
	  reason: 'have-fun'
	}, // co-founder
	{
	  match: "co #Noun",
	  tag: 'Actor',
	  reason: 'co-noun'
	}];

	var adjectives = "(".concat(_ambig.adverbAdjective.join('|'), ")");
	var _05Adverb = [//still good
	{
	  match: '[still] #Adjective',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'still-advb'
	}, //still make
	{
	  match: '[still] #Verb',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'still-verb'
	}, // so hot
	{
	  match: '[so] #Adjective',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'so-adv'
	}, // way hotter
	{
	  match: '[way] #Comparative',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'way-adj'
	}, // way too hot
	{
	  match: '[way] #Adverb #Adjective',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'way-too-adj'
	}, // all singing
	{
	  match: '[all] #Verb',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'all-verb'
	}, // sing like an angel
	{
	  match: '(#Verb && !#Modal) [like]',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'verb-like'
	}, //barely even walk
	{
	  match: '(barely|hardly) even',
	  tag: 'Adverb',
	  reason: 'barely-even'
	}, //even held
	{
	  match: '[even] #Verb',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'even-walk'
	}, // even left
	{
	  match: 'even left',
	  tag: '#Adverb #Verb',
	  reason: 'even-left'
	}, //cheering hard - dropped -ly's
	{
	  match: '(#PresentTense && !#Copula) [(hard|quick|long|bright|slow|fast|backwards|forwards)]',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'lazy-ly'
	}, // much appreciated
	{
	  match: '[much] #Adjective',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'bit-1'
	}, // is well
	{
	  match: '#Copula [#Adverb]$',
	  group: 0,
	  tag: 'Adjective',
	  reason: 'is-well'
	}, // a bit cold
	{
	  match: 'a [(little|bit|wee) bit?] #Adjective',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'a-bit-cold'
	}, // dark green
	{
	  match: "[".concat(adjectives, "] #Adjective"),
	  group: 0,
	  tag: 'Adverb',
	  reason: 'dark-green'
	}, // kinda sparkly
	{
	  match: "#Adverb [#Adverb]$",
	  group: 0,
	  tag: 'Adjective',
	  reason: 'kinda-sparkly'
	}, {
	  match: "#Adverb [#Adverb] (and|or|then)",
	  group: 0,
	  tag: 'Adjective',
	  reason: 'kinda-sparkly-and'
	}];

	var _06Value = [// ==== PhoneNumber ====
	//1 800 ...
	{
	  match: '1 #Value #PhoneNumber',
	  tag: 'PhoneNumber',
	  reason: '1-800-Value'
	}, //(454) 232-9873
	{
	  match: '#NumericValue #PhoneNumber',
	  tag: 'PhoneNumber',
	  reason: '(800) PhoneNumber'
	}, // ==== Currency ====
	// chinese yuan
	{
	  match: '#Demonym #Currency',
	  tag: 'Currency',
	  reason: 'demonym-currency'
	}, // ==== Ordinal ====
	{
	  match: '[second] #Noun',
	  group: 0,
	  tag: 'Ordinal',
	  reason: 'second-noun'
	}, // ==== Unit ====
	//5 yan
	{
	  match: '#Value+ [#Currency]',
	  group: 0,
	  tag: 'Unit',
	  reason: '5-yan'
	}, {
	  match: '#Value [(foot|feet)]',
	  group: 0,
	  tag: 'Unit',
	  reason: 'foot-unit'
	}, //minus 7
	{
	  match: '(minus|negative) #Value',
	  tag: 'Value',
	  reason: 'minus-value'
	}, //5 kg.
	{
	  match: '#Value [#Abbreviation]',
	  group: 0,
	  tag: 'Unit',
	  reason: 'value-abbr'
	}, {
	  match: '#Value [k]',
	  group: 0,
	  tag: 'Unit',
	  reason: 'value-k'
	}, {
	  match: '#Unit an hour',
	  tag: 'Unit',
	  reason: 'unit-an-hour'
	}, //seven point five
	{
	  match: '#Value (point|decimal) #Value',
	  tag: 'Value',
	  reason: 'value-point-value'
	}, // ten bucks
	{
	  match: '(#Value|a) [(buck|bucks|grand)]',
	  group: 0,
	  tag: 'Currency',
	  reason: 'value-bucks'
	}, //quarter million
	{
	  match: '#Determiner [(half|quarter)] #Ordinal',
	  group: 0,
	  tag: 'Value',
	  reason: 'half-ordinal'
	}, {
	  match: 'a #Value',
	  tag: 'Value',
	  reason: 'a-value'
	}, // ==== Money ====
	{
	  match: '[#Value+] #Currency',
	  group: 0,
	  tag: 'Money',
	  reason: '15 usd'
	}, // thousand and two
	{
	  match: "(hundred|thousand|million|billion|trillion|quadrillion)+ and #Value",
	  tag: 'Value',
	  reason: 'magnitude-and-value'
	}, //'a/an' can mean 1 - "a hour"
	{
	  match: '!once [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)',
	  group: 0,
	  tag: 'Value',
	  reason: 'a-is-one'
	}];

	var verbs = "(".concat(_ambig.personVerb.join('|'), ")");
	var list$2 = [// adj -> gerund
	// amusing his aunt
	{
	  match: '[#Adjective] #Possessive #Noun',
	  group: 0,
	  tag: 'Verb',
	  reason: 'gerund-his-noun'
	}, // loving you
	{
	  match: '[#Adjective] (us|you)',
	  group: 0,
	  tag: 'Gerund',
	  reason: 'loving-you'
	}, // slowly stunning
	{
	  match: '(slowly|quickly) [#Adjective]',
	  group: 0,
	  tag: 'Gerund',
	  reason: 'slowly-adj'
	}, // like
	{
	  match: '(#Modal|i|they|we|do) not? [like]',
	  group: 0,
	  tag: 'PresentTense',
	  reason: 'modal-like'
	}, // do not simply like
	{
	  match: 'do (simply|just|really|not)+ [(#Adjective|like)]',
	  group: 0,
	  tag: 'Verb',
	  reason: 'do-simply-like'
	}, // does mean
	{
	  match: 'does (#Adverb|not)? [#Adjective]',
	  group: 0,
	  tag: 'PresentTense',
	  reason: 'does-mean'
	}, // i mean
	{
	  match: 'i (#Adverb|do)? not? [mean]',
	  group: 0,
	  tag: 'PresentTense',
	  reason: 'i-mean'
	}, // { match: '!are (i|you|we) (#Adverb|do)? [#Adjective]', group: 0, tag: 'PresentTense', reason: 'i-mean' },
	// ==== Tense ====
	//he left
	{
	  match: '#Noun #Adverb? [left]',
	  group: 0,
	  tag: 'PastTense',
	  reason: 'left-verb'
	}, //this rocks
	{
	  match: '(this|that) [#Plural]',
	  group: 0,
	  tag: 'PresentTense',
	  reason: 'this-verbs'
	}, // ==== Auxiliary ====
	//was walking
	{
	  match: "[#Copula (#Adverb|not)+?] (#Gerund|#PastTense)",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'copula-walking'
	}, //support a splattering of auxillaries before a verb
	{
	  match: "[(has|had) (#Adverb|not)+?] #PastTense",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'had-walked'
	}, //would walk
	{
	  match: "[#Adverb+? (#Modal|did)+ (#Adverb|not)+?] #Verb",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'modal-verb'
	}, //would have had
	{
	  match: "[#Modal (#Adverb|not)+? have (#Adverb|not)+? had (#Adverb|not)+?] #Verb",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'would-have'
	}, //would be walking
	// { match: `#Modal (#Adverb|not)+? be (#Adverb|not)+? #Verb`, group: 0, tag: 'Auxiliary', reason: 'would-be' },
	//had been walking
	// {
	//   match: `(#Modal|had|has) (#Adverb|not)+? been (#Adverb|not)+? #Verb`,
	//   group: 0,
	//   tag: 'Auxiliary',
	//   reason: 'had-been',
	// },
	//support a splattering of auxillaries before a verb
	{
	  match: "[(has|had) (#Adverb|not)+?] #PastTense",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'had-walked'
	}, // will walk
	{
	  match: '[(do|does|will|have|had)] (not|#Adverb)? #Verb',
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'have-had'
	}, // about to go
	{
	  match: '[about to] #Adverb? #Verb',
	  group: 0,
	  tag: ['Auxiliary', 'Verb'],
	  reason: 'about-to'
	}, //would be walking
	{
	  match: "#Modal (#Adverb|not)+? be (#Adverb|not)+? #Verb",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'would-be'
	}, //were being run
	{
	  match: "(were|was) being [#PresentTense]",
	  group: 0,
	  tag: 'PastTense',
	  reason: 'was-being'
	}, //have run
	// { match: `have #PresentTense`, group: 0, tag: 'PastTense', reason: 'have-vb' },
	//would have had
	{
	  match: "[#Modal (#Adverb|not)+? have (#Adverb|not)+? had (#Adverb|not)+?] #Verb",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'would-have'
	}, //had been walking
	{
	  match: "(#Modal|had|has) (#Adverb|not)+? been (#Adverb|not)+? #Verb",
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'had-been'
	}, // was being driven
	{
	  match: '[(be|being|been)] #Participle',
	  group: 0,
	  tag: 'Auxiliary',
	  reason: 'being-foo'
	}, // ==== Phrasal ====
	//'foo-up'
	{
	  match: '(#Verb && @hasHyphen) up',
	  tag: 'PhrasalVerb',
	  reason: 'foo-up'
	}, {
	  match: '(#Verb && @hasHyphen) off',
	  tag: 'PhrasalVerb',
	  reason: 'foo-off'
	}, {
	  match: '(#Verb && @hasHyphen) over',
	  tag: 'PhrasalVerb',
	  reason: 'foo-over'
	}, {
	  match: '(#Verb && @hasHyphen) out',
	  tag: 'PhrasalVerb',
	  reason: 'foo-out'
	}, //fall over
	{
	  match: '#PhrasalVerb [#PhrasalVerb]',
	  group: 0,
	  tag: 'Particle',
	  reason: 'phrasal-particle'
	}, //back it up
	{
	  match: '#Verb (him|her|it|us|himself|herself|itself|everything|something) [(up|down)]',
	  group: 0,
	  tag: 'Adverb',
	  reason: 'phrasal-pronoun-advb'
	}, // ==== Copula ====
	//will be running (not copula)
	{
	  match: '[will #Adverb? not? #Adverb? be] #Gerund',
	  group: 0,
	  tag: 'Copula',
	  reason: 'will-be-copula'
	}, //for more complex forms, just tag 'be'
	{
	  match: 'will #Adverb? not? #Adverb? [be] #Adjective',
	  group: 0,
	  tag: 'Copula',
	  reason: 'be-copula'
	}, // ==== Infinitive ====
	//march to
	{
	  match: '[march] (up|down|back|to|toward)',
	  group: 0,
	  tag: 'Infinitive',
	  reason: 'march-to'
	}, //must march
	{
	  match: '#Modal [march]',
	  group: 0,
	  tag: 'Infinitive',
	  reason: 'must-march'
	}, //let him glue
	{
	  match: '(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)',
	  group: 0,
	  tag: 'Infinitive',
	  reason: 'let-him-glue'
	}, //he quickly foo
	// { match: '#Noun #Adverb [#Noun]', group: 0, tag: 'Verb', reason: 'quickly-foo' },
	//will secure our
	{
	  match: 'will [#Adjective]',
	  group: 0,
	  tag: 'Verb',
	  reason: 'will-adj'
	}, //he disguised the thing
	{
	  match: '#Pronoun [#Adjective] #Determiner #Adjective? #Noun',
	  group: 0,
	  tag: 'Verb',
	  reason: 'he-adj-the'
	}, //is eager to go
	{
	  match: '#Copula [#Adjective to] #Verb',
	  group: 0,
	  tag: 'Verb',
	  reason: 'adj-to'
	}, // open the door
	{
	  match: '[open] #Determiner',
	  group: 0,
	  tag: 'Infinitive',
	  reason: 'open-the'
	}, // compromises are possible
	{
	  match: '[#PresentTense] (are|were|was) #Adjective',
	  group: 0,
	  tag: 'Plural',
	  reason: 'compromises-are-possible'
	}, // would wade
	{
	  match: "#Modal [".concat(verbs, "]"),
	  group: 0,
	  tag: 'Verb',
	  reason: 'would-mark'
	}, {
	  match: "#Adverb [".concat(verbs, "]"),
	  group: 0,
	  tag: 'Verb',
	  reason: 'really-mark'
	}, //to mark
	{
	  match: '(to|#Modal) [mark]',
	  group: 0,
	  tag: 'PresentTense',
	  reason: 'to-mark'
	}, // wade smith
	{
	  match: "".concat(verbs, " #Person"),
	  tag: 'Person',
	  reason: 'rob-smith'
	}, // wade m. Cooper
	{
	  match: "".concat(verbs, " #Acronym #ProperNoun"),
	  tag: 'Person',
	  reason: 'rob-a-smith'
	}, // damn them
	{
	  match: '[shit] (#Determiner|#Possessive|them)',
	  group: 0,
	  tag: 'Verb',
	  reason: 'swear1-verb'
	}, {
	  match: '[damn] (#Determiner|#Possessive|them)',
	  group: 0,
	  tag: 'Verb',
	  reason: 'swear2-verb'
	}, {
	  match: '[fuck] (#Determiner|#Possessive|them)',
	  group: 0,
	  tag: 'Verb',
	  reason: 'swear3-verb'
	}];
	var _07Verbs = list$2;

	var list$1 = [// ==== Region ====
	//West Norforlk
	{
	  match: '(west|north|south|east|western|northern|southern|eastern)+ #Place',
	  tag: 'Region',
	  reason: 'west-norfolk'
	}, //some us-state acronyms (exlude: al, in, la, mo, hi, me, md, ok..)
	{
	  match: '#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|or|pa|sc|tn|tx|ut|vt|pr)]',
	  group: 0,
	  tag: 'Region',
	  reason: 'us-state'
	}, //Foo District
	{
	  match: '#ProperNoun+ (district|region|province|county|prefecture|municipality|territory|burough|reservation)',
	  tag: 'Region',
	  reason: 'foo-district'
	}, //District of Foo
	{
	  match: '(district|region|province|municipality|territory|burough|state) of #ProperNoun',
	  tag: 'Region',
	  reason: 'district-of-Foo'
	}, // in Foo California
	{
	  match: 'in [#ProperNoun] #Place',
	  group: 0,
	  tag: 'Place',
	  reason: 'propernoun-place'
	}, // ==== Address ====
	{
	  match: '#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)',
	  tag: 'Address',
	  reason: 'address-st'
	} // in houston
	// { match: `in [${places}]`, group: 0, tag: 'Place', reason: 'in-paris' },
	// { match: `near [${places}]`, group: 0, tag: 'Place', reason: 'near-paris' },
	// { match: `at [${places}]`, group: 0, tag: 'Place', reason: 'at-paris' },
	// { match: `from [${places}]`, group: 0, tag: 'Place', reason: 'from-paris' },
	// { match: `to [${places}]`, group: 0, tag: 'Place', reason: 'to-paris' },
	// { match: `#Place [${places}]`, group: 0, tag: 'Place', reason: 'tokyo-paris' },
	// // houston texas
	// { match: `[${places}] #Place`, group: 0, tag: 'Place', reason: 'paris-france' },
	];
	var _08Place = list$1;

	var _09Org = [//John & Joe's
	{
	  match: '#Noun (&|n) #Noun',
	  tag: 'Organization',
	  reason: 'Noun-&-Noun'
	}, // teachers union of Ontario
	{
	  match: '#Organization of the? #ProperNoun',
	  tag: 'Organization',
	  reason: 'org-of-place',
	  safe: true
	}, //walmart USA
	{
	  match: '#Organization #Country',
	  tag: 'Organization',
	  reason: 'org-country'
	}, //organization
	{
	  match: '#ProperNoun #Organization',
	  tag: 'Organization',
	  reason: 'titlecase-org'
	}, //FitBit Inc
	{
	  match: '#ProperNoun (ltd|co|inc|dept|assn|bros)',
	  tag: 'Organization',
	  reason: 'org-abbrv'
	}, // the OCED
	{
	  match: 'the [#Acronym]',
	  group: 0,
	  tag: 'Organization',
	  reason: 'the-acronym',
	  safe: true
	}, // global trade union
	{
	  match: '(world|global|international|national|#Demonym) #Organization',
	  tag: 'Organization',
	  reason: 'global-org'
	}, // schools
	{
	  match: '#Noun+ (public|private) school',
	  tag: 'School',
	  reason: 'noun-public-school'
	}];

	var nouns = "(".concat(_ambig.personNoun.join('|'), ")");
	var months = "(".concat(_ambig.personMonth.join('|'), ")");
	var places = "(".concat(_ambig.personPlace.join('|'), ")");
	var list = [// ==== Honorific ====
	{
	  match: '[(1st|2nd|first|second)] #Honorific',
	  group: 0,
	  tag: 'Honorific',
	  reason: 'ordinal-honorific'
	}, {
	  match: '[(private|general|major|corporal|lord|lady|secretary|premier)] #Honorific? #Person',
	  group: 0,
	  tag: 'Honorific',
	  reason: 'ambg-honorifics'
	}, // ==== FirstNames ====
	//is foo Smith
	{
	  match: '#Copula [(#Noun|#PresentTense)] #LastName',
	  group: 0,
	  tag: 'FirstName',
	  reason: 'copula-noun-lastname'
	}, //pope francis
	{
	  match: '(lady|queen|sister) #ProperNoun',
	  tag: 'FemaleName',
	  reason: 'lady-titlecase',
	  safe: true
	}, {
	  match: '(king|pope|father) #ProperNoun',
	  tag: 'MaleName',
	  reason: 'pope-titlecase',
	  safe: true
	}, //ambiguous-but-common firstnames
	{
	  match: '[(will|may|april|june|said|rob|wade|ray|rusty|drew|miles|jack|chuck|randy|jan|pat|cliff|bill)] #LastName',
	  group: 0,
	  tag: 'FirstName',
	  reason: 'maybe-lastname'
	}, // ==== Nickname ====
	// Dwayne 'the rock' Johnson
	{
	  match: '#FirstName [#Determiner #Noun] #LastName',
	  group: 0,
	  tag: 'NickName',
	  reason: 'first-noun-last'
	}, //my buddy
	{
	  match: '#Possessive [#FirstName]',
	  group: 0,
	  tag: 'Person',
	  reason: 'possessive-name'
	}, {
	  match: '#ProperNoun (b|c|d|e|f|g|h|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) #ProperNoun',
	  tag: 'Person',
	  reason: 'titlecase-acronym-titlecase',
	  safe: true
	}, //ludwig van beethovan
	{
	  match: '#Acronym #LastName',
	  tag: 'Person',
	  reason: 'acronym-latname',
	  safe: true
	}, //jk rowling
	{
	  match: '#Person (jr|sr|md)',
	  tag: 'Person',
	  reason: 'person-honorific'
	}, //peter II
	{
	  match: '#Person #Person the? #RomanNumeral',
	  tag: 'Person',
	  reason: 'roman-numeral'
	}, //'Professor Fink', 'General McCarthy'
	{
	  match: '#FirstName [/^[^aiurck]$/]',
	  group: 0,
	  tag: ['Acronym', 'Person'],
	  reason: 'john-e'
	}, //Doctor john smith jr
	//general pearson
	{
	  match: '#Honorific #Person',
	  tag: 'Person',
	  reason: 'honorific-person'
	}, //remove single 'mr'
	{
	  match: '#Honorific #Acronym',
	  tag: 'Person',
	  reason: 'Honorific-TitleCase'
	}, //j.k Rowling
	{
	  match: '#Noun van der? #Noun',
	  tag: 'Person',
	  reason: 'van der noun',
	  safe: true
	}, //king of spain
	{
	  match: '(king|queen|prince|saint|lady) of #Noun',
	  tag: 'Person',
	  reason: 'king-of-noun',
	  safe: true
	}, //lady Florence
	{
	  match: '(prince|lady) #Place',
	  tag: 'Person',
	  reason: 'lady-place'
	}, //saint Foo
	{
	  match: '(king|queen|prince|saint) #ProperNoun',
	  tag: 'Person',
	  reason: 'saint-foo'
	}, //Foo U Ford
	{
	  match: '[#ProperNoun] #Person',
	  group: 0,
	  tag: 'Person',
	  reason: 'proper-person',
	  safe: true
	}, // al sharpton
	{
	  match: 'al (#Person|#ProperNoun)',
	  tag: 'Person',
	  reason: 'al-borlen',
	  safe: true
	}, //ferdinand de almar
	{
	  match: '#FirstName de #Noun',
	  tag: 'Person',
	  reason: 'bill-de-noun'
	}, //Osama bin Laden
	{
	  match: '#FirstName (bin|al) #Noun',
	  tag: 'Person',
	  reason: 'bill-al-noun'
	}, //John L. Foo
	{
	  match: '#FirstName #Acronym #ProperNoun',
	  tag: 'Person',
	  reason: 'bill-acronym-title'
	}, //Andrew Lloyd Webber
	{
	  match: '#FirstName #FirstName #ProperNoun',
	  tag: 'Person',
	  reason: 'bill-firstname-title'
	}, //Mr Foo
	{
	  match: '#Honorific #FirstName? #ProperNoun',
	  tag: 'Person',
	  reason: 'dr-john-Title'
	}, //peter the great
	{
	  match: '#FirstName the #Adjective',
	  tag: 'Person',
	  reason: 'name-the-great'
	}, //very common-but-ambiguous lastnames
	{
	  match: '#FirstName (green|white|brown|hall|young|king|hill|cook|gray|price)',
	  tag: 'Person',
	  reason: 'bill-green'
	}, // faith smith
	{
	  match: "".concat(nouns, " #Person"),
	  tag: 'Person',
	  reason: 'ray-smith',
	  safe: true
	}, // faith m. Smith
	{
	  match: "".concat(nouns, " #Acronym? #ProperNoun"),
	  tag: 'Person',
	  reason: 'ray-a-smith',
	  safe: true
	}, //give to april
	{
	  match: "#Infinitive #Determiner? #Adjective? #Noun? (to|for) [".concat(months, "]"),
	  group: 0,
	  tag: 'Person',
	  reason: 'ambig-person'
	}, // remind june
	{
	  match: "#Infinitive [".concat(months, "]"),
	  group: 0,
	  tag: 'Person',
	  reason: 'infinitive-person'
	}, // may waits for
	// { match: `[${months}] #PresentTense for`, group: 0, tag: 'Person', reason: 'ambig-active-for' },
	// may waits to
	// { match: `[${months}] #PresentTense to`, group: 0, tag: 'Person', reason: 'ambig-active-to' },
	// april will
	{
	  match: "[".concat(months, "] #Modal"),
	  group: 0,
	  tag: 'Person',
	  reason: 'ambig-modal'
	}, // may be
	{
	  match: "[may] be",
	  group: 0,
	  tag: 'Verb',
	  reason: 'may-be'
	}, // would april
	{
	  match: "#Modal [".concat(months, "]"),
	  group: 0,
	  tag: 'Person',
	  reason: 'modal-ambig'
	}, // it is may
	{
	  match: "#Copula [".concat(months, "]"),
	  group: 0,
	  tag: 'Person',
	  reason: 'is-may'
	}, // may is
	{
	  match: "[".concat(months, "] #Copula"),
	  group: 0,
	  tag: 'Person',
	  reason: 'may-is'
	}, // with april
	{
	  match: "that [".concat(months, "]"),
	  group: 0,
	  tag: 'Person',
	  reason: 'that-month'
	}, // with april
	{
	  match: "with [".concat(months, "]"),
	  group: 0,
	  tag: 'Person',
	  reason: 'with-month'
	}, // for april
	{
	  match: "for [".concat(months, "]"),
	  group: 0,
	  tag: 'Person',
	  reason: 'for-month'
	}, // this april
	{
	  match: "this [".concat(months, "]"),
	  group: 0,
	  tag: 'Month',
	  reason: 'this-may'
	}, //maybe not 'this'
	// next april
	{
	  match: "next [".concat(months, "]"),
	  group: 0,
	  tag: 'Month',
	  reason: 'next-may'
	}, // last april
	{
	  match: "last [".concat(months, "]"),
	  group: 0,
	  tag: 'Month',
	  reason: 'last-may'
	}, // wednesday april
	{
	  match: "#Date [".concat(months, "]"),
	  group: 0,
	  tag: 'Month',
	  reason: 'date-may'
	}, // may 5th
	{
	  match: "[".concat(months, "] the? #Value"),
	  group: 0,
	  tag: 'Month',
	  reason: 'may-5th'
	}, // 5th of may
	{
	  match: "#Value of [".concat(months, "]"),
	  group: 0,
	  tag: 'Month',
	  reason: '5th-of-may'
	}, // dick van dyke
	{
	  match: '#ProperNoun (van|al|bin) #ProperNoun',
	  tag: 'Person',
	  reason: 'title-van-title',
	  safe: true
	}, //jose de Sucre
	{
	  match: '#ProperNoun (de|du) la? #ProperNoun',
	  tag: 'Person',
	  reason: 'title-de-title',
	  safe: true
	}, //Jani K. Smith
	{
	  match: '#Singular #Acronym #LastName',
	  tag: '#Person',
	  reason: 'title-acro-noun',
	  safe: true
	}, //John Foo
	{
	  match: '#FirstName (#Noun && #ProperNoun) #ProperNoun?',
	  tag: 'Person',
	  reason: 'firstname-titlecase'
	}, //Joe K. Sombrero
	{
	  match: '#FirstName #Acronym #Noun',
	  tag: 'Person',
	  reason: 'n-acro-noun',
	  safe: true
	}, //Anthony de Marco
	{
	  match: '#FirstName [(de|di|du|van|von) #Person]',
	  group: 0,
	  tag: 'LastName',
	  reason: 'de-firstname'
	}, // Paris Berelc
	{
	  match: "[".concat(places, "] (#ProperNoun && !#Place)"),
	  group: 0,
	  tag: 'FirstName',
	  reason: 'place-firstname'
	}];
	var _10People = list;

	var matches = [];
	matches = matches.concat(_01Misc);
	matches = matches.concat(_02Dates);
	matches = matches.concat(_03Adjective);
	matches = matches.concat(_04Noun);
	matches = matches.concat(_05Adverb);
	matches = matches.concat(_06Value);
	matches = matches.concat(_07Verbs);
	matches = matches.concat(_08Place);
	matches = matches.concat(_09Org);
	matches = matches.concat(_10People); // cache the easier conditions up-front

	var cacheRequired = function cacheRequired(reg) {
	  var needTags = [];
	  var needWords = [];
	  reg.forEach(function (obj) {
	    if (obj.optional === true || obj.negative === true) {
	      return;
	    }

	    if (obj.tag !== undefined) {
	      needTags.push(obj.tag);
	    }

	    if (obj.word !== undefined) {
	      needWords.push(obj.word);
	    }
	  });
	  return {
	    tags: _unique(needTags),
	    words: _unique(needWords)
	  };
	}; // for speed, enumerate (a|b|c) to three matches


	var allLists = function allLists(m) {
	  var more = [];
	  var lists = m.reg.filter(function (r) {
	    return r.fastOr !== undefined;
	  });

	  if (lists.length === 1) {
	    var i = m.reg.findIndex(function (r) {
	      return r.fastOr !== undefined;
	    });
	    Object.keys(m.reg[i].fastOr).forEach(function (w) {
	      var newM = Object.assign({}, m);
	      newM.reg = newM.reg.slice(0);
	      newM.reg[i] = Object.assign({}, newM.reg[i]);
	      newM.reg[i].word = w;
	      delete newM.reg[i].operator;
	      delete newM.reg[i].fastOr; // newM.reason += '-' + w

	      more.push(newM);
	    });
	  }

	  return more;
	}; // parse them


	var all = [];
	matches.forEach(function (m) {
	  m.reg = matchSyntax(m.match);
	  var enumerated = allLists(m);

	  if (enumerated.length > 0) {
	    all = all.concat(enumerated);
	  } else {
	    all.push(m); // console.log(m)
	  }
	});
	all.forEach(function (m) {
	  m.required = cacheRequired(m.reg);
	  return m;
	}); // console.log(all.length)
	// console.log(all[all.length - 1])

	var matches_1 = all;

	var hasEvery = function hasEvery(chances) {
	  if (chances.length === 0) {
	    return [];
	  }

	  var obj = {};
	  chances.forEach(function (arr) {
	    arr = _unique(arr);

	    for (var i = 0; i < arr.length; i++) {
	      obj[arr[i]] = obj[arr[i]] || 0;
	      obj[arr[i]] += 1;
	    }
	  });
	  var res = Object.keys(obj);
	  res = res.filter(function (k) {
	    return obj[k] === chances.length;
	  });
	  res = res.map(function (num) {
	    return Number(num);
	  });
	  return res;
	};

	var runner = function runner(doc) {
	  //find phrases to try for each match
	  matches_1.forEach(function (m) {
	    var allChances = [];
	    m.required.words.forEach(function (w) {
	      allChances.push(doc._cache.words[w] || []);
	    });
	    m.required.tags.forEach(function (tag) {
	      allChances.push(doc._cache.tags[tag] || []);
	    });
	    var worthIt = hasEvery(allChances);

	    if (worthIt.length === 0) {
	      return;
	    }

	    var phrases = worthIt.map(function (index) {
	      return doc.list[index];
	    });
	    var tryDoc = doc.buildFrom(phrases); // phrases getting tagged

	    var match = tryDoc.match(m.reg, m.group);

	    if (match.found) {
	      if (m.safe === true) {
	        match.tagSafe(m.tag, m.reason);
	      } else {
	        match.tag(m.tag, m.reason);
	      }
	    }
	  });
	};

	var runner_1 = runner; // console.log(hasEvery([[1, 2, 2, 3], [2, 3], []]))

	// misc: 40ms
	//sequence of match-tag statements to correct mis-tags

	var corrections = function corrections(doc) {
	  runner_1(doc);
	  fixMisc(doc);
	  return doc;
	};

	var _04Correction = corrections;

	/** POS-tag all terms in this document */

	var tagger = function tagger(doc) {
	  var terms = doc.termList(); // check against any known-words

	  doc = _01Init(doc, terms); // everything has gotta be something. \_(:/)_/

	  doc = _02Fallbacks(doc, terms); // support "didn't" & "spencer's"

	  doc = _03Contractions(doc); //set our cache, to speed things up

	  doc.cache(); // wiggle-around the results, so they make more sense

	  doc = _04Correction(doc); // remove our cache, as it's invalidated now

	  doc.uncache(); // run any user-given tagger functions

	  doc.world.taggers.forEach(function (fn) {
	    fn(doc);
	  });
	  return doc;
	};

	var _02Tagger = tagger;

	var addMethod$a = function addMethod(Doc) {
	  /**  */
	  var Abbreviations = /*#__PURE__*/function (_Doc) {
	    _inherits(Abbreviations, _Doc);

	    var _super = _createSuper(Abbreviations);

	    function Abbreviations() {
	      _classCallCheck(this, Abbreviations);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Abbreviations, [{
	      key: "stripPeriods",
	      value: function stripPeriods() {
	        this.termList().forEach(function (t) {
	          if (t.tags.Abbreviation === true && t.next) {
	            t.post = t.post.replace(/^\./, '');
	          }

	          var str = t.text.replace(/\./, '');
	          t.set(str);
	        });
	        return this;
	      }
	    }, {
	      key: "addPeriods",
	      value: function addPeriods() {
	        this.termList().forEach(function (t) {
	          t.post = t.post.replace(/^\./, '');
	          t.post = '.' + t.post;
	        });
	        return this;
	      }
	    }]);

	    return Abbreviations;
	  }(Doc);

	  Abbreviations.prototype.unwrap = Abbreviations.prototype.stripPeriods;

	  Doc.prototype.abbreviations = function (n) {
	    var match = this.match('#Abbreviation');

	    if (typeof n === 'number') {
	      match = match.get(n);
	    }

	    return new Abbreviations(match.list, this, this.world);
	  };

	  return Doc;
	};

	var Abbreviations = addMethod$a;

	var hasPeriod = /\./;

	var addMethod$9 = function addMethod(Doc) {
	  /**  */
	  var Acronyms = /*#__PURE__*/function (_Doc) {
	    _inherits(Acronyms, _Doc);

	    var _super = _createSuper(Acronyms);

	    function Acronyms() {
	      _classCallCheck(this, Acronyms);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Acronyms, [{
	      key: "stripPeriods",
	      value: function stripPeriods() {
	        this.termList().forEach(function (t) {
	          var str = t.text.replace(/\./g, '');
	          t.set(str);
	        });
	        return this;
	      }
	    }, {
	      key: "addPeriods",
	      value: function addPeriods() {
	        this.termList().forEach(function (t) {
	          var str = t.text.replace(/\./g, '');
	          str = str.split('').join('.'); // don't add a end-period if there's a sentence-end one

	          if (hasPeriod.test(t.post) === false) {
	            str += '.';
	          }

	          t.set(str);
	        });
	        return this;
	      }
	    }]);

	    return Acronyms;
	  }(Doc);

	  Acronyms.prototype.unwrap = Acronyms.prototype.stripPeriods;
	  Acronyms.prototype.strip = Acronyms.prototype.stripPeriods;

	  Doc.prototype.acronyms = function (n) {
	    var match = this.match('#Acronym');

	    if (typeof n === 'number') {
	      match = match.get(n);
	    }

	    return new Acronyms(match.list, this, this.world);
	  };

	  return Doc;
	};

	var Acronyms = addMethod$9;

	var addMethod$8 = function addMethod(Doc) {
	  /** split into approximate sub-sentence phrases */
	  Doc.prototype.clauses = function (n) {
	    // an awkward way to disambiguate a comma use
	    var commas = this["if"]('@hasComma').notIf('@hasComma @hasComma') //fun, cool...
	    .notIf('@hasComma . .? (and|or) .') //cool, and fun
	    .notIf('(#City && @hasComma) #Country') //'toronto, canada'
	    .notIf('(#WeekDay && @hasComma) #Date') //'tuesday, march 2nd'
	    .notIf('(#Date && @hasComma) #Year') //'july 6, 1992'
	    .notIf('@hasComma (too|also)$') //at end of sentence
	    .match('@hasComma');
	    var found = this.splitAfter(commas);
	    var quotes = found.quotations();
	    found = found.splitOn(quotes);
	    var parentheses = found.parentheses();
	    found = found.splitOn(parentheses); // it is cool and it is ..

	    var conjunctions = found["if"]('#Copula #Adjective #Conjunction (#Pronoun|#Determiner) #Verb').match('#Conjunction');
	    found = found.splitBefore(conjunctions); // if it is this then that

	    var condition = found["if"]('if .{2,9} then .').match('then');
	    found = found.splitBefore(condition); // misc clause partitions

	    found = found.splitBefore('as well as .');
	    found = found.splitBefore('such as .');
	    found = found.splitBefore('in addition to .'); // semicolons, dashes

	    found = found.splitAfter('@hasSemicolon');
	    found = found.splitAfter('@hasDash'); // passive voice verb - '.. which was robbed is empty'
	    // let passive = found.match('#Noun (which|that) (was|is) #Adverb? #PastTense #Adverb?')
	    // if (passive.found) {
	    //   found = found.splitAfter(passive)
	    // }
	    // //which the boy robbed
	    // passive = found.match('#Noun (which|that) the? #Noun+ #Adverb? #PastTense #Adverb?')
	    // if (passive.found) {
	    //   found = found.splitAfter(passive)
	    // }
	    // does there appear to have relative/subordinate clause still?

	    var tooLong = found.filter(function (d) {
	      return d.wordCount() > 5 && d.match('#Verb+').length >= 2;
	    });

	    if (tooLong.found) {
	      var m = tooLong.splitAfter('#Noun .* #Verb .* #Noun+');
	      found = found.splitOn(m.eq(0));
	    }

	    if (typeof n === 'number') {
	      found = found.get(n);
	    }

	    return new Doc(found.list, this, this.world);
	  };

	  return Doc;
	};

	var Clauses = addMethod$8;

	var addMethod$7 = function addMethod(Doc) {
	  /**  */
	  var Contractions = /*#__PURE__*/function (_Doc) {
	    _inherits(Contractions, _Doc);

	    var _super = _createSuper(Contractions);

	    function Contractions(list, from, world) {
	      var _this;

	      _classCallCheck(this, Contractions);

	      _this = _super.call(this, list, from, world);
	      _this.contracted = null;
	      return _this;
	    }
	    /** turn didn't into 'did not' */


	    _createClass(Contractions, [{
	      key: "expand",
	      value: function expand() {
	        this.list.forEach(function (p) {
	          var terms = p.terms(); //change the case?

	          var isTitlecase = terms[0].isTitleCase();
	          terms.forEach(function (t, i) {
	            //use the implicit text
	            t.set(t.implicit || t.text);
	            t.implicit = undefined; //add whitespace

	            if (i < terms.length - 1 && t.post === '') {
	              t.post += ' ';
	            }
	          }); //set titlecase

	          if (isTitlecase) {
	            terms[0].toTitleCase();
	          }
	        });
	        return this;
	      }
	    }]);

	    return Contractions;
	  }(Doc); //find contractable, expanded-contractions
	  // const findExpanded = r => {
	  //   let remain = r.not('#Contraction')
	  //   let m = remain.match('(#Noun|#QuestionWord) (#Copula|did|do|have|had|could|would|will)')
	  //   m.concat(remain.match('(they|we|you|i) have'))
	  //   m.concat(remain.match('i am'))
	  //   m.concat(remain.match('(#Copula|#Modal|do|does|have|has|can|will) not'))
	  //   return m
	  // }


	  Doc.prototype.contractions = function (n) {
	    //find currently-contracted
	    var found = this.match('@hasContraction+'); //(may want to split these up)
	    //todo: split consecutive contractions

	    if (typeof n === 'number') {
	      found = found.get(n);
	    }

	    return new Contractions(found.list, this, this.world);
	  }; //aliases


	  Doc.prototype.expanded = Doc.prototype.isExpanded;
	  Doc.prototype.contracted = Doc.prototype.isContracted;
	  return Doc;
	};

	var Contractions = addMethod$7;

	var addMethod$6 = function addMethod(Doc) {
	  //pull it apart..
	  var parse = function parse(doc) {
	    var things = doc.splitAfter('@hasComma').splitOn('(and|or) not?').not('(and|or) not?');
	    var beforeLast = doc.match('[.] (and|or)', 0);
	    return {
	      things: things,
	      conjunction: doc.match('(and|or) not?'),
	      beforeLast: beforeLast,
	      hasOxford: beforeLast.has('@hasComma')
	    };
	  };
	  /** cool, fun, and nice */


	  var Lists = /*#__PURE__*/function (_Doc) {
	    _inherits(Lists, _Doc);

	    var _super = _createSuper(Lists);

	    function Lists() {
	      _classCallCheck(this, Lists);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Lists, [{
	      key: "conjunctions",
	      value:
	      /** coordinating conjunction */
	      function conjunctions() {
	        return this.match('(and|or)');
	      }
	      /** split-up by list object */

	    }, {
	      key: "parts",
	      value: function parts() {
	        return this.splitAfter('@hasComma').splitOn('(and|or) not?');
	      }
	      /** remove the conjunction */

	    }, {
	      key: "items",
	      value: function items() {
	        return parse(this).things;
	      }
	      /** add a new unit to the list */

	    }, {
	      key: "add",
	      value: function add(str) {
	        this.forEach(function (p) {
	          var beforeLast = parse(p).beforeLast;
	          beforeLast.append(str); //add a comma to it

	          beforeLast.termList(0).addPunctuation(',');
	        });
	        return this;
	      }
	      /** remove any matching unit from the list */

	    }, {
	      key: "remove",
	      value: function remove(match) {
	        return this.items()["if"](match).remove();
	      }
	      /** return only lists that use a serial comma */

	    }, {
	      key: "hasOxfordComma",
	      value: function hasOxfordComma() {
	        return this.filter(function (doc) {
	          return parse(doc).hasOxford;
	        });
	      }
	    }, {
	      key: "addOxfordComma",
	      value: function addOxfordComma() {
	        var items = this.items();
	        var needsComma = items.eq(items.length - 2);

	        if (needsComma.found && needsComma.has('@hasComma') === false) {
	          needsComma.post(', ');
	        }

	        return this;
	      }
	    }, {
	      key: "removeOxfordComma",
	      value: function removeOxfordComma() {
	        var items = this.items();
	        var needsComma = items.eq(items.length - 2);

	        if (needsComma.found && needsComma.has('@hasComma') === true) {
	          needsComma.post(' ');
	        }

	        return this;
	      }
	    }]);

	    return Lists;
	  }(Doc); // aliases


	  Lists.prototype.things = Lists.prototype.items;

	  Doc.prototype.lists = function (n) {
	    var m = this["if"]('@hasComma+ .? (and|or) not? .'); // person-list

	    var nounList = m.match('(#Noun|#Adjective|#Determiner|#Article)+ #Conjunction not? (#Article|#Determiner)? #Adjective? #Noun+')["if"]('#Noun');
	    var adjList = m.match('(#Adjective|#Adverb)+ #Conjunction not? #Adverb? #Adjective+');
	    var verbList = m.match('(#Verb|#Adverb)+ #Conjunction not? #Adverb? #Verb+');
	    var result = nounList.concat(adjList);
	    result = result.concat(verbList);
	    result = result["if"]('@hasComma');

	    if (typeof n === 'number') {
	      result = m.get(n);
	    }

	    return new Lists(result.list, this, this.world);
	  };

	  return Doc;
	};

	var Lists = addMethod$6;

	var noPlural = '(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)'; //certain words can't be plural, like 'peace'

	var hasPlural = function hasPlural(doc) {
	  if (doc.has('#Plural') === true) {
	    return true;
	  } // these can't be plural


	  if (doc.has(noPlural) === true) {
	    return false;
	  }

	  return true;
	};

	var hasPlural_1 = hasPlural;

	var irregulars = {
	  hour: 'an',
	  heir: 'an',
	  heirloom: 'an',
	  honest: 'an',
	  honour: 'an',
	  honor: 'an',
	  uber: 'an' //german u

	}; //pronounced letters of acronyms that get a 'an'

	var an_acronyms = {
	  a: true,
	  e: true,
	  f: true,
	  h: true,
	  i: true,
	  l: true,
	  m: true,
	  n: true,
	  o: true,
	  r: true,
	  s: true,
	  x: true
	}; //'a' regexes

	var a_regexs = [/^onc?e/i, //'wu' sound of 'o'
	/^u[bcfhjkqrstn][aeiou]/i, // 'yu' sound for hard 'u'
	/^eul/i];

	var makeArticle = function makeArticle(doc) {
	  //no 'the john smith', but 'a london hotel'
	  if (doc.has('#Person') || doc.has('#Place')) {
	    return '';
	  } //no a/an if it's plural


	  if (doc.has('#Plural')) {
	    return 'the';
	  }

	  var str = doc.text('normal').trim(); //explicit irregular forms

	  if (irregulars.hasOwnProperty(str)) {
	    return irregulars[str];
	  } //spelled-out acronyms


	  var firstLetter = str.substr(0, 1);

	  if (doc.has('^@isAcronym') && an_acronyms.hasOwnProperty(firstLetter)) {
	    return 'an';
	  } //'a' regexes


	  for (var i = 0; i < a_regexs.length; i++) {
	    if (a_regexs[i].test(str)) {
	      return 'a';
	    }
	  } //basic vowel-startings


	  if (/^[aeiou]/i.test(str)) {
	    return 'an';
	  }

	  return 'a';
	};

	var getArticle = makeArticle;

	//similar to plural/singularize rules, but not the same
	var isPlural$2 = [/(antenn|formul|nebul|vertebr|vit)ae$/i, /(octop|vir|radi|nucle|fung|cact|stimul)i$/i, /men$/i, /.tia$/i, /(m|l)ice$/i]; //similar to plural/singularize rules, but not the same

	var isSingular = [/(ax|test)is$/i, /(octop|vir|radi|nucle|fung|cact|stimul)us$/i, /(octop|vir)i$/i, /(rl)f$/i, /(alias|status)$/i, /(bu)s$/i, /(al|ad|at|er|et|ed|ad)o$/i, /(ti)um$/i, /(ti)a$/i, /sis$/i, /(?:(^f)fe|(lr)f)$/i, /hive$/i, /(^aeiouy|qu)y$/i, /(x|ch|ss|sh|z)$/i, /(matr|vert|ind|cort)(ix|ex)$/i, /(m|l)ouse$/i, /(m|l)ice$/i, /(antenn|formul|nebul|vertebr|vit)a$/i, /.sis$/i, /^(?!talis|.*hu)(.*)man$/i];
	var _rules = {
	  isSingular: isSingular,
	  isPlural: isPlural$2
	};

	var endS = /s$/; // double-check this term, if it is not plural, or singular.
	// (this is a partial copy of ./tagger/fallbacks/plural)
	// fallback plural if it ends in an 's'.

	var isPlural$1 = function isPlural(str) {
	  // isSingular suffix rules
	  if (_rules.isSingular.find(function (reg) {
	    return reg.test(str);
	  })) {
	    return false;
	  } // does it end in an s?


	  if (endS.test(str) === true) {
	    return true;
	  } // is it a plural like 'fungi'?


	  if (_rules.isPlural.find(function (reg) {
	    return reg.test(str);
	  })) {
	    return true;
	  }

	  return null;
	};

	var isPlural_1$1 = isPlural$1;

	var exceptions = {
	  he: 'his',
	  she: 'hers',
	  they: 'theirs',
	  we: 'ours',
	  i: 'mine',
	  you: 'yours',
	  her: 'hers',
	  their: 'theirs',
	  our: 'ours',
	  my: 'mine',
	  your: 'yours'
	}; // turn "David" to "David's"

	var toPossessive = function toPossessive(doc) {
	  var str = doc.text('text').trim(); // exceptions

	  if (exceptions.hasOwnProperty(str)) {
	    doc.replaceWith(exceptions[str], true);
	    doc.tag('Possessive', 'toPossessive');
	    return;
	  } // flanders'


	  if (/s$/.test(str)) {
	    str += "'";
	    doc.replaceWith(str, true);
	    doc.tag('Possessive', 'toPossessive');
	    return;
	  } //normal form:


	  str += "'s";
	  doc.replaceWith(str, true);
	  doc.tag('Possessive', 'toPossessive');
	  return;
	};

	var toPossessive_1 = toPossessive;

	// .nouns() supports some noun-phrase-ish groupings
	// pull these apart, if necessary
	var parse$1 = function parse(doc) {
	  var res = {
	    main: doc
	  }; //support 'mayor of chicago' as one noun-phrase

	  if (doc.has('#Noun (of|by|for) .')) {
	    var m = doc.splitAfter('[#Noun+]', 0);
	    res.main = m.eq(0);
	    res.post = m.eq(1);
	  }

	  return res;
	};

	var parse_1 = parse$1;

	var methods$2 = {
	  /** overload the original json with noun information */
	  json: function json(options) {
	    var n = null;

	    if (typeof options === 'number') {
	      n = options;
	      options = null;
	    }

	    options = options || {
	      text: true,
	      normal: true,
	      trim: true,
	      terms: true
	    };
	    var res = [];
	    this.forEach(function (doc) {
	      var json = doc.json(options)[0];
	      json.article = getArticle(doc);
	      res.push(json);
	    });

	    if (n !== null) {
	      return res[n];
	    }

	    return res;
	  },

	  /** get all adjectives describing this noun*/
	  adjectives: function adjectives() {
	    var list = this.lookAhead('^(that|who|which)? (was|is|will)? be? #Adverb? #Adjective+');
	    list = list.concat(this.lookBehind('#Adjective+ #Adverb?$'));
	    list = list.match('#Adjective');
	    return list.sort('index');
	  },
	  isPlural: function isPlural() {
	    return this["if"]('#Plural'); //assume tagger has run?
	  },
	  hasPlural: function hasPlural() {
	    return this.filter(function (d) {
	      return hasPlural_1(d);
	    });
	  },
	  toPlural: function toPlural(agree) {
	    var _this = this;

	    var toPlural = this.world.transforms.toPlural;
	    this.forEach(function (doc) {
	      if (doc.has('#Plural') || hasPlural_1(doc) === false) {
	        return;
	      } // double-check it isn't an un-tagged plural


	      var main = parse_1(doc).main;
	      var str = main.text('reduced');

	      if (!main.has('#Singular') && isPlural_1$1(str) === true) {
	        return;
	      }

	      str = toPlural(str, _this.world);
	      main.replace(str).tag('#Plural'); // 'an apple' -> 'apples'

	      if (agree) {
	        var an = main.lookBefore('(an|a) #Adjective?$').not('#Adjective');

	        if (an.found === true) {
	          an.remove();
	        }
	      }
	    });
	    return this;
	  },
	  toSingular: function toSingular(agree) {
	    var _this2 = this;

	    var toSingular = this.world.transforms.toSingular;
	    this.forEach(function (doc) {
	      if (doc.has('^#Singular+$') || hasPlural_1(doc) === false) {
	        return;
	      } // double-check it isn't an un-tagged plural


	      var main = parse_1(doc).main;
	      var str = main.text('reduced');

	      if (!main.has('#Plural') && isPlural_1$1(str) !== true) {
	        return;
	      }

	      str = toSingular(str, _this2.world);
	      main.replace(str).tag('#Singular'); // add an article

	      if (agree) {
	        // 'apples' -> 'an apple'
	        var start = doc;
	        var adj = doc.lookBefore('#Adjective');

	        if (adj.found) {
	          start = adj;
	        }

	        var article = getArticle(start);
	        start.insertBefore(article);
	      }
	    });
	    return this;
	  },
	  toPossessive: function toPossessive() {
	    this.forEach(function (d) {
	      toPossessive_1(d);
	    });
	    return this;
	  }
	};
	var methods_1 = methods$2;

	var addMethod$5 = function addMethod(Doc) {
	  /**  */
	  var Nouns = /*#__PURE__*/function (_Doc) {
	    _inherits(Nouns, _Doc);

	    var _super = _createSuper(Nouns);

	    function Nouns() {
	      _classCallCheck(this, Nouns);

	      return _super.apply(this, arguments);
	    }

	    return Nouns;
	  }(Doc); // add-in our methods


	  Object.assign(Nouns.prototype, methods_1);

	  Doc.prototype.nouns = function (n) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    // don't split 'paris, france'
	    var keep = this.match('(#City && @hasComma) (#Region|#Country)'); // but split the other commas

	    var m = this.not(keep).splitAfter('@hasComma'); // combine them back together

	    m = m.concat(keep); // don't combine over scare-quotes

	    var quotes = m.quotations();

	    if (quotes.found) {
	      m = m.splitOn(quotes.eq(0));
	    }

	    m = m.match('#Noun+ (of|by)? the? #Noun+?'); //nouns that we don't want in these results, for weird reasons

	    if (opts.keep_anaphora !== true) {
	      m = m.not('#Pronoun');
	      m = m.not('(there|these)');
	      m = m.not('(#Month|#WeekDay)'); //allow Durations, Holidays
	      // //allow possessives like "spencer's", but not generic ones like,

	      m = m.not('(my|our|your|their|her|his)');
	    }

	    m = m.not('(of|for|by|the)$');

	    if (typeof n === 'number') {
	      m = m.get(n);
	    }

	    return new Nouns(m.list, this, this.world);
	  };

	  return Doc;
	};

	var Nouns = addMethod$5;

	var open = /\(/;
	var close = /\)/;

	var addMethod$4 = function addMethod(Doc) {
	  /** anything between (these things) */
	  var Parentheses = /*#__PURE__*/function (_Doc) {
	    _inherits(Parentheses, _Doc);

	    var _super = _createSuper(Parentheses);

	    function Parentheses() {
	      _classCallCheck(this, Parentheses);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Parentheses, [{
	      key: "unwrap",
	      value:
	      /** remove the parentheses characters */
	      function unwrap() {
	        this.list.forEach(function (p) {
	          var first = p.terms(0);
	          first.pre = first.pre.replace(open, '');
	          var last = p.lastTerm();
	          last.post = last.post.replace(close, '');
	        });
	        return this;
	      }
	    }]);

	    return Parentheses;
	  }(Doc);

	  Doc.prototype.parentheses = function (n) {
	    var list = [];
	    this.list.forEach(function (p) {
	      var terms = p.terms(); //look for opening brackets

	      for (var i = 0; i < terms.length; i += 1) {
	        var t = terms[i];

	        if (open.test(t.pre)) {
	          //look for the closing bracket..
	          for (var o = i; o < terms.length; o += 1) {
	            if (close.test(terms[o].post)) {
	              var len = o - i + 1;
	              list.push(p.buildFrom(t.id, len));
	              i = o;
	              break;
	            }
	          }
	        }
	      }
	    }); //support nth result

	    if (typeof n === 'number') {
	      if (list[n]) {
	        list = [list[n]];
	      } else {
	        list = [];
	      }

	      return new Parentheses(list, this, this.world);
	    }

	    return new Parentheses(list, this, this.world);
	  };

	  return Doc;
	};

	var Parentheses = addMethod$4;

	var addMethod$3 = function addMethod(Doc) {
	  /**  */
	  var Possessives = /*#__PURE__*/function (_Doc) {
	    _inherits(Possessives, _Doc);

	    var _super = _createSuper(Possessives);

	    function Possessives(list, from, world) {
	      var _this;

	      _classCallCheck(this, Possessives);

	      _this = _super.call(this, list, from, world);
	      _this.contracted = null;
	      return _this;
	    }
	    /** turn didn't into 'did not' */


	    _createClass(Possessives, [{
	      key: "strip",
	      value: function strip() {
	        this.list.forEach(function (p) {
	          var terms = p.terms();
	          terms.forEach(function (t) {
	            var str = t.text.replace(/'s$/, '');
	            t.set(str || t.text);
	          });
	        });
	        return this;
	      }
	    }]);

	    return Possessives;
	  }(Doc); //find contractable, expanded-contractions
	  // const findExpanded = r => {
	  //   let remain = r.not('#Contraction')
	  //   let m = remain.match('(#Noun|#QuestionWord) (#Copula|did|do|have|had|could|would|will)')
	  //   m.concat(remain.match('(they|we|you|i) have'))
	  //   m.concat(remain.match('i am'))
	  //   m.concat(remain.match('(#Copula|#Modal|do|does|have|has|can|will) not'))
	  //   return m
	  // }


	  Doc.prototype.possessives = function (n) {
	    //find currently-contracted
	    var found = this.match('#Noun+? #Possessive'); //todo: split consecutive contractions

	    if (typeof n === 'number') {
	      found = found.get(n);
	    }

	    return new Possessives(found.list, this, this.world);
	  };

	  return Doc;
	};

	var Possessives = addMethod$3;

	var pairs = {
	  "\"": "\"",
	  // 'StraightDoubleQuotes'
	  "\uFF02": "\uFF02",
	  // 'StraightDoubleQuotesWide'
	  "'": "'",
	  // 'StraightSingleQuotes'
	  "\u201C": "\u201D",
	  // 'CommaDoubleQuotes'
	  "\u2018": "\u2019",
	  // 'CommaSingleQuotes'
	  "\u201F": "\u201D",
	  // 'CurlyDoubleQuotesReversed'
	  "\u201B": "\u2019",
	  // 'CurlySingleQuotesReversed'
	  "\u201E": "\u201D",
	  // 'LowCurlyDoubleQuotes'
	  "\u2E42": "\u201D",
	  // 'LowCurlyDoubleQuotesReversed'
	  "\u201A": "\u2019",
	  // 'LowCurlySingleQuotes'
	  "\xAB": "\xBB",
	  // 'AngleDoubleQuotes'
	  "\u2039": "\u203A",
	  // 'AngleSingleQuotes'
	  // Prime 'non quotation'
	  "\u2035": "\u2032",
	  // 'PrimeSingleQuotes'
	  "\u2036": "\u2033",
	  // 'PrimeDoubleQuotes'
	  "\u2037": "\u2034",
	  // 'PrimeTripleQuotes'
	  // Prime 'quotation' variation
	  "\u301D": "\u301E",
	  // 'PrimeDoubleQuotes'
	  "`": "\xB4",
	  // 'PrimeSingleQuotes'
	  "\u301F": "\u301E" // 'LowPrimeDoubleQuotesReversed'

	};
	var hasOpen = RegExp('(' + Object.keys(pairs).join('|') + ')');

	var addMethod$2 = function addMethod(Doc) {
	  /** "these things" */
	  var Quotations = /*#__PURE__*/function (_Doc) {
	    _inherits(Quotations, _Doc);

	    var _super = _createSuper(Quotations);

	    function Quotations() {
	      _classCallCheck(this, Quotations);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Quotations, [{
	      key: "unwrap",
	      value:
	      /** remove the quote characters */
	      function unwrap() {
	        return this;
	      }
	    }]);

	    return Quotations;
	  }(Doc);

	  Doc.prototype.quotations = function (n) {
	    var list = [];
	    this.list.forEach(function (p) {
	      var terms = p.terms(); //look for opening quotes

	      for (var i = 0; i < terms.length; i += 1) {
	        var t = terms[i];

	        if (hasOpen.test(t.pre)) {
	          var _char = (t.pre.match(hasOpen) || [])[0];
	          var want = pairs[_char]; // if (!want) {
	          //   console.warn('missing quote char ' + char)
	          // }
	          //look for the closing bracket..

	          for (var o = i; o < terms.length; o += 1) {
	            if (terms[o].post.indexOf(want) !== -1) {
	              var len = o - i + 1;
	              list.push(p.buildFrom(t.id, len));
	              i = o;
	              break;
	            }
	          }
	        }
	      }
	    }); //support nth result

	    if (typeof n === 'number') {
	      if (list[n]) {
	        list = [list[n]];
	      } else {
	        list = [];
	      }

	      return new Quotations(list, this, this.world);
	    }

	    return new Quotations(list, this, this.world);
	  }; // alias


	  Doc.prototype.quotes = Doc.prototype.quotations;
	  return Doc;
	};

	var Quotations = addMethod$2;

	// walked => walk  - turn a verb into it's root form
	var toInfinitive = function toInfinitive(parsed, world) {
	  var verb = parsed.verb; // console.log(parsed)
	  // verb.debug()
	  //1. if it's already infinitive

	  var str = verb.text('reduced');

	  if (verb.has('#Infinitive')) {
	    return str;
	  } // 2. world transform does the heavy-lifting


	  var tense = null;

	  if (verb.has('#PastTense')) {
	    tense = 'PastTense';
	  } else if (verb.has('#Gerund')) {
	    tense = 'Gerund';
	  } else if (verb.has('#PresentTense')) {
	    tense = 'PresentTense';
	  } else if (verb.has('#Participle')) {
	    tense = 'Participle';
	  } else if (verb.has('#Actor')) {
	    tense = 'Actor';
	  }

	  return world.transforms.toInfinitive(str, world, tense);
	};

	var toInfinitive_1 = toInfinitive;

	// spencer walks -> singular
	// we walk -> plural
	// the most-recent noun-phrase, before this verb.
	var findNoun = function findNoun(vb) {
	  var noun = vb.lookBehind('#Noun+').last();
	  return noun;
	}; //sometimes you can tell if a verb is plural/singular, just by the verb
	// i am / we were
	// othertimes you need its subject 'we walk' vs 'i walk'


	var isPlural = function isPlural(parsed) {
	  var vb = parsed.verb;

	  if (vb.has('(are|were|does)') || parsed.auxiliary.has('(are|were|does)')) {
	    return true;
	  }

	  if (vb.has('(is|am|do|was)') || parsed.auxiliary.has('(is|am|do|was)')) {
	    return false;
	  } //consider its prior noun


	  var noun = findNoun(vb);

	  if (noun.has('(we|they|you)')) {
	    return true;
	  }

	  if (noun.has('#Plural')) {
	    return true;
	  }

	  if (noun.has('#Singular')) {
	    return false;
	  }

	  return null;
	};

	var isPlural_1 = isPlural;

	// #Copula : is           -> 'is not'
	// #PastTense : walked    -> did not walk
	// #PresentTense : walks  -> does not walk
	// #Gerund : walking:     -> not walking
	// #Infinitive : walk     -> do not walk

	var toNegative = function toNegative(parsed, world) {
	  var vb = parsed.verb; // if it's already negative...

	  if (parsed.negative.found) {
	    return;
	  } // would walk -> would not walk


	  if (parsed.auxiliary.found) {
	    parsed.auxiliary.eq(0).append('not'); // 'would not have'  'would not have'

	    if (parsed.auxiliary.has('#Modal have not')) {
	      parsed.auxiliary.replace('have not', 'not have');
	    }

	    return;
	  } // is walking -> is not walking


	  if (vb.has('(#Copula|will|has|had|do)')) {
	    vb.append('not');
	    return;
	  } // walked -> did not walk


	  if (vb.has('#PastTense')) {
	    var inf = toInfinitive_1(parsed, world);
	    vb.replaceWith(inf, true);
	    vb.prepend('did not');
	    return;
	  } // walks -> does not walk


	  if (vb.has('#PresentTense')) {
	    var _inf = toInfinitive_1(parsed, world);

	    vb.replaceWith(_inf, true);

	    if (isPlural_1(parsed)) {
	      vb.prepend('do not');
	    } else {
	      vb.prepend('does not');
	    }

	    return;
	  } //walking -> not walking


	  if (vb.has('#Gerund')) {
	    var _inf2 = toInfinitive_1(parsed, world);

	    vb.replaceWith(_inf2, true);
	    vb.prepend('not');
	    return;
	  } //fallback 1:  walk -> does not walk


	  if (isPlural_1(parsed)) {
	    vb.prepend('does not');
	    return;
	  } //fallback 2:  walk -> do not walk


	  vb.prepend('do not');
	  return;
	};

	var toNegative_1 = toNegative;

	// who/what is doing this verb?
	// get the prior verb most-likely doing this action
	// (it can not-exist - 'close the door')
	var getSubject = function getSubject(vb) {
	  var behind = vb.lookBehind();
	  var lastNoun = behind.nouns(null, {
	    keep_anaphora: true
	  }).last(); // support 'that' and 'this'

	  if (!lastNoun.found) {
	    lastNoun = behind.match('(that|this|each)').last();
	    lastNoun = lastNoun.tag('#Noun').nouns();
	  }

	  return lastNoun;
	};

	var getSubject_1 = getSubject;

	var parseVerb = function parseVerb(vb) {
	  var parsed = {
	    adverb: vb.match('#Adverb+'),
	    // 'really'
	    negative: vb.match('#Negative'),
	    // 'not'
	    auxiliary: vb.match('#Auxiliary+').not('(#Negative|#Adverb)'),
	    // 'will' of 'will go'
	    particle: vb.match('#Particle'),
	    // 'up' of 'pull up'
	    verb: vb.match('#Verb+').not('(#Adverb|#Negative|#Auxiliary|#Particle)'),
	    original: vb,
	    subject: getSubject_1(vb)
	  }; // fallback, if no verb found

	  if (!parsed.verb.found) {
	    // blank-everything
	    Object.keys(parsed).forEach(function (k) {
	      parsed[k] = parsed[k].not('.');
	    }); // it's all the verb

	    parsed.verb = vb;
	    return parsed;
	  } //


	  if (parsed.adverb && parsed.adverb.found) {
	    var match = parsed.adverb.text('reduced') + '$';

	    if (vb.has(match)) {
	      parsed.adverbAfter = true;
	    }
	  }

	  return parsed;
	};

	var parse = parseVerb;

	/** too many special cases for is/was/will be*/

	var toBe = function toBe(parsed) {
	  var isI = false;
	  var plural = isPlural_1(parsed);
	  var isNegative = parsed.negative.found; //account for 'i is' -> 'i am' irregular
	  // if (vb.parent && vb.parent.has('i #Adverb? #Copula')) {
	  //   isI = true;
	  // }
	  // 'i look', not 'i looks'

	  if (parsed.verb.lookBehind('(i|we) (#Adverb|#Verb)?$').found) {
	    isI = true;
	  }

	  var obj = {
	    PastTense: 'was',
	    PresentTense: 'is',
	    FutureTense: 'will be',
	    Infinitive: 'is',
	    Gerund: 'being',
	    Actor: '',
	    PerfectTense: 'been',
	    Pluperfect: 'been'
	  }; //"i is" -> "i am"

	  if (isI === true) {
	    obj.PresentTense = 'am';
	    obj.Infinitive = 'am';
	  }

	  if (plural) {
	    obj.PastTense = 'were';
	    obj.PresentTense = 'are';
	    obj.Infinitive = 'are';
	  }

	  if (isNegative) {
	    obj.PastTense += ' not';
	    obj.PresentTense += ' not';
	    obj.FutureTense = 'will not be';
	    obj.Infinitive += ' not';
	    obj.PerfectTense = 'not ' + obj.PerfectTense;
	    obj.Pluperfect = 'not ' + obj.Pluperfect;
	    obj.Gerund = 'not ' + obj.Gerund;
	  }

	  return obj;
	};

	var toBe_1 = toBe;

	// 'may/could/should' -> 'may/could/should have'
	var doModal = function doModal(parsed) {
	  var str = parsed.verb.text();
	  var res = {
	    PastTense: str + ' have',
	    PresentTense: str,
	    FutureTense: str,
	    Infinitive: str // Gerund: ,
	    // Actor: '',
	    // PerfectTense: '',
	    // Pluperfect: '',

	  };
	  return res;
	};

	var doModal_1 = doModal;

	var conjugate = function conjugate(parsed, world) {
	  var verb = parsed.verb; //special handling of 'is', 'will be', etc.

	  if (verb.has('#Copula') || verb.out('normal') === 'be' && parsed.auxiliary.has('will')) {
	    return toBe_1(parsed);
	  } // special handling of 'are walking'


	  if (parsed.auxiliary.has('are') && verb.has('#Gerund')) {
	    var og = parsed.original.clone();
	    var past = og.clone().replace('are', 'were');
	    var fut = og.clone().replace('are', 'will be');

	    var _infinitive = toInfinitive_1(parsed, world);

	    var res = {
	      PastTense: past.text(),
	      PresentTense: og.text(),
	      FutureTense: fut.text(),
	      Infinitive: _infinitive
	    };
	    return res;
	  } // special handling of 'he could.'


	  if (verb.has('#Modal')) {
	    return doModal_1(parsed);
	  } // dont conjugate imperative form - 'close the door'
	  // if (parsed.auxiliary.has('do')) {
	  //   let str = parsed.original.text()
	  //   let res = {
	  //     PastTense: str,
	  //     PresentTense: str,
	  //     FutureTense: str,
	  //     Infinitive: str,
	  //   }
	  //   return res
	  // }


	  var hasHyphen = parsed.verb.termList(0).hasHyphen();
	  var infinitive = toInfinitive_1(parsed, world);

	  if (!infinitive) {
	    return {};
	  }

	  var forms = world.transforms.conjugate(infinitive, world);
	  forms.Infinitive = infinitive; // add particle to phrasal verbs ('fall over')

	  if (parsed.particle.found) {
	    var particle = parsed.particle.text();
	    var space = hasHyphen === true ? '-' : ' ';
	    Object.keys(forms).forEach(function (k) {
	      return forms[k] += space + particle;
	    });
	  } //put the adverb at the end?
	  // if (parsed.adverb.found) {
	  // let adverb = parsed.adverb.text()
	  // let space = hasHyphen === true ? '-' : ' '
	  // if (parsed.adverbAfter === true) {
	  //   Object.keys(forms).forEach(k => (forms[k] += space + adverb))
	  // } else {
	  //   Object.keys(forms).forEach(k => (forms[k] = adverb + space + forms[k]))
	  // }
	  // }
	  //apply negative


	  var isNegative = parsed.negative.found;

	  if (isNegative) {
	    forms.PastTense = 'did not ' + forms.Infinitive;
	    forms.PresentTense = 'does not ' + forms.Infinitive;
	    forms.Gerund = 'not ' + forms.Gerund;
	  } //future Tense is pretty straightforward


	  if (!forms.FutureTense) {
	    if (isNegative) {
	      forms.FutureTense = 'will not ' + forms.Infinitive;
	    } else {
	      forms.FutureTense = 'will ' + forms.Infinitive;
	    }
	  }

	  if (isNegative) {
	    forms.Infinitive = 'not ' + forms.Infinitive;
	  }

	  return forms;
	};

	var conjugate_1 = conjugate;

	// if something is 'modal-ish' we are forced to use past-participle
	// ('i could drove' is wrong)

	var useParticiple$1 = function useParticiple(parsed) {
	  if (parsed.auxiliary.has('(could|should|would|may|can|must)')) {
	    return true;
	  }

	  if (parsed.auxiliary.has('am .+? being')) {
	    return true;
	  }

	  if (parsed.auxiliary.has('had .+? been')) {
	    return true;
	  }

	  return false;
	}; // conjugate 'drive'  'have driven'


	var toParticiple = function toParticiple(parsed, world) {
	  //is it already a participle?
	  if (parsed.auxiliary.has('(have|had)') && parsed.verb.has('#Participle')) {
	    return;
	  } // try to swap the main verb to its participle form


	  var obj = conjugate_1(parsed, world);
	  var str = obj.Participle || obj.PastTense;

	  if (str) {
	    parsed.verb.replaceWith(str, false);
	  } // 'am being driven'  'have been driven'


	  if (parsed.auxiliary.has('am .+? being')) {
	    parsed.auxiliary.remove('am');
	    parsed.auxiliary.replace('being', 'have been');
	  } // add a 'have'


	  if (!parsed.auxiliary.has('have')) {
	    parsed.auxiliary.append('have');
	  } // tag it as a participle


	  parsed.verb.tag('Participle', 'toParticiple'); // turn 'i can swim' to -> 'i could swim'

	  parsed.auxiliary.replace('can', 'could'); //'must be'  'must have been'

	  parsed.auxiliary.replace('be have', 'have been'); //'not have'  'have not'

	  parsed.auxiliary.replace('not have', 'have not'); // ensure all new words are tagged right

	  parsed.auxiliary.tag('Auxiliary');
	};

	var participle = {
	  useParticiple: useParticiple$1,
	  toParticiple: toParticiple
	};

	var _toParticiple = participle.toParticiple,
	    useParticiple = participle.useParticiple; // remove any tense-information in auxiliary verbs

	var makeNeutral = function makeNeutral(parsed) {
	  //remove tense-info from auxiliaries
	  parsed.auxiliary.remove('(will|are|am|being)');
	  parsed.auxiliary.remove('(did|does)');
	  parsed.auxiliary.remove('(had|has|have)'); //our conjugation includes the 'not' and the phrasal-verb particle

	  parsed.particle.remove();
	  parsed.negative.remove();
	  return parsed;
	};

	var methods$1 = {
	  /** overload the original json with verb information */
	  json: function json(options) {
	    var _this = this;

	    var n = null;

	    if (typeof options === 'number') {
	      n = options;
	      options = null;
	    }

	    options = options || {
	      text: true,
	      normal: true,
	      trim: true,
	      terms: true
	    };
	    var res = [];
	    this.forEach(function (p) {
	      var json = p.json(options)[0];
	      var parsed = parse(p);
	      json.parts = {};
	      Object.keys(parsed).forEach(function (k) {
	        if (parsed[k] && parsed[k].isA === 'Doc') {
	          json.parts[k] = parsed[k].text('normal');
	        } else {
	          json.parts[k] = parsed[k];
	        }
	      });
	      json.isNegative = p.has('#Negative');
	      json.conjugations = conjugate_1(parsed, _this.world);
	      res.push(json);
	    });

	    if (n !== null) {
	      return res[n];
	    }

	    return res;
	  },

	  /** grab the adverbs describing these verbs */
	  adverbs: function adverbs() {
	    var list = []; // look at internal adverbs

	    this.forEach(function (vb) {
	      var advb = parse(vb).adverb;

	      if (advb.found) {
	        list = list.concat(advb.list);
	      }
	    }); // look for leading adverbs

	    var m = this.lookBehind('#Adverb+$');

	    if (m.found) {
	      list = m.list.concat(list);
	    } // look for trailing adverbs


	    m = this.lookAhead('^#Adverb+');

	    if (m.found) {
	      list = list.concat(m.list);
	    }

	    return this.buildFrom(list);
	  },
	  /// Verb Inflection

	  /**return verbs like 'we walk' and not 'spencer walks' */
	  isPlural: function isPlural() {
	    var _this2 = this;

	    var list = [];
	    this.forEach(function (vb) {
	      var parsed = parse(vb);

	      if (isPlural_1(parsed, _this2.world) === true) {
	        list.push(vb.list[0]);
	      }
	    });
	    return this.buildFrom(list);
	  },

	  /** return verbs like 'spencer walks' and not 'we walk' */
	  isSingular: function isSingular() {
	    var _this3 = this;

	    var list = [];
	    this.forEach(function (vb) {
	      var parsed = parse(vb);

	      if (isPlural_1(parsed, _this3.world) === false) {
	        list.push(vb.list[0]);
	      }
	    });
	    return this.buildFrom(list);
	  },
	  /// Conjugation

	  /** return all forms of this verb  */
	  conjugate: function conjugate() {
	    var _this4 = this;

	    var result = [];
	    this.forEach(function (vb) {
	      var parsed = parse(vb);

	      var forms = conjugate_1(parsed, _this4.world);

	      result.push(forms);
	    });
	    return result;
	  },

	  /** walk  walked*/
	  toPastTense: function toPastTense() {
	    var _this5 = this;

	    this.forEach(function (vb) {
	      var parsed = parse(vb); // should we support 'would swim'  'would have swam'

	      if (useParticiple(parsed)) {
	        _toParticiple(parsed, _this5.world);

	        return;
	      }

	      if (vb.has('#Imperative')) {
	        return;
	      } // don't conjugate 'to be'


	      if (vb.has('be') && vb.lookBehind('to$').found) {
	        return;
	      } // handle 'is raining' -> 'was raining'


	      if (parsed.verb.has('#Gerund') && parsed.auxiliary.has('(is|will|was)')) {
	        vb.replace('is', 'was');
	        return;
	      }

	      var str = conjugate_1(parsed, _this5.world).PastTense;

	      if (str) {
	        parsed = makeNeutral(parsed);
	        parsed.verb.replaceWith(str, false); // vb.tag('PastTense')
	      }
	    });
	    return this;
	  },

	  /** walk  walks */
	  toPresentTense: function toPresentTense() {
	    var _this6 = this;

	    this.forEach(function (vb) {
	      var parsed = parse(vb);

	      var obj = conjugate_1(parsed, _this6.world);

	      var str = obj.PresentTense; // 'i look', not 'i looks'

	      if (vb.lookBehind('(i|we) (#Adverb|#Verb)?$').found) {
	        str = obj.Infinitive;
	      }

	      if (str) {
	        //awkward support for present-participle form
	        // -- should we support 'have been swimming'  'am swimming'
	        if (parsed.auxiliary.has('(have|had) been')) {
	          parsed.auxiliary.replace('(have|had) been', 'am being');

	          if (obj.Particle) {
	            str = obj.Particle || obj.PastTense;
	          }

	          return;
	        }

	        parsed.verb.replaceWith(str, false);
	        parsed.verb.tag('PresentTense');
	        parsed = makeNeutral(parsed); // avoid 'he would walks'

	        parsed.auxiliary.remove('#Modal');
	      }
	    });
	    return this;
	  },

	  /** walk  will walk*/
	  toFutureTense: function toFutureTense() {
	    var _this7 = this;

	    this.forEach(function (vb) {
	      var parsed = parse(vb); // 'i should drive' is already future-enough

	      if (useParticiple(parsed)) {
	        return;
	      }

	      var str = conjugate_1(parsed, _this7.world).FutureTense;

	      if (str) {
	        parsed = makeNeutral(parsed); // avoid 'he would will go'

	        parsed.auxiliary.remove('#Modal');
	        parsed.verb.replaceWith(str, false);
	        parsed.verb.tag('FutureTense');
	      }
	    });
	    return this;
	  },

	  /** walks  walk */
	  toInfinitive: function toInfinitive() {
	    var _this8 = this;

	    this.forEach(function (vb) {
	      var parsed = parse(vb);

	      var str = conjugate_1(parsed, _this8.world).Infinitive;

	      if (str) {
	        vb.replaceWith(str, false);
	        vb.tag('Infinitive');
	      }
	    });
	    return this;
	  },

	  /** walk  walking */
	  toGerund: function toGerund() {
	    var _this9 = this;

	    this.forEach(function (vb) {
	      var parsed = parse(vb);

	      var str = conjugate_1(parsed, _this9.world).Gerund;

	      if (str) {
	        vb.replaceWith(str, false);
	        vb.tag('Gerund');
	      }
	    });
	    return this;
	  },

	  /** drive  driven - naked past-participle if it exists, otherwise past-tense */
	  toParticiple: function toParticiple() {
	    var _this10 = this;

	    this.forEach(function (vb) {
	      var parsed = parse(vb);
	      var noAux = !parsed.auxiliary.found;

	      _toParticiple(parsed, _this10.world); // dirty trick to  ensure our new auxiliary is found


	      if (noAux) {
	        parsed.verb.prepend(parsed.auxiliary.text());
	        parsed.auxiliary.remove();
	      }
	    });
	    return this;
	  },
	  /// Negation

	  /** return only verbs with 'not'*/
	  isNegative: function isNegative() {
	    return this["if"]('#Negative');
	  },

	  /**  return only verbs without 'not'*/
	  isPositive: function isPositive() {
	    return this.ifNo('#Negative');
	  },

	  /**  return only commands - verbs in imperative mood */
	  isImperative: function isImperative() {
	    return this["if"]('#Imperative');
	  },

	  /** add a 'not' to these verbs */
	  toNegative: function toNegative() {
	    var _this11 = this;

	    this.list.forEach(function (p) {
	      var doc = _this11.buildFrom([p]);

	      var parsed = parse(doc);

	      toNegative_1(parsed, doc.world);
	    });
	    return this;
	  },

	  /** remove 'not' from these verbs */
	  toPositive: function toPositive() {
	    var m = this.match('do not #Verb');

	    if (m.found) {
	      m.remove('do not');
	    }

	    return this.remove('#Negative');
	  },

	  /** who, or what is doing this action? */
	  subject: function subject() {
	    var list = [];
	    this.forEach(function (p) {
	      var found = getSubject_1(p);

	      if (found.list[0]) {
	        list.push(found.list[0]);
	      }
	    });
	    return this.buildFrom(list);
	  }
	};

	var addMethod$1 = function addMethod(Doc) {
	  /**  */
	  var Verbs = /*#__PURE__*/function (_Doc) {
	    _inherits(Verbs, _Doc);

	    var _super = _createSuper(Verbs);

	    function Verbs() {
	      _classCallCheck(this, Verbs);

	      return _super.apply(this, arguments);
	    }

	    return Verbs;
	  }(Doc); // add-in our methods


	  Object.assign(Verbs.prototype, methods$1); // aliases

	  Verbs.prototype.negate = Verbs.prototype.toNegative;

	  Doc.prototype.verbs = function (n) {
	    var match = this.match('(#Adverb|#Auxiliary|#Verb|#Negative|#Particle)+'); // try to ignore leading and trailing adverbs

	    match = match.not('^#Adverb+');
	    match = match.not('#Adverb+$'); // handle commas:
	    // don't split 'really, really'

	    var keep = match.match('(#Adverb && @hasComma) #Adverb'); // // but split the other commas

	    var m = match.not(keep).splitAfter('@hasComma'); // i was shocked looking at...

	    var gerund = m.match('#PastTense #Gerund');

	    if (!gerund.has('(been|am|#Auxiliary) #Gerund')) {
	      m = m.splitBefore(gerund.match('#Gerund'));
	    } // combine them back together


	    m = m.concat(keep);
	    m.sort('index'); //handle slashes?
	    //ensure there's actually a verb

	    m = m["if"]('#Verb'); // the reason he will is ...

	    if (m.has('(is|was)$')) {
	      m = m.splitBefore('(is|was)$');
	    } //ensure it's not two verbs


	    if (m.has('#PresentTense #Adverb #PresentTense')) {
	      m = m.splitBefore('#Adverb #PresentTense');
	    } //grab (n)th result


	    if (typeof n === 'number') {
	      m = m.get(n);
	    }

	    var vb = new Verbs(m.list, this, this.world);
	    return vb;
	  };

	  return Doc;
	};

	var Verbs = addMethod$1;

	var addMethod = function addMethod(Doc) {
	  /**  */
	  var People = /*#__PURE__*/function (_Doc) {
	    _inherits(People, _Doc);

	    var _super = _createSuper(People);

	    function People() {
	      _classCallCheck(this, People);

	      return _super.apply(this, arguments);
	    }

	    return People;
	  }(Doc);

	  Doc.prototype.people = function (n) {
	    var match = this.splitAfter('@hasComma');
	    match = match.match('#Person+'); //grab (n)th result

	    if (typeof n === 'number') {
	      match = match.get(n);
	    }

	    return new People(match.list, this, this.world);
	  };

	  return Doc;
	};

	var People = addMethod;

	var subclass = [Abbreviations, Acronyms, Clauses, Contractions, Lists, Nouns, Parentheses, Possessives, Quotations, Verbs, People];

	var extend = function extend(Doc) {
	  // add basic methods
	  Object.keys(_simple).forEach(function (k) {
	    return Doc.prototype[k] = _simple[k];
	  }); // add subclassed methods

	  subclass.forEach(function (addFn) {
	    return addFn(Doc);
	  });
	  return Doc;
	};

	var Subset = extend;

	var methods = {
	  misc: methods$4,
	  selections: _simple
	};
	/** a parsed text object */

	var Doc = /*#__PURE__*/function () {
	  function Doc(list, from, world) {
	    var _this = this;

	    _classCallCheck(this, Doc);

	    this.list = list; // this.reasons = []
	    //quiet these properties in console.logs

	    Object.defineProperty(this, 'from', {
	      enumerable: false,
	      value: from,
	      writable: true
	    }); //borrow some missing data from parent

	    if (world === undefined && from !== undefined) {
	      world = from.world;
	    } //'world' getter


	    Object.defineProperty(this, 'world', {
	      enumerable: false,
	      value: world,
	      writable: true
	    }); //fast-scans for our data

	    Object.defineProperty(this, '_cache', {
	      enumerable: false,
	      writable: true,
	      value: {}
	    }); //'found' getter

	    Object.defineProperty(this, 'found', {
	      get: function get() {
	        return _this.list.length > 0;
	      }
	    }); //'length' getter

	    Object.defineProperty(this, 'length', {
	      get: function get() {
	        return _this.list.length;
	      }
	    }); // this is way easier than .constructor.name...

	    Object.defineProperty(this, 'isA', {
	      get: function get() {
	        return 'Doc';
	      }
	    });
	  }
	  /** run part-of-speech tagger on all results*/


	  _createClass(Doc, [{
	    key: "tagger",
	    value: function tagger() {
	      return _02Tagger(this);
	    }
	    /** pool is stored on phrase objects */

	  }, {
	    key: "pool",
	    value: function pool() {
	      if (this.list.length > 0) {
	        return this.list[0].pool;
	      }

	      return this.all().list[0].pool;
	    }
	  }]);

	  return Doc;
	}();
	/** create a new Document object */


	Doc.prototype.buildFrom = function (list) {
	  list = list.map(function (p) {
	    return p.clone(true);
	  }); // new this.constructor()

	  var doc = new Doc(list, this, this.world);
	  return doc;
	};
	/** create a new Document from plaintext. */


	Doc.prototype.fromText = function (str) {
	  var list = _01Tokenizer(str, this.world, this.pool());
	  return this.buildFrom(list);
	};

	Object.assign(Doc.prototype, methods.misc);
	Object.assign(Doc.prototype, methods.selections); //add sub-classes

	Subset(Doc); //aliases

	var aliases = {
	  untag: 'unTag',
	  and: 'match',
	  notIf: 'ifNo',
	  only: 'if',
	  onlyIf: 'if'
	};
	Object.keys(aliases).forEach(function (k) {
	  return Doc.prototype[k] = Doc.prototype[aliases[k]];
	});
	var Doc_1 = Doc;

	var smallTagger = function smallTagger(doc) {
	  var terms = doc.termList();
	  _01Lexicon(terms, doc.world); // run any user-given tagger functions

	  doc.world.taggers.forEach(function (fn) {
	    fn(doc);
	  });
	  return doc;
	};

	var tiny = smallTagger;

	function instance(worldInstance) {
	  //blast-out our word-lists, just once
	  var world = worldInstance;
	  /** parse and tag text into a compromise object  */

	  var nlp = function nlp() {
	    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var lexicon = arguments.length > 1 ? arguments[1] : undefined;

	    if (lexicon) {
	      world.addWords(lexicon);
	    }

	    var list = _01Tokenizer(text, world);
	    var doc = new Doc_1(list, null, world);
	    doc.tagger();
	    return doc;
	  };
	  /** parse text into a compromise object, without running POS-tagging */


	  nlp.tokenize = function () {
	    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var lexicon = arguments.length > 1 ? arguments[1] : undefined;
	    var w = world;

	    if (lexicon) {
	      w = w.clone();
	      w.words = {};
	      w.addWords(lexicon);
	    }

	    var list = _01Tokenizer(text, w);
	    var doc = new Doc_1(list, null, w);

	    if (lexicon || doc.world.taggers.length > 0) {
	      tiny(doc);
	    }

	    return doc;
	  };
	  /** mix in a compromise-plugin */


	  nlp.extend = function (fn) {
	    fn(Doc_1, world, this, Phrase_1, Term_1, Pool_1);
	    return this;
	  };
	  /** create a compromise Doc object from .json() results */


	  nlp.fromJSON = function (json) {
	    var list = fromJSON_1(json, world);
	    return new Doc_1(list, null, world);
	  };
	  /** make a deep-copy of the library state */


	  nlp.clone = function () {
	    return instance(world.clone());
	  };
	  /** log our decision-making for debugging */


	  nlp.verbose = function () {
	    var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	    world.verbose(bool);
	    return this;
	  };
	  /** grab currently-used World object */


	  nlp.world = function () {
	    return world;
	  };
	  /** pre-parse any match statements */


	  nlp.parseMatch = function (str, opts) {
	    return matchSyntax(str, opts);
	  };
	  /** current version of the library */


	  nlp.version = _version; // aliases

	  nlp["import"] = nlp.load;
	  nlp.plugin = nlp.extend;
	  return nlp;
	}

	var src = instance(new World_1());

	function elementify(el){
	  // pipeline to vanillafy pragma objects to html elements
	  if (el instanceof N) el = el.element;
	  if (!el.isPragmaElement) el = j(el);
	  return el
	}

	// function getViewportHeight(){
	//   return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
	// }
	//
	// export function getRelativeScreen(el){
	//   el = elementify(el)
	//   let eee = _e(el)
	//   let rect = el.getBoundingClientRect()
	//   return  {
	//             top: rect.top, // has to be bigger than 0
	//             bottom: rect.bottom-getViewportHeight()// has to be smaller than
	//           }
	// }

	globalThis.lectorSpace = globalThis.lectorSpace || {};

	function isElementWithin(el, r={}){
	  let off = el.offset();
	  let elTop = off.top;
	  let elBot = off.top + el.rect().height;
	  return (elTop <= r.bot && elBot >= r.top) || (elTop <= r.top && elBot >= r.bot)
	}

	function isOnScreen(el, threshold=100){
	  if (!el) throw E.throwSoft(`couldnt not evaluate if [${el}] is on screen`)
	  el = elementify(el);
	  let winTop = window.scrollY;
	  let winBot = winTop + window.innerHeight;
	  let eee = isElementWithin(el, {top: winTop+threshold , bot: winBot-threshold});
	  return eee
	}

	function scrollTo(el, duration=200, threshold=200){
	  // behavior
	  // closer, will scroll little bit downwards or upwards
	  // until the element is in view for more than the threshold

	  //return new Promise(r => r())
	  //el = jqueryfy(el)
	  //

	  el = elementify(el);
	  return new Promise((resolve, reject) => {
	    const body = window.document.scrollingElement || window.document.body || window.document.documentElement;
	    const top = el.offset().top - threshold;
	    anime({
	      targets: body,
	      scrollTop: top,
	      duration: duration,
	      easing: 'easeInOutSine',
	    }).finished.then(() => {
	      setTimeout(resolve, 20);
	    });
	  })
	}



	function _onScroll(cb){
	  let last = 0;
	  let ticking = false;
	  document.addEventListener('scroll', function(e) {
	    let temp = last;
	    last = window.scrollY;
	    if (!ticking) {
	      window.requestAnimationFrame(function() {
	        cb(last, last-temp);
	        ticking = false;
	      });
	      ticking = true;
	    }
	  });
	}

	function onScroll(cb){
	  if (!globalThis.lectorSpace.scrollChain){
	    E.createChains(globalThis.lectorSpace, 'scroll');
	    _onScroll((scroll, ds) => {
	      globalThis.lectorSpace.scrollChain.exec(scroll, ds);
	    });
	  }
	  globalThis.lectorSpace.onScroll(cb);
	}

	function _onScrollEnd(cb){

	  let scrollData = { s: null, ds: null };
	  let t;

	  onScroll((s, ds) => {
	    scrollData = {
	      s: s,
	      ds: ds
	    };

	    if (t) clearTimeout(t);

	    t = setTimeout(_ => {
	      cb(scrollData.s, scrollData.ds);
	    }, 50);
	  });
	}

	function onScrollEnd(cb){
	  if (!globalThis.lectorSpace.scrollEndChain){
	    E.createChains(globalThis.lectorSpace, 'scrollEnd');

	      _onScrollEnd((scroll, ds) => {
	        globalThis.lectorSpace.scrollEndChain.exec(scroll, ds);
	      });  
	  }
	  globalThis.lectorSpace.onScrollEnd(cb);
	}

	//export function onSlowScroll(cb, sensit=10){
	  //onScroll((_, dp) => {
	    //if (dp<=sensit) cb()
	  //})
	//}

	const greek_prefixes = ['an', 'an', 'ap', 'di', 'dy', 'ec', 'eg', 'en', 'em', 'eo', 'ep', 'eu', 'id', 'is', 'my', 'ne', 'od', 'oo', 'ot', 'sy', 'ur', 'ur', 'zo', 'pto', 'pyl', 'acr', 'aer', 'agr', 'ana', 'ant', 'apo', 'aut', 'bar', 'bio', 'cac', 'cat', 'cen', 'cen', 'con', 'cub', 'cyn', 'dec', 'dek', 'dem', 'dia', 'dox', 'eco', 'ego', 'eme', 'eos', 'epi', 'erg', 'eso', 'eth', 'eur', 'exo', 'geo', 'gen', 'hem', 'hal', 'hen', 'hex', 'hod', 'hol', 'hor', 'hor', 'hyo', 'hyp', 'ide', 'idi', 'iso', 'kil', 'lei', 'lep', 'lip', 'log', 'meg', 'mei', 'men', 'mer', 'mes', 'mim', 'mis', 'mit', 'mne', 'mon', 'myx', 'nes', 'nom', 'oct', 'oed', 'oen', 'omm', 'ont', 'opt', 'pan', 'pam', 'par', 'ped', 'pin', 'pis', 'pol', 'por', 'pro', 'rhe', 'sei', 'sit', 'syn', 'syl', 'sym', 'tax', 'the', 'the', 'tom', 'ton', 'top', 'tox', 'tri', 'ulo', 'uro', 'uro', 'xen', 'xer', 'zon', 'zyg', 'psil', 'prot', 'pros', 'amph', 'anem', 'anti', 'anth', 'arct', 'astr', 'athl', 'auto', 'basi', 'bibl', 'briz', 'brom', 'brom', 'call', 'carp', 'carp', 'cata', 'chir', 'cine', 'cirr', 'clad', 'clav', 'coel', 'copr', 'cosm', 'crep', 'cris', 'crit', 'cten', 'cyan', 'cycl', 'cyst', 'deca', 'deka', 'delt', 'derm', 'dexi', 'dino', 'dipl', 'ecto', 'endo', 'engy', 'eoso', 'etho', 'ethi', 'ethm', 'ethn', 'etym', 'fant', 'glia', 'gram', 'gymn', 'haem', 'hapl', 'heli', 'hemi', 'hept', 'herp', 'heur', 'hipp', 'home', 'horm', 'hyal', 'hydr', 'hygr', 'hypn', 'icos', 'kine', 'lamp', 'leps', 'leuc', 'leuk', 'lith', 'metr', 'meta', 'micr', 'myri', 'myth', 'narc', 'naut', 'necr', 'nect', 'nema', 'neur', 'noth', 'noto', 'oeco', 'ogdo', 'olig', 'onom', 'ophi', 'orch', 'orth', 'pach', 'paed', 'pale', 'path', 'patr', 'pect', 'pent', 'pept', 'peri', 'petr', 'phae', 'phag', 'pher', 'phil', 'phob', 'phon', 'phor', 'phos', 'phot', 'phyl', 'phys', 'plac', 'plas', 'plec', 'plut', 'pneu', 'poie', 'pole', 'poli', 'poli', 'poly', 'raph', 'rhag', 'rhig', 'rhin', 'rhiz', 'rhod', 'sarc', 'scel', 'scop', 'sema', 'siph', 'soma', 'soph', 'stea', 'steg', 'sten', 'stig', 'stom', 'styl', 'tach', 'tars', 'taur', 'tele', 'tele', 'temn', 'tetr', 'than', 'thus', 'ther', 'thym', 'thyr', 'trag', 'trit', 'trop', 'xiph', 'proct', 'ptych', 'amphi', 'arche', 'archi', 'arche', 'arist', 'arthr', 'bathy', 'batho', 'blenn', 'blast', 'botan', 'brady', 'bront', 'calli', 'calyp', 'cardi', 'centr', 'ceram', 'cerat', 'chlor', 'chore', 'chrom', 'chron', 'chrys', 'clast', 'clist', 'cochl', 'corac', 'cotyl', 'crani', 'cross', 'crypt', 'dendr', 'dodec', 'dynam', 'ennea', 'gastr', 'graph', 'heter', 'homal', 'hyper', 'klept', 'lekan', 'macro', 'melan', 'meter', 'morph', 'nephr', 'nomad', 'odont', 'organ', 'osteo', 'palae', 'palin', 'peran', 'phleg', 'phloe', 'phren', 'phryn', 'phyll', 'plagi', 'platy', 'plesi', 'pleth', 'pleur', 'pogon', 'polem', 'potam', 'rhabd', 'rhomb', 'scaph', 'schem', 'schis', 'scler', 'scoli', 'scept', 'scyph', 'selen', 'solen', 'sperm', 'sphen', 'spher', 'stern', 'stich', 'stoch', 'taeni', 'techn', 'therm', 'thyre', 'traum', 'trema', 'trich', 'troch', 'troph', 'xanth', 'psych', 'archae', 'brachi', 'brachy', 'bronch', 'cathar', 'cephal', 'chelon', 'cleist', 'cosmet', 'cylind', 'dactyl', 'deuter', 'dogmat', 'erythr', 'galact', 'hendec', 'ichthy', 'mening', 'myrmec', 'omphal', 'opisth', 'opoter', 'ornith', 'ostrac', 'persic', 'phalar', 'phaner', 'phragm', 'plinth', 'prasin', 'presby', 'rhynch', 'scalen', 'strept', 'stroph', 'thalam', 'theori', 'trachy', 'trapez', 'tympan', 'aesthet', 'anthrop', 'branchi', 'cleithr', 'epistem', 'parthen', 'phalang', 'pharmac', 'porphyr', 'sacchar', 'sphinct', 'stalact', 'stalagm', 'thalass', 'oesophag', 'ophthalm', 'physalid', 'pentecost', 'treiskaidek'];

	function crush(n) {
	  const xa = 1; const ya = 4; const xb = 7; const yb = 6; const xc = 8; const yc = 7; const xd = 16; const yd = 10;
	  if (n <= xa) return ya
	  if (n <= xb) return ((yb - ya) / (xb - xa)) * (n - xa) + ya
	  if (n <= xc) return ((yc - yb) / (xc - xb)) * (n - xb) + yb
	  return ((yd - yc) / (xd - xc)) * (n - xc) + yc
	}

	function generateDifficultyIndex(word) {
	  // returns 0-1 with 0 being not difficult at all
	  let d = 0;
	  let w = src(word.text);
	  if (w.has('#Verb')) {
	    d += .5;
	  }
	  if (w.has('#Acronym')) {
	    d += .8;
	  }
	  let greekF = howGreek(word.text);
	  if (greekF > 1) {
	    d += greekF / 10;
	  }
	  return Math.min(1, Math.min(d, 1));
	}

	function wordValue(word, d) {
	  return crush(word.text.length) * (d + 1)
	}

	function charsMsAt(wpm) {
	  const avgCharsInWord = 4.7;
	  return 1000 / ((wpm / 60) * avgCharsInWord)
	}

	function howGreek(word) {
	  let length = word.length;
	  if (length < 5) return 0
	  for (let prefix of greek_prefixes) {
	    if (prefix.length >= length - 3) return 0
	    if (prefix == word.substring(0, prefix.length)) return prefix.length
	  }
	  return 0
	}

	class PinkyPromise {
	  constructor(executor) {
	    let _reject = null;
	    let _resolve = null;
	    
	    const cancelablePromise = new Promise((resolve, reject) => {
	      _reject = reject;
	      _resolve = resolve;
	      return executor(resolve, reject);
	    });
	    cancelablePromise.cancel = _reject;
	    cancelablePromise.resolve = _resolve;

	    return cancelablePromise;
	  }
	}

	class Idle {
	  constructor(idleTime){
	    this.afkChain = new Map;
	    this.activeChain = new Map;
	    this.idleTime = idleTime;
	    this.isIdle = false;
	    
	    const events = [ 'load', 'mousemove'];

	    events.forEach( event => {
	      window.addEventListener(event, _ => this.reset());
	    });
	  }

	  generateActionKey(key){
	    if (key == null) key = this.afkChain.size;
	    return key
	  }
	  
	  onAfk(cb, key){
	    this.afkChain.set(this.generateActionKey(key), cb); 
	    return this
	  }
	  
	  onActive(cb, key){
	    this.activeChain.set(this.generateActionKey(key), cb); 
	    return this
	  }

	  reset(){
	    clearTimeout(this.t);
	    this.t = setTimeout(() => this.idle(), this.idleTime);  // time is in milliseconds
	    this.active();
	    return this
	  }
	  
	  idle(){
	    if (this.isIdle) return false
	    this.isIdle = true;
	    doMap(this.afkChain); 
	    return this
	  }

	  active(){
	    if (!this.isIdle) return false
	    this.isIdle = false; 
	    doMap(this.activeChain);
	    return this
	  }
	}



	function doMap(map){
	  for (const [ key, cb ] of map.entries()){
	      cb();
	  }
	}

	function wfyInner$1(desc){
	  if (!desc) return false
	  desc = j(desc);
	  desc.textContent;
	  let inner = "";
	  for (let txt of desc.textContent.split(" ")){
	    // console.log(txt)
	    console.log(typeof txt);
	    let noWhiteSpace = txt.replace(/\s/g, "");
	    inner += noWhiteSpace.length!=0 ? "<w>"+txt.split(" ").join("</w> <w>")+"</w> " : txt;
	  }

	  desc.html(inner);
	}

	function wfyElement$1(element){
	  element = j(element);
	  let nodes = element.findAll("*");
	  if (nodes.length == 0) return wfyInner$1(wfyInner$1(element))
	  nodes.forEach(desc => wfyElement$1(desc));
	}

	function wfy(element){
	  // console.log(`wfying ${JSON.stringify(element)}`)
	  element = j(element);
	  // if (element.textContent.replaceAll(" ", "").length<1) return false
	  let txtNodes = element.findAll("p, div, h1, h2, h3, h3, h4, h5, article, text");
	  if (txtNodes.length==0) return wfyElement$1(element)
	  // txtNodes.each((i, el) => {
	  //   wfy(el)
	  // })
	  txtNodes.forEach(el => wfy(el));
	  return true
	}

	// airway handles the start of the marker animation
	// the target is to make it as smooooooooooooooooth
	// as possible
	//
	//


	const conf = {
	  threshold: 8, // will run for the first 8 words
	  divider: 8 // the lower the slower the acceleration
	};

	function airway(time=0, session=0){
	  if (session > conf.threshold) return time
	  return (time*(conf.threshold - session))/conf.divider + time
	}

	function range(start, stop, step) {
	    var a = [start], b = start;
	    while (b < stop) {
	        a.push(b += step || 1);
	    }
	    return a;
	}

	function isClickWithin(click, el){
	    el = j(el);
	    let left = el.rect().x;
	    let top = el.rect().y;
	    let width = el.rect().width;
	    let height = el.rect().height;

	    console.log(click, el.offset());
	   
	    let _x =  left < click.x && left + width > click.x;
	    let _y =  top < click.y && top + height > click.y;
	  
	    return _x && _y
	  }

	class PragmaLector extends N {

	  constructor(){
	    super(arguments);
	  }

	  get lector(){
	    return this
	  }

	  get mark(){
	    return this._mark
	  }

	  set mark(m){
	    this.adopt(m);
	    this._mark = m;
	  }

	  get settings(){
	    return this._settings
	  }
	  set settings(s){
	    this.adopt(s);
	    this._settings = s;
	  }

	  get isReading(){
	    return this.w.isReading
	  }

	  get currentWord(){
	    return this.w.currentWord
	  }
	  get currentParent(){
	    return this.currentWord.parent
	  }

	  connectTo(w){
	    this.w = w;
	    this.add(w);

	    return this
	  }

	  removeWord(key){
	    this.w.remove(key);
	  }

	  addWord(w, setIndex=false){
	    w.value = w.value ?? 0;
	    this.w.add(w);
	    //w.currentWord.summon()
	    // w.do(_ => {
	    //   if (!w.dv) return 
	    //   console.log("W VALUE", w.value,w.dv)
	    //   // this.connectTo(this.w.next())
	    // })
	    // this.connect()
	    return this
	  }

	  toggle(){
	    if (this.isReading) return this.pause()
	    return this.read()
	  }

	  read(){
	    E.log("::LECTOR reading", this);
	    if (!this.w.hasKids) return console.error('nothing to read')
	    this.w.read(true);
	  }

	  summonTo(n){
	    this.currentParent.value += n;
	    this.currentWord.summon();
	  }

	  goToNext(){ this.summonTo(+1); }
	  goToPre(){ this.summonTo(-1); }

	  pause(){
	    this.w.pause();
	  }

	  setFont(font){
	    this.w.css(`font-family ${font}`);
	  }

	}

	class PragmaWord extends N {

	  constructor(k){
	      super(k);
	      this.do(function(){
	        if (this.hasKids && this.parent){
	          // if (this.childMap.has(this.value)){
	          // let excess = this.childMap.has(this.value) ? 0 : (this.value>0 ? 1 : -1)
	          
	          this.parent.value = this.key; 
	          // + excess
	          // if (excess){
	          //   console.log("EXCESSSS", excess)
	          //   console.log(this.next)
	          //   if (this.isReading){
	          //     this.pause().then(_ => {
	          //       this.parent.read()
	          //     })
	          //   }
	          // }
	         
	        }
	      });
	  }
	  destroy(){
	    this.childMap = null;
	    return null
	  }

	  get lector(){
	    if (this.parent) return this.parent.lector
	    E.throwSoft('could not find lector for');
	  }

	  get txt(){
	    return this.text
	  }

	  get index(){
	    return parseInt(this.key)
	  }

	  get mark(){
	    if (this.parent) return this.parent.mark
	    return null
	  }

	  set mark(m){
	    if (this.parent) this.parent.mark = m;
	    return null
	  }

	  get isReading(){
	    return this.currentPromise != null
	  }

	  get currentWord(){
	    if (!this.hasKids) return this
	    // console.log(this.value)
	    // console.log(this.childMap)
	    // console.log(this.element, this.value, this.childMap, this.get(this.value))
	    let subW = this.get(this.value);
	    if (!subW) return E.throwSoft(`Could not find current Word of ${this.key}`)
	    return subW.currentWord
	  }

	  getFromBottom(n){
	    // get items from last
	    return this.get(this.kidsum-n)
	  }
	  sibling(n){
	    if (!this.parent) return null
	    let sib = this.parent.get(this.index+n);

	    // [1, 2, 3, 4, 5]
	    // [1, 2, 3, 4, 5]

	    if (!sib){
	      if (typeof this.parent.sibling !== 'function') return null

	      if (n < 0) return this.parent.sibling(-1).getFromBottom(n)
	      return this.parent.sibling(1)?.get(n)
	      // this.parent.sibling(-1).get(this.parent.sibling(-1).)
	      // this.parent.sibling(n > 0 ? 1 : -1).get(n)
	    }

	    return sib

	    // return this.parent ? this.parent.get(this.index + n) : null
	  }

	  get next() {
	    return this.sibling(1)
	  }
	  
	  get pre() {
	    return this.sibling(-1)
	  }

	  isInTheSameLine(n) {
	    return this.sibling(n) != null && ((this.sibling(n).top - this.top) ** 2 < 10)
	  }
	  get isFirstInLine() {
	    return !this.isInTheSameLine(-1)
	  }
	  get isLastInLine() {
	    return !this.isInTheSameLine(1)
	  }
	  time(wpm = 250) {
	    return charsMsAt(wpm) * wordValue(this, generateDifficultyIndex(this))
	  }
	  pause(){
	    return new PinkyPromise( resolve => {
	      if (this.currentPromise){
	        this.currentPromise.catch((e)=>{
	          //console.log("broke read chain")
	          this.mark.pause().catch(e => {
	            // this will trigger if mark is already pausing and not done yet
	            console.warn("prevent pause event from bubbling. Chill on the keyboard bro", e);
	          }).then(() => {
	            this.currentPromise = null;
	            resolve("done pausing");
	            console.log("- - - - - PAUSED - - - - - - - -");
	          });
	        });
	        this.currentPromise.cancel("pause");
	      } else { resolve("already paused"); }
	    })
	  }

	  set currentPromise(p){
	    if (this.parent) return this.parent.currentPromise = p
	    this.currentPromiseVal = new PinkyPromise((resolve, reject) => {
	      p.catch((e) => {
	        console.warn(e);
	        // this.currentPromiseVal = null
	        // reject(e)
	      }).then(() => {
	        // this.currentPromiseVal = null
	        resolve();
	        this.currentPromiseVal = null;
	      });
	    });
	  }

	  get currentPromise() {
	    return this.parent ? this.parent.currentPromise : this.currentPromiseVal
	  }

	  promiseRead(startingToRead){
	    this.currentPromise = new PinkyPromise((resolve, reject) => {
	          // this.mark = "MARK V5 " + this.text() + this.key
	          // console.log(this.mark)
	          // console.log(this.text())
	          console.time(this.text);
	         
	          function launchMark(){
	            let time = startingToRead ? 500 : null;
	            this.mark.guide(this, time).then(() => {
	              console.timeEnd(this.text);
	              this.parent.value = this.index + 1;
	              resolve(` read [ ${this.text} ] `);
	            }).catch((e) => {
	              console.warn('rejected promise read', e);
	              reject(e);
	            });
	          }
	      

	          let self = this;
	          if (startingToRead){
	            new Promise(resolve => {
	              resolve();
	            }).then(data => {
	              launchMark.bind(self)();
	            });
	          } else {
	            launchMark.bind(self)();
	          }
	      });
	    // console.log(this.mark)
	    return this.currentPromise
	  }

	  read(source=false){
	    if (this.currentPromise) return new Promise((resolve, reject) => {
	      resolve('already reading');
	    })

	    if (this.hasKids){
	      // recursive reading 
	      if (this.currentWord) return this.currentWord.read(source)
	      this.next.value = 0;
	      return this.next.read()
	    } 

	    this.promiseRead(source);
	    // console.log(this)
	    return new PinkyPromise(resolve => {
	      this.currentPromise.then(() => {
	       resolve();
	       this.currentPromise = null;
	       return this.parent.read()
	      }).catch(e => resolve('pause'));
	    })
	  }

	  summon(silent=false) {
	    if (this.hasKids) return false
	    console.log("SUMMONING", this);
	    return this.parent.pause().catch(() => console.log('no need to pause')).then(() => {
	      this.mark.mark(this, 50, false);
	      if (!silent) this.parent.value = this.index;
	    })
	  }
	}

	const reset = `border 0
               border-radius 3px
               z-index 10
               opacity 1
               mix-blend-mode darken;`;


	const modes = {
	  'hotbox': bg => `background ${bg}`,

	  'underneath': bg => ` background transparent
                        border-bottom 3px solid ${bg}
                        border-radius 4px`,

	  'faded': bg => `
      background: rgb(255,255,255);
      background: -moz-linear-gradient(90deg, rgba(255,255,255,0) 0%, ${ bg } 25%, ${ bg } 75%, rgba(255,255,255,0) 100%);
      background: -webkit-linear-gradient(90deg, rgba(255,255,255,0) 0%, ${ bg } 25%, ${ bg } 75%, rgba(255,255,255,0) 100%);
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, ${ bg } 25%, ${ bg } 75%, rgba(255,255,255,0) 100%);
    `
	};

	function grabMode(mode, bg) {
	  return reset + modes[mode](bg)
	}

	const mode_ify = (mark, mode=mark._mode, bg=mark._color) => {
	  mode = (mode || 'hotbox').toString().toLowerCase();
	  let css = grabMode(mode, bg);
	  if (mark) mark.css(css);
	  return css
	};

	// mark is responsible for marking words in the screen

	const defaultStyles = `
  position absolute
  outline solid 0px red
  background-color #ffdf6c
  width 10px
  height 20px
  z-index 10
  opacity 1
  mix-blend-mode darken
  border-radius 3px
`;

	class PragmaMark extends N {
	  constructor() {
	    super('marker');

	    this.element = j("marker");
	    this.appendTo('body');
	    this.hide();
	    this.css(defaultStyles);

	    this.currentlyMarking = null;
	    window.addEventListener('resize', () => {
	      this.mark(this.last_marked, 0);
	    });

	    this.runningFor = 0;
	    this.pausing = false;

	    //this.idle = new Idle(8000)
	      //.onAfk(()=> {
	        //util.log('user is afk')
	        //this.shout()
	      //})
	      //.onActive(() => {
	        //util.log('user is back')
	        //this.shutUp()
	      //})
	  }
	  hide(){
	    if (this._hidden) return
	    this._hidden = true;
	    this.element.hide();
	  }
	  show(){
	    if (!this._hidden) return
	    this._hidden = false;
	    this.element.show();
	  }

	  set last_marked(n){
	    this.value = n;
	  }

	  get last_marked(){
	    return this.value
	  }

	  get settings() {
	    return this.parent ? this.parent.settings : console.error('mark has no settings attached')
	  }

	  get cw() {
	    return this._fovea * 30
	  }
	  
	  get wpm() { return this._wpm || 260 }
	  
	  setMode(mode){
	    this._mode = mode;
	    mode_ify(this);
	  }

	  setWpm(wpm){
	    this._wpm = wpm;
	  }

	  setColor(hex){
	    this._color = hex;
	    //this.css(`background-color ${hex}`)
	    mode_ify(this);
	  }

	  setFovea(val){
	    this._fovea = val;
	    this.css(`width ${this.cw}px`);
	  }

	  pause() {
	    return new Promise((resolve, reject) => {
	      if (this.pausing) return reject("already pausing")

	      this.pausing = true;

	      if (this.currentlyMarking && this.current_anime && this.last_marked) {
	        //console.log(this.current_anime.seek(1))
	        let temp = this.last_marked;
	        console.log('mark was running for', this.runningFor);
	        this.runningFor = 0;
	        //console.table(temp)
	        this.current_anime.complete();
	        this.current_anime.remove('marker');
	        //this.current_anime = null
	        this.mark(temp, 80, false).then(() => {
	          resolve("paused");
	        }).catch(e => {
	          reject("could not mark");
	        }).then(c => {
	          this.pausing = false;
	        });
	      }
	    })
	  }

	  moveTo(blueprint, duration, complete = (() => {})) {
	    console.log('moving to', blueprint);
	    this.show();
	    //this.shutUp() // clear any ui elements that direct attention to mark
	    if (this.currentlyMarking) return new Promise((resolve, reject) => resolve());
	    return new Promise((resolve, reject) => {
	      this.currentlyMarking = blueprint;
	      this.current_anime = anime({
	        targets: this.element,
	        left: blueprint.left,
	        top: blueprint.top,
	        height: blueprint.height,
	        width: blueprint.width,
	        easing: blueprint.ease || 'easeInOutExpo',
	        duration: duration,
	        complete: (anim) => {
	          this.currentlyMarking = null;
	          complete();
	          resolve();
	        }
	      });
	      // console.log(blueprint)
	      // console.log(this.current_anime)
	    })
	  }


	  mark(word, time = 200, fit = false, ease = "easeInOutExpo") {
	    //console.log("marking", word)
	    if (!(word instanceof N)) return new Promise((r) => { console.warn("cannot mark"); r("error"); })
	    let w = fit ? word.width + 5 : this.cw;
	    //this.setWidth(w)
	    return this.moveTo({
	        top: word.top,
	        left: word.x(w),
	        height: word.height,
	        width: w,
	        ease: ease
	      }, time, () => {
	        //console.log(`FROM MARK -> marked ${word.text}`)
	        this.last_marked = word;
	        // word.parent.value = word.index
	      })
	  }

	  guide(word, time) {
	    if (!(word instanceof N)) return new Promise((resolve, reject) => { console.warn("cannot guide thru"); reject("error"); })
	    return new PinkyPromise((resolve, reject) => {
	      let first_ease = word.isFirstInLine ? "easeInOutExpo" : "linear";
	      return this.moveTo({
	        top: word.top,
	        left: word.x(this.width) - word.width / 2,
	        height: word.height,
	        width: this.cw,
	        ease: first_ease
	      }, time || this.calcDuration(word, 1))
	        .then(() => {
	          this.last_marked = word;
	          this.runningFor += 1;
	          this.mark(word, this.calcDuration(word, 2), false, "linear").then(() => {
	            resolve();
	          });
	        })
	    })
	  }

	  calcDuration(word, dw=1){

	    /*  @dw - either 1 or 2
	      * 1. yee|t th|e green fox
	      * 2. yeet |the| green fox
	      * 1. yeet th|e gr|een fox
	      *
	      * The marking of "the"(and every word) happens in 2 instances. First mark
	      * will transition from "yeet" (1) and then in will mark "the", and immedietly afterwards
	      * it will transition from "the" to "green" (1) etc...
	      *
	      * */

	    if (!(word instanceof N)) return this.throw(`Could not calculate marking duration for [${word}] since it does not appear to be a Pragma Object`)
	    if (dw!=1 && dw!=2) return this.throw(`Could not calculate duration for ${word.text} since dw was not 1 or 2`)
	    if (word.isFirstInLine) return 500 // mark has to change line
	    if (!this.last_marked) return 0 // failsafe

	    const before_weight = .4;
	    const weight = dw==1 ? before_weight : 1 - before_weight;

	    let w = dw==1 ? this.last_marked : word;
	    //const filters = [(d) => { return d*weight }]

	    let duration = w.time(this.wpm);
	    const filters = [(d) => { return d*weight }, airway];


	    filters.forEach(f => {
	      //console.log(f, duration, this.runningFor)
	      //console.log(duration, f(duration, this.runningFor))
	       duration = f(duration, this.runningFor);
	    });

	    return duration
	    //return airway(duration)*weight// TODO make this a chain of callbacks
	  }
	}

	function paginator(pageTemplate, conf={}){
	  return new N()
	        .from(E.createTemplate({
	          // make this nicer
	          // defaultSet: pageTemplate,
	          pageTemplate: pageTemplate,
	          fetch: typeof conf.fetch === 'function' ? conf.fetch : _=>{ E.throwSoft('no fetch source specified'); },
	          onCreate: typeof conf.onCreate === 'function' ? conf.onCreate : p => E.log('created', p),
	          onFetch: conf.onFetch,

	          onPageAdd: null,
	          onPageRender: null,
	          //typeof conf.onPageRender === 'function' ? conf.onPageRender : function(page, i){ util.log('rendered', page, 'active?', page.active) },
	          onPageActive: typeof conf.onPageActive === 'function' ? conf.onPageActive: function(page, i){E.log('active', page); },
	          onPageInactive: typeof conf.onPageInactive === 'function' ? conf.onPageInactive : function(page, i) { E.log('inactive', page); },
	        }))

	        .run(function(){

	          let _ptemp = j(this.pageTemplate).hide();
	          this.pageTemplate = _ptemp.cloneNode(false);

	          this._clonePage = function() {
	            let page = j(this.pageTemplate.cloneNode(false)).show();
	            //if (this._lastAddedPage){
	              ////page.style.height = this._lastAddedPage.height
	              //page.css(`height ${this._lastAddedPage.height}px`)
	              //console.log('>>>>>>>>>>>>>>>>>>>>', this._lastAddedPage.height)
	            //}
	            this.adopt(page);
	            page.lec = this.parent;
	            E.createEventChains(page, 'fetch');
	            return page
	          };

	          this.create = function(val=this.value, action='append'){
	            // console.log('creating', val, action)
	            let cloned = this._clonePage();

	            new Promise( resolve => {

	              this.onCreate(cloned, val);

	              let f = this.fetch(val);

	              let onFetch = conf.onFetch ||
	                        function(page, fetched){
	                          page.html(fetched);
	                          resolve(page);
	                        };

	                        // on fetch in config or the default one
	              //
	              const onFetchAndResolve = (resolved) => {
	                let page = this.pages.get(val);
	                if (page){
	                  onFetch(page, resolved);
	                  resolve(page);
	                }
	              };

	              if (f instanceof Promise){
	                f.then(resolved => {
	                  onFetchAndResolve(resolved);
	                });
	              } else {
	                  onFetchAndResolve(f);
	              }

	              //if (f instanceof Promise){
	                //f.then(resolved => {
	                  //this.pages.get(val)
	                  //onFetch(cloned, resolved)
	                  //resolve(val)
	                //})
	              //} else {
	                //onFetch(cloned, f)
	                //resolve(val)
	              //}

	            }).then( page => {
	              //let page = this.pages.get(index)
	              //if (!page) return console.log('eeeeeeeeeee')
	              page.fetchChain.exec();
	              if (this.onPageRender) this.onPageRender(page, val);
	              //this._lastAddedPage = page
	            });

	            cloned[`${action}To`](this.parent.element);
	            this.addPage(cloned, val);
	          };

	          this.pages = new Map();

	          this.destroy = function(val){
	            //console.log('>> destroy', val)

	            let toDestroy = this.pages.get(val);

	            let destroy = _ => {
	              toDestroy = this.pages.get(val);
	              //toDestroy.destroy()
	              this.delPage(val);
	              toDestroy.destroy();
	            };

	            if (this.onPageDestroy){
	              let r = this.onPageDestroy(toDestroy, val);
	              if (r instanceof Promise) return r.then(destroy)
	            }

	            destroy();
	          };

	          this.addPage = function(page, key){
	            key = key === null ? this.pages.size : key;
	            if (this.onPageAdd) this.onPageAdd(page, key);
	            this.pages.set(key, page);
	          };

	          this.delPage = function(key){
	            return this.pages.delete(key)
	          };

	          this.activate = function(...pages){
	            pages.forEach(pageIndex => {
	              let page = this.pages.get(pageIndex);
	              if (!page) return
	              page.active = true;
	              this.onPageActive(page, pageIndex);  
	            });
	          };

	          this.inactivate = function(...pages){
	            pages.forEach(pageIndex => {
	              let page = this.pages.get(pageIndex);
	              if (!page) return
	              page.active = false;
	              this.onPageInactive(page, pageIndex);
	            });
	          };
	          
	      
	          this.export(
	            "pageTemplate",
	            "_clonePage",
	            "create",
	            'destroy',
	            "pages",
	            "addPage",
	            "delPage",
	            'activate',
	            'inactivate');
	        })
	}

	function infinityPaginator(streamer, pageTemplate, config={}){
	  let inf = W("infinity paginator")
	        .from(
	          paginator(pageTemplate, E.objDiff(
	            {
	              streamer: streamer,
	              fetch: streamer.fetch,
	              // on page render
	              // on page active

	              // on page inactive,
	              // on page add,
	              // on create,
	              // on fetch
	            }, config)
	          )
	        )
	        .setValue(0)
	        .run({
	          initialConfig(){

	            this._watching = true;
	            const conf = {
	              headspace: 10,
	              timeout: 5 
	            };

	            this.fill = function(){

	              this.fetching = true;
	              // console.log(">>> FILLING WITH", this.value)
	              let start = this.value >= conf.headspace ? this.value-conf.headspace : 0;
	              let pageRange = range(start, this.value+conf.headspace);
	              let pagesRendered = Array.from(this.pages.keys());

	              let pagesToRender = E.aryDiff(pageRange, pagesRendered);
	              let pagesToDelete = E.aryDiff(pagesRendered, pageRange);


	              let pagesToRenderAfter = pagesToRender.filter(i => i>this.value);
	              let pagesToRenderBefore = E.aryDiff(pagesToRender, pagesToRenderAfter);

	              // console.log(">> ALREADY RENDERED", pagesRendered)
	               console.log(">> DEL", pagesToDelete);
	               //console.log(">> ADD", pagesToRender) 
	               console.log(">> ADD AFTER", pagesToRenderAfter);
	               console.log(">> ADD BEFORE", pagesToRenderBefore);

	              // pararellize?
	              B(
	                _ => {
	                  for (let pageIndex of pagesToRenderAfter){
	                    this.create(pageIndex, 'append');
	                  }  
	                },
	                _ => {
	                  // pararellize?
	                  for (let pageIndex of pagesToRenderBefore.reverse()){
	                    this.create(pageIndex, 'prepend');
	                  }
	                },
	                _ => {
	                  // pararellize?
	                  for (let pageIndex of pagesToDelete){
	                    //this.inactivate(pageIndex)
	                    //this.pages.get(pageIndex).css("background:red")
	                    this.destroy(pageIndex);
	                  }
	                }
	              );
	              setTimeout(a => {
	                this.fetching = false;
	                console.log(this.pages);
	              }, conf.timeout);
	          };
	        }, scrollSetup(){
	          // this.goTo()
	          this.goTo = function (val, speed) {
	            `add-${this.value}`;
	            let paginator = this;

	            if (this.value != val) this.value = val;
	            let page = this.pages.get(val);

	            page.onRender(function () {
	              paginator._watching = false;
	              scrollTo(page, speed || 20).then(() => {
	                paginator._watching = true;
	              });
	            });
	          };

	          this.export('goTo');
	        },
	        findActivePages(){

	          function findCandidates(pages, scroll){
	            let bestIndex = null;
	            let best = 999999999999;
	            const middle = scroll + window.innerHeight/2;
	            // console.log(pages)
	            for (let [pageIndex, page] of pages){
	              let pageMiddle = page.top + page.height/2;
	              let closeness = Math.abs(pageMiddle - middle);
	              // console.log(page, pageIndex, closeness)
	              if (closeness <= best){
	                best = closeness;
	                bestIndex = pageIndex;
	              }
	            }

	            return bestIndex
	          }
	          
	          this.findActivePage = function(s, dp){
	            // dp is the rate of change of scroll
	            
	            // console.log(canditates)
	            //if (this.fetching) return
	            //
	            return new PinkyPromise(resolve => {
	              resolve(findCandidates(this.pages, s));
	              //let canditates
	              //util.bench(_ => canditates = findCandidates(this.pages, s))
	              ////resolve(canditates)
	              //setTimeout(_ => resolve(canditates), 5)
	            })
	          };

	          let searching = false;
	          let owe = false;
	          const doOnScroll= (pos, dp) => {
	            if (this.fetching || !this._watching) return 
	            if (searching) return owe = { pos: pos, dp: dp }

	            searching = true;
	            this.findActivePage(pos, dp).then(active => {
	              // console.log("ACTIVE>>", active, this.pages.get(active))
	              this.value = active;
	              searching = false;
	              if (owe){
	                // console.log('owe', owe)
	                doOnScroll(owe.pos, owe.dp);
	                owe = null;
	              }
	            });
	          };

	          onScrollEnd((pos, dp) => {
	            doOnScroll(pos, dp);
	          });
	          
	          // optimization for fast scroll
	          onScroll((pos, dp) => {
	            if (Math.abs(dp) > 40){
	              if (pos < 350) doOnScroll(pos, dp);
	            }
	          });
	          
	          //onScroll((pos, dp) => {
	            //if (pos < 300){
	              //doOnScroll(pos, dp)
	            //}
	          //})

	        }
	      })
	      .do(function(){
	        if (this.dv === 0) return
	        this.activate(this.value);
	        let preVal = this.value-(this.dv||1);
	        this.inactivate(preVal);

	        this.fill();
	      });

	  return inf
	}

	const defaults = {
	  onOptionCreate: function(self, option){
	    
	    self.contain(option);
	  },
	  optionTemplate: function(option){
	      return W(option)
	              .html(option)
	              .addClass('pragma-click')
	              .on('click').do(function(){
	                this.parent.value = this.key;
	              })
	  }
	};  


	//  const select = (conf) => _p()
	//     //.from(util.createTemplate())
	//     .run(function(){
	//       // this._options = []
	      
	//       let options = conf.options
	//       if (!options) return util.throwSoft('need to define options when creating a select template')

	//       let onOptionCreate = conf.onOptionCreate || defaults.onOptionCreate
	//       let optionTemplate = conf.optionTemplate || defaults.optionTemplate 

	//       if (options.constructor === Array){
	//         for (let el of options){
	//           onOptionCreate(this, optionTemplate(el))
	//         }
	//       }else{
	//         for (let [ key, val ] of Object.entries(options)){
	//           const pair = {[key]: val}
	//           onOptionCreate(this, optionTemplate(key, val), pair)
	//         }
	//       }

	//       this.onExport(function(pragma) {
	//         pragma.contain(...this.children)
	//         pragma.getOptions = function(){
	//           console.log(pragma.children)
	//           return pragma.children.filter(child => child._isOption)
	//         }
	//       })
	//       this.export('elementDOM', 'actionChain', 'exportChain', 'exports', '_options')
	//     })

	function select(conf){
	  // this._options = []
	  
	  let options = conf.options;
	  if (!options) return E.throwSoft('need to define options when creating a select template')

	  let onOptionCreate = conf.onOptionCreate || defaults.onOptionCreate;
	  let optionTemplate = conf.optionTemplate || defaults.optionTemplate; 

	  if (options.constructor === Array){
	    for (let el of options){
	      let option = optionTemplate(el);
	      option._isOption = true;

	      onOptionCreate(this, option);
	    }
	  }else {
	    for (let [ key, val ] of Object.entries(options)){
	      const pair = {[key]: val};
	      onOptionCreate(this, optionTemplate(key, val), pair);
	    }
	  }

	  // this.onExport(function(pragma) {
	    // pragma.contain(...this.children)
	    this.getOptions = function(){
	      console.log(this.children);
	      return this.children.filter(child => child._isOption)
	    };
	}

	var full = "@charset \"utf-8\";body{background-color:#161616}";
	var slider = "@charset \"utf-8\";.pragma-slider{user-select:none;cursor:grab}.pragma-slider:active{cursor:grabbing}.pragma-slider-bg{width:100%;height:5px;background:#6F6F6F;border-radius:15px}.pragma-slider-bar{height:100%;width:100%;background:#2B6CCE;position:relative;transition:all .05s ease;border-radius:15px}.pragma-slider-thumb{width:5px;height:18px;background:#2b6cce;transition:all .05s ease;position:absolute;right:0;top:50%;bottom:50%;margin:auto}";
	var main = "@charset \"utf-8\";@import url(https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300&display=swap);@import url(https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600;700&display=swap);.glass-block,.lector-mini-settings,.glass-block-border{background:rgba(35,35,35,0.55);backdrop-filter:blur(22px);-webkit-backdrop-filter:blur(22px);border-radius:5px;padding:20px 40px;color:whitesmoke}.glass-block-border{border:1px solid rgba(255,255,255,0.18)}.fixed-bottom-box,.lector-mini-settings,.lector-settings{position:fixed;bottom:20px}.lector-settings .pop-up-settings{background-color:#262626;border-radius:5px;left:-10px;transition:all .2s;padding:20px 5px 11px 5px;margin-left:10px;font-family:'Poppins','Inter','Arial Narrow',Arial,sans-serif;width:200px;margin-bottom:10px}.lector-settings .pragma-input-element{display:flex;flex-direction:column;width:fit-content;justify-content:center}.lector-settings .section{margin:20px 0}.lector-settings .section:hover>.pragma-label{opacity:1}.lector-settings .section .pragma-label{opacity:0;transition:all .2s ease;position:absolute;left:25%;margin-top:-55px;font-size:12px;color:whitesmoke}.lector-settings .section .pragma-label .option-title{color:rgba(199,199,199,0.92)}.lector-settings .selector,.lector-settings .selector-fovea,.lector-settings .selector-mode{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:center;align-items:center;align-content:stretch;width:fit-content;border-radius:4px;overflow:hidden}.lector-settings .selector-mode{padding:0;color:#262626;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:center;align-items:center;align-content:center;left:-7%;top:-70px}.lector-settings .selector-fovea{width:130px;height:45px;left:-9%;top:-70px;z-index:45678;margin-right:9px}.lector-settings .setting,.lector-settings .setting-wpm{width:100%;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-around;align-items:center;align-content:stretch}.lector-settings .setting .setting-icon,.lector-settings .setting-wpm .setting-icon{width:35px;height:35px}.lector-settings .setting-wpm{border-radius:5px;left:-10px;transition:all .2s;margin-left:20px;font-family:'Poppins','Inter','Arial Narrow',Arial,sans-serif;width:125px;position:relative}.lector-settings .setting-wpm .speed-adjust{width:10px}.lector-settings .setting-wpm .speed-adjust .adjusticon{width:10px;height:20px}.lector-settings .setting-wpm::before{content:\"\";position:absolute;height:30px;width:1px;background-color:#6F6F6F;left:-10px}.lector-settings .settings-bar{background-color:#262626;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-around;align-items:center;align-content:stretch;margin-left:10px;padding:5px 0 5px 10px;border-radius:5px;width:200px}.lector-settings .settings-bar-icon{width:25px;height:25px;position:relative;cursor:pointer}.lector-settings .wpm-icon{color:#fff;opacity:65%;font-size:28px;line-height:45px;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.lector-settings .wpm-icon:hover{opacity:100%;transition:all ease .1s}.lector-settings .color-indicator{width:25px;height:25px;background-color:#a8f19a;border-radius:50%}.lector-settings .mode-indicator{mix-blend-mode:normal !important;width:35px;height:25px}.lector-settings .modeOption{width:45px;height:25px;padding:10px 1px;display:flex;align-items:center;justify-content:center;background-color:transparent !important}.lector-settings .modeOption.inactive{background-color:transparent !important;opacity:.5 !important}.lector-settings .modeOption.active{opacity:1 !important}.lector-settings .modeOption.active::before{content:none}.lector-settings .modeOption .mini-pointer{height:70%;width:70%}.lector-settings .color-option{width:22px;height:22px;border-radius:25px;margin:5px 6px}.lector-settings .displayN{display:none}.lector-settings #underneath{margin:0 !important;position:relative}.lector-settings #mode{margin:35px 0;position:relative}.lector-settings #mode::before{width:70%;height:1px;background-color:#6F6F6F;content:\"\";position:absolute;top:-14px}.lector-settings #mode::after{width:70%;height:1px;background-color:#6F6F6F;content:\"\";position:absolute;bottom:-22px}.lector-settings #fovea{height:fit-content}.lector-settings #fovea .pragma-label{margin-top:-25px}.lector-settings #wpm .pragma-label{position:relative;left:0;margin:0;opacity:1;font-size:18px}.lector-mini-settings{right:-10px;padding-right:40px}.lector-mini-settings .section{margin-top:25px;margin-bottom:25px}.settings-input{display:flex;flex-direction:column;align-items:center}.pragma-input-text{font-family:'IBM Plex Mono',monospace;font-size:22px;border-style:none;outline:none;color:whitesmoke;border-radius:2px;background-color:transparent;text-align:center}.pragma-input-text:hover{background:#393939}.active-select-template{display:flex;flex-direction:row;flex-wrap:no wrap;justify-content:space-around;align-items:center;width:100%}.active-select-template .option{user-select:none;cursor:pointer}.active-select-template .active{opacity:1 !important;background-color:gray;position:relative;transform-style:preserve-3d}.active-select-template .active::after{height:32px;top:-6px;left:-10px}.active-select-template .active::before{width:30px;height:30px;top:-4px;border-radius:2px;left:-4px;background-color:#6F6F6F;position:absolute;border-radius:50%;content:\"\";z-index:-1;transform:translateZ(-1px);transition:ease all .2s;-webkit-transition:all 1s;-moz-transition:all 1s;animation:sheen 1s forwards}.active-select-template .inactive{background-color:#1a1a1a}.word-element{cursor:pointer;transition:all .05s ease}.word-element.hover-0{background-color:lightblue}.word-element.hover-1{background-color:rgba(184,184,184,0.249)}.word-element.hover-2{background-color:rgba(184,184,184,0.119)}";
	var css = {
		full: full,
		slider: slider,
		main: main
	};

	E.addStyles(css.slider);
	  
	function slider$1(conf={}){
	  
	  
	  this._n = function(){ 
	    let range = this.range || { min: 1, max: 100};
	    return 100/(range.max||100-range.min||1)
	  };


	  this.do(function(){
	    this.element.setData({ value: this.value});
	    this._setBarTo(this.value*this._n());
	  });

	  this._setBarTo = wp => {
	    this._bar.css(`width ${wp}%`);
	    this._thumb.offset();
	  };

	  this._clipValue = perc => {
	    let v = Math.round(perc/this._n());
	    if (this._lv !== v) {
	      this.value = v;
	    }
	    //console.log(this.value)
	  };
	  
	  this._input = j('div.').addClass('pragma-slider-bg');
	  this._bar = j('div.')
	    .addClass('pragma-slider-bar');
	  
	  this._thumb = j('div.pragma-slider-thumb');
	  this._bar.append(this._thumb);

	  this._input.append(this._bar);
	  

	  let onDown = function(){
	    this._clicked = true;
	  };

	  this._input.listenTo('mousedown', onDown);
	  this._thumb.listenTo('mousedown', onDown);
	  
	  document.addEventListener('mouseup', ()=> {
	    this._input._clicked = false;
	  });      
	  
	  let ticking = false;

	  document.addEventListener("mousemove", yx => {
	    if (this._input._clicked && !ticking) {
	      window.requestAnimationFrame(() => {
	        ticking = false;
	        let w = yx.pageX-this._input.offset().left;
	        let wp = Math.round(Math.min(w/this._input.rect().width, 1)*100);
	        this._clipValue(wp);
	      });
	      ticking = true;
	    }
	  });

	  this.adopt(this._input);
	  this.append(this._input);
	  this.element.addClass('pragma-slider');
	}

	function input(conf = {}) {
	    // return new Pragma()
	        // .from(util.createTemplate(conf))
	        // .run({
	            // makeChains(){
	                E.createChains(this, 'userInput');
	            // },
	            // makeInput () {
	                this.input = j(`<input type='text'></input>`)
	                    .addClass('pragma-input-text');

	                this.setValue = function(v){
	                    let newVal = this.valueSanitizer ? this.valueSanitizer(v) : v;
	                    if (newVal === this._lv) return 

	                    this.value = newVal;

	                    if (this.value != newVal){
	                        this.updateFront();
	                    }
	                    return this
	                };

	                this.input.listenTo('focus', function(){
	                    this.parent._listenToEsc = document.addEventListener('keydown', k => {
	                        if (k.key === 'Enter'){
	                            this.blur();
	                        }
	                    });
	                });
	                
	                this.input.listenTo('focusout', function(){
	                    this.parent.setValue(this.value);
	                    this.parent.userInputChain.exec(this.parent.value);
	                    document.removeEventListener('keydown', this.parent._listenToEsc);
	                });


	                // this.onExport(pragma => {
	                    // pragma.adopt(this.input)
	                    this.adopt(this.input);
	                    this.append(this.input);
	                // })
	            // },
	        
	            this.setMonitorTemplate = function(n){
	                this._monitorTemplate = n;
	                return this
	            };
	            // extend(){
	                this.updateFront = function(val=this.value){
	                    this.input.value = this._monitorTemplate ? this._monitorTemplate(val) : val;
	                    this.input.placeholder = val;
	                };
	            // }
	        // })
	        this.do(function(){
	            this.updateFront(this.value);
	        });

	        // .run(function(){
	            this.setInputAttrs = function(attrs){
	                for (let [key, val] of Object.entries(attrs)){
	                    this.input.attr(key, val);
	                }
	                return this
	            };

	            this.setValueSanitizer = function(cb){
	                this.valueSanitizer = cb;
	                return this
	            };
	        //   })
	}

	function withLabel(conf = {}) {
	    this.setLabel = function(html){
	        this._label.html(html);
	        return this
	    };
	    
	    this._label = j('div.pragma-label', conf.label);
	    this.append(this._label);    
	}

	function _createIdler(timeout, afk, active) {
	    let _idler = new Idle(timeout)
	      .onAfk(()=> {
	        console.log('user is afk');
	        if (afk) afk();
	        // this.shout()
	      })
	      .onActive(() => {
	        console.log('user is back');
	        if (active) active();
	        // this.shutUp()
	    });
	    return _idler
	}

	function idler(){
	    E.createChains(this, 'idle', 'active');

	    this.setIdleTime = function(time=5000){
	        this._idler = _createIdler(time, () => {
	            this.idleChain.exec();
	        }, () => {
	            this.activeChain.exec();
	        });
	        return this
	    };
	    
	    this.extend('onIdle', function(){
	        this._onIdle(...arguments);
	        return this
	    });

	    this.extend('onActive', function(){
	        this._onActive(...arguments);
	        return this
	    });
	}

	class Scaler extends N {
	    constructor(target){
	        super();
	        this.target = target;
	        this.target.css(`transition transform .07s ease`);

	        this.value = 100;
	        this.do(function(){
	            this.scaleTo(this.value);
	        });

	        this.setRange(10, 400);
	    }
	    
	    setTarget(n) { this.target = n; return this }
	    
	    set scaleStep(n){
	        this._scaleStep = n;
	    }

	    get scaleStep(){
	        return this._scaleStep || 5
	    }

	    scaleUp(){
	        this.value+= this.scaleStep;
	    }
	    
	    scaleDown(){
	        this.value-= this.scaleStep;
	    }
	    
	    scaleTo(to){
	        this.target.css(`transform scale(${to/100})`);
	    }
	}

	//scaler(element){
	    //this.target = element

	    //this
	//}

	const colorsHumanFriendly = {
	    "#a8f19a": 'bez', 
	    "#eddd6e": 'roz', 
	    "#edd1b0": 'mua', 
	    "#96adfc": 'fua'
	};
	const colors = Object.keys(colorsHumanFriendly);
	const fonts = ["Helvetica", "Open Sans", "Space Mono"];
	const modes$1 = ["HotBox", "Underneath", "Faded"];

	var shc = {
	  wpmPlus: ['+', '='],
	  wpmMinus: ['-'],

	  pageNext: ']',
	  pagePre: '[',

	  scaleUp: 'mod+=',
	  scaleDown: 'mod+-'
	};

	var icons = {
		"speed-increase": "<svg width=\"17\" height=\"9\" viewBox=\"0 0 17 9\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8.5 0L17 7.89474L15.81 9L8.5 2.21053L1.19 9L0 7.89474L8.5 0Z\" fill=\"white\"/>\n</svg>\n",
		"speed-decrease": "<svg width=\"17\" height=\"9\" viewBox=\"0 0 17 9\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8.5 9L2.13343e-07 1.10526L1.19 -1.40286e-06L8.5 6.78947L15.81 -1.24738e-07L17 1.10526L8.5 9Z\" fill=\"white\"/>\n</svg>\n",
		"mode-icon": "<svg width=\"28\" height=\"28\" viewBox=\"0 0 28 28\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M22.75 3.5H5.25C4.78603 3.50053 4.34122 3.68508 4.01315 4.01315C3.68508 4.34122 3.50053 4.78603 3.5 5.25V22.75C3.50053 23.214 3.68508 23.6588 4.01315 23.9868C4.34122 24.3149 4.78603 24.4995 5.25 24.5H22.75C23.214 24.4995 23.6588 24.3149 23.9868 23.9868C24.3149 23.6588 24.4995 23.214 24.5 22.75V5.25C24.4995 4.78603 24.3149 4.34122 23.9868 4.01315C23.6588 3.68508 23.214 3.50053 22.75 3.5ZM19.25 22.75V19.25H15.75V22.75H12.25V19.25H8.75V15.75H12.25V12.25H8.75V8.75H12.25V5.25H15.75V8.75H19.25V5.25H22.75V22.75H19.25Z\" fill=\"#909090\"/>\n<path d=\"M15.75 8.75H12.25V12.25H15.75V8.75Z\" fill=\"#909090\"/>\n<path d=\"M15.75 15.75H12.25V19.25H15.75V15.75Z\" fill=\"#909090\"/>\n<path d=\"M19.25 12.25H15.75V15.75H19.25V12.25Z\" fill=\"#909090\"/>\n</svg>\n",
		"speed-icon": "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M22.4979 15.7501C22.4969 13.7461 21.9163 11.7851 20.8261 10.1035L19.7422 11.1875C20.564 12.5675 20.9978 14.1439 20.9979 15.7501L22.4979 15.7501Z\" fill=\"#909090\"/>\n<path d=\"M21 7.8105L19.9394 6.75L13.5143 13.1752C13.057 12.8997 12.5338 12.7528 12 12.75C11.4067 12.75 10.8266 12.9259 10.3333 13.2556C9.83994 13.5852 9.45543 14.0538 9.22836 14.602C9.0013 15.1501 8.94189 15.7533 9.05765 16.3353C9.1734 16.9172 9.45912 17.4518 9.87868 17.8713C10.2982 18.2909 10.8328 18.5766 11.4147 18.6924C11.9967 18.8081 12.5999 18.7487 13.1481 18.5216C13.6962 18.2946 14.1648 17.9101 14.4944 17.4167C14.8241 16.9234 15 16.3433 15 15.75C14.9972 15.2162 14.8503 14.693 14.5748 14.2357L21 7.8105ZM12 17.25C11.7033 17.25 11.4133 17.162 11.1666 16.9972C10.92 16.8324 10.7277 16.5981 10.6142 16.324C10.5007 16.0499 10.4709 15.7483 10.5288 15.4574C10.5867 15.1664 10.7296 14.8991 10.9393 14.6893C11.1491 14.4796 11.4164 14.3367 11.7074 14.2788C11.9983 14.2209 12.2999 14.2506 12.574 14.3642C12.8481 14.4777 13.0824 14.67 13.2472 14.9166C13.412 15.1633 13.5 15.4533 13.5 15.75C13.4995 16.1477 13.3414 16.529 13.0602 16.8102C12.779 17.0914 12.3977 17.2495 12 17.25Z\" fill=\"#909090\"/>\n<path d=\"M12 6.75002C13.6061 6.75077 15.1822 7.18457 16.5625 8.00574L17.6527 6.91554C16.0679 5.89651 14.2378 5.32343 12.3548 5.2566C10.4719 5.18976 8.60573 5.63164 6.95268 6.53575C5.29964 7.43986 3.92082 8.77277 2.96128 10.3943C2.00174 12.0158 1.49695 13.8659 1.50001 15.75L3.00001 15.75C3.00273 13.3639 3.95182 11.0763 5.63906 9.38906C7.32629 7.70182 9.6139 6.75274 12 6.75002Z\" fill=\"#909090\"/>\n</svg>\n",
		"color-icon": "<svg width=\"22\" height=\"22\" viewBox=\"0 0 22 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M19.75 0.5L2.25 0.5C1.78605 0.500579 1.34127 0.685139 1.0132 1.0132C0.685139 1.34127 0.500579 1.78605 0.5 2.25L0.5 19.75C0.500579 20.214 0.685139 20.6587 1.0132 20.9868C1.34127 21.3149 1.78605 21.4994 2.25 21.5L19.75 21.5C20.214 21.4994 20.6587 21.3149 20.9868 20.9868C21.3149 20.6587 21.4994 20.214 21.5 19.75L21.5 2.25C21.4994 1.78605 21.3149 1.34127 20.9868 1.0132C20.6587 0.685139 20.214 0.500579 19.75 0.5ZM2.25 19.75L19.75 2.25L19.75 19.75L2.25 19.75Z\" fill=\"#919191\"/>\n</svg>\n",
		"fovea-icon": "<svg width=\"28\" height=\"28\" viewBox=\"0 0 28 28\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M26.249 14L19.249 21L18.0117 19.7628L23.7745 14L18.0117 8.23725L19.249 7L26.249 14Z\" fill=\"#909090\"/>\n<path d=\"M14 19.25C13.8851 19.2502 13.7713 19.2276 13.6651 19.1836C13.559 19.1396 13.4625 19.075 13.3814 18.9937L9.00641 14.6187C8.92512 14.5374 8.86064 14.441 8.81664 14.3349C8.77265 14.2287 8.75 14.1149 8.75 14C8.75 13.8851 8.77265 13.7714 8.81664 13.6652C8.86064 13.5591 8.92512 13.4626 9.00641 13.3814L13.3814 9.00641C13.4626 8.92512 13.5591 8.86064 13.6652 8.81664C13.7713 8.77265 13.8851 8.75 14 8.75C14.1149 8.75 14.2287 8.77265 14.3349 8.81664C14.441 8.86064 14.5374 8.92512 14.6187 9.00641L18.9937 13.3814C19.0749 13.4626 19.1394 13.5591 19.1834 13.6652C19.2274 13.7714 19.2501 13.8851 19.2501 14C19.2501 14.1149 19.2274 14.2287 19.1834 14.3349C19.1394 14.441 19.0749 14.5374 18.9937 14.6187L14.6187 18.9937C14.5375 19.075 14.4411 19.1396 14.3349 19.1836C14.2288 19.2276 14.115 19.2502 14 19.25ZM10.8624 14L14 17.1377L17.1377 14L14 10.8624L10.8624 14Z\" fill=\"#909090\"/>\n<path d=\"M1.75 14L8.75 7L9.98725 8.23725L4.2245 14L9.98725 19.7628L8.75 21L1.75 14Z\" fill=\"#909090\"/>\n</svg>\n",
		"settings-icon-white": "<svg width=\"28\" height=\"24\" viewBox=\"0 0 28 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M27.0474 3.86392H23.0869C22.6039 1.64217 20.672 0 18.3536 0C16.0353 0 14.1033 1.64217 13.6203 3.86392H0V5.79588H13.6203C14.1033 8.01763 16.0353 9.65979 18.3536 9.65979C20.672 9.65979 22.6039 8.01763 23.0869 5.79588H27.0474V3.86392ZM18.3536 7.72784C16.7114 7.72784 15.4557 6.47206 15.4557 4.8299C15.4557 3.18773 16.7114 1.93196 18.3536 1.93196C19.9958 1.93196 21.2516 3.18773 21.2516 4.8299C21.2516 6.47206 19.9958 7.72784 18.3536 7.72784Z\" fill=\"white\"/>\n<path d=\"M0 19.3193H3.96052C4.44351 21.5411 6.37547 23.1832 8.69382 23.1832C11.0122 23.1832 12.9441 21.5411 13.4271 19.3193H27.0474V17.3874H13.4271C12.9441 15.1656 11.0122 13.5234 8.69382 13.5234C6.37547 13.5234 4.44351 15.1656 3.96052 17.3874H0V19.3193ZM8.69382 15.4554C10.336 15.4554 11.5918 16.7112 11.5918 18.3533C11.5918 19.9955 10.336 21.2513 8.69382 21.2513C7.05165 21.2513 5.79588 19.9955 5.79588 18.3533C5.79588 16.7112 7.05165 15.4554 8.69382 15.4554Z\" fill=\"white\"/>\n</svg>\n"
	};

	function activate(self, key){
	  self.find(key).addClass('active')
	                .removeClass('inactive');
	}

	function deactivate(self, key){
	  self.find(key).removeClass('active')
	                .addClass('inactive');
	}

	function activeSelectTpl(conf){
	  select.bind(this)(E.objDiff({
	    onOptionCreate: (self, el) => {
	      self.contain(el);
	      el.addClass('option');
	      deactivate(self, el.key);
	    }
	  }, conf));

	  this.addClass('active-select-template')
	  .do(function(){
	    if (this.value === this._lv) return
	    activate(this, this.value);
	    if (this._lv) deactivate(this, this._lv);
	  });
	}

	// const activeSelectTpl = (conf={}) => _p()
	//   .from(select(util.objDiff({
	//     onOptionCreate: (self, el) => {
	//       self.contain(el)
	//       el.addClass('option')
	//       deactivate(self, el.key)
	//     }
	//   }, conf)))
	//   .addClass('active-select-template')
	//   .do(function(){
	//     if (this.value === this._lv) return
	//     activate(this, this.value)
	//     if (this._lv) deactivate(this, this._lv)
	//   })

	function lectorSettings(lector){


	  // let icons = new IconBuilder()
	  // icons.default.fill = "white"

	  //const tippyOption = {
	                        //theme: 'lector-settings',
	                        //arrow: false,
	                        //hideOnClick: false
	                      //}
	  //
	  // let foveaComp = Slider.value("markerfovea", 1, 10)
	  //     .bind(">", (comp) => { comp.value+=1 }, 'keyup')
	  //     .bind("<", (comp) => { comp.value-=1 }, 'keyup')
	  //     .html.class("slider")

	  const actions = {
	    changeColor(hex=this.value){
	      modeComp.update(hex);
	      foveaComp.update(hex);
	      j('body').findAll('[data-lector-marker-color]').forEach(e => {
	        e.css(`${e.getData("lectorMarkerColor")} ${hex}`);
	      });
	      lector.mark.setColor(hex);
	    },

	    changeFovea(fovea=this.value){
	      lector.mark.setFovea(fovea);
	    },

	    changeWpm(wpm=this.value){
	      lector.mark.setWpm(wpm); 
	    },

	    changeFont(font=this.value){
	      lector.setFont(font);
	    },

	    changeMode(mode=this.value){
	      lector.mark.setMode(mode);
	      j('body').findAll('[data-lector-marker-mode]').forEach(e => {
	        mode_ify(e, mode, lector.mark._color);
	        // e.css(`${e.getData("lectorMarkerColor")} ${hex}`)
	      });
	    },

	    changePage(page=this.value){
	      if (lector.paginator) lector.paginator.goTo(page); 
	    },

	    changeScale(scale=this.value){
	      if (lector.scaler) lector.scaler.scaleTo(scale);
	    }
	  };

	  let settings = W("settingsWrapper")
	                  .addClass("items-center", 'lector-settings')

	                  .run(function(){
	                    this.value = {};

	                    this._setVal = function(edit){
	                      this.value = E.objDiff(this.value, edit);
	                    };

	                    this.set = function(edit){
	                     this._setting = true; 
	                      for (let [key, val] of Object.entries(edit)){
	                        let child = this.find('!'+key);
	                        if (child) child.value = val;
	                      }
	                     this._setting = false;
	                    };
	                    
	                    this.get = function(key){
	                      return this.value[key] 
	                    };
	                  });
	                  //.do(function(){
	                    //console.log('set value', this.value)
	                  //})

	           
	  function popUpEditor(){
	    this.setPopupEditor = function(popup){
	      this._popupEditor = popup;
	      this._popupEditor.addClass(`displayN`);
	      return this
	    };

	    this.element.listenTo('click', click =>{
	      this._popped = click;
	      this._popupEditor.removeClass(`displayN`);
	    });

	    this.element.onRender(() => {
	      let self = this;
	      document.addEventListener('click', function _onClick(click){
	        console.log(click, self._popped);
	        if (self._popped === click){
	          // if click event was used to pop the menu, skip
	          return null
	        }
	        if (!isClickWithin(click, self._popupEditor)){
	          self._popupEditor.addClass(`displayN`);      
	        }
	      });
	    });
	  }


	  let modeIcon = W().as(j(icons['mode-icon']))
	                  .addClass(`setting-icon`);

	  W('monitor')
	                    .as(j('div.'))
	                    .addClass('mode-indicator')
	                    .setData({ 'lectorMarkerMode': 'true' });


	  let setMode = W('!mode')
	                  .run(function(){
	                    activeSelectTpl.bind(this)({
	                    options: modes$1,
	                    optionTemplate: option => W(option)
	                        .addClass(`modeOption`)
	                        .on('click').do(function(){
	                          this.parent.value = this.key;
	                        })
	                        .run(function(){
	                          this._miniPointer = j('div.mini-pointer#');
	                          this.append(this._miniPointer);
	                          this.update = function(bg){
	                            mode_ify(this._miniPointer, option, bg);
	                            this._miniPointer.css('mix-blend-mode normal');  
	                          };
	                        })
	                  });
	                })
	                  .run(function(){
	                    this.update = bg => {
	                      console.log('my options', this.getOptions());
	                      this.getOptions().forEach(option => option.update(bg));
	                      console.log(this.children);
	                    };
	                  })
	                  // .run(lecLabel)
	                  // .setLabelName('Pointer mode')
	                  .addClass('selector-mode')
	                  .do(actions.changeMode);

	  let modeComp = W().contain(modeIcon, setMode)
	                    .addClass(`setting`)
	                    .css(`position relative`)
	                    .run(function() {
	                      this.update = setMode.update;
	                    });

	  let foveaIcon = W().as(j(icons['fovea-icon']))
	                  .addClass(`setting-icon`);
	  W('monitor')
	                    .as(j('div.'))
	                    .addClass(`color-indicator`)
	                    .setData({ 'lectorMarkerColor': 'background' });                

	  let setFovea = W("!fovea")
	                .addClass( 'selector-fovea' )
	                .run(slider$1) // label
	                .setRange(2, 10)
	                .setValue(5)
	                .css(``)
	                .do(actions.changeFovea)
	                .run(function(){
	                  this.update = (bg) => {
	                    this._bar.css(``);
	                  };
	                });
	          
	  let foveaComp = W().contain(foveaIcon, setFovea)
	                .addClass(`setting`)
	                .css(`position relative`)
	                .run(function () {
	                  this.update = setFovea.update;
	                });


	    
	  let setColor = W('!color')
	                  .run(
	                    function(){
	                      activeSelectTpl.bind(this)({
	                      options: colors,
	                      optionTemplate: option => {
	                        return W(option)
	                                .css(`background-color ${option} `)
	                                .addClass(`color-option`)
	                                .on('click').do(function(){
	                                  this.parent.value = this.key;
	                                })
	                      }
	                    });
	                  })
	                  .addClass(`selector`)
	                  
	                  //.run(lecLabel)
	                  //.setLabelName('Pointer Color')
	                  //.setLabelTemplate(v => colorsHumanFriendly[v])
	                  .do(actions.changeColor);




	  let colorIcon = W()
	                  .as(j(icons['color-icon']))
	                  .css('width 25px; height 25px;')
	                  .addClass(`setting-icon`);

	  W('monitor')
	                    .as(j('div.'))
	                    .addClass(`color-indicator`)
	                    .setData({ 'lectorMarkerColor': 'background' });

	  let colorsComp = W().contain(colorIcon, setColor)
	                  .addClass(`setting`)
	                  .css(`position relative`);

	                  // .run(popUpEditor)
	                  //   .setPopupEditor(setColor)

	  
	  
	  let popUpSettings = W("popupsettings")
	                    .contain(
	                      //fontComp.setId('font'), 
	                      colorsComp.setId('color'), 
	                      modeComp.setId('mode'),
	                      foveaComp.setId('fovea'),)
	                    .addClass('pop-up-settings')
	                    .run(function(){
	                      this.show = function(){
	                        this.hidden = false;
	                        this.element.show();
	                      };
	                      this.hide = function(){
	                        this.hidden = true;
	                        this.element.hide();
	                      };
	                      this.toggle = function(){
	                        this.hidden ? this.show() : this.hide();
	                      };
	            
	                      this.show();
	                    })
	                    .bind("h", function() { this.toggle(); });



	  // let fontIcon = _p().as(_e(icons['fovea-icon']))

	  // let fontMonitor = _p('monitor')
	  //                   .addClass('font-indicator')

	  // let setFont = _p('!font')
	  //                 .run(function(){
	  //                   console.log(this.key)
	  //                 })
	  //                 .from(activeSelectTpl({
	  //                   options: fonts,
	  //                   optionTemplate: option => _p(option)
	  //                             .html("Aa")
	  //                             .css(`font-family ${option}`)
	  //                             .on('click').do(function(){
	  //                               this.parent.value = this.key
	  //                             })
	  //                 }))
	  //                 .css(`flex-direction row`)
	  //                 .addClass('section', `selector`)
	  //                 .do(actions.changeFont)
	                
	  // let fontComp = _p()
	  //                 .contain(fontIcon, fontMonitor, setFont)
	  //                 .run(popUpEditor)
	  //                   .setPopupEditor(setFont)
	  
	  let wpmIcon = W().as(j(icons['speed-icon']))
	                .css('width 25px; height 25px;')
	                .addClass(`setting-icon`);

	  let wpmIncreaseIcon = W().as(j(icons['speed-increase']))
	                      .addClass(`setting-wpm-adjusticon`)
	                      .on('click').do(_ => {
	                        setWpm.value += 10;
	                      });

	  let wpmDecreaseIcon = W().as(j(icons[`speed-decrease`]))
	                        .addClass(`setting-wpm-adjusticon`)
	                        .on('click').do(_ => {
	                          setWpm.value -= 10;
	                        });

	  let wpmAdjust = W('wpmAdjustPragma').contain(wpmIncreaseIcon,wpmDecreaseIcon)
	                  .addClass(`speed-adjust`);

	  let setWpm = W("!wpm")
	                  .run(input, withLabel)
	                  .addClass('settings-input')
	                  .setInputAttrs({
	                    maxlength: 4,
	                    size: 4
	                  })
	                  .setValueSanitizer(
	                    v => parseInt(v)
	                  )
	                  .setId('wpm')
	                  .setRange(40, 4200)
	                  .setValue(250)
	                  .bind(shc.wpmPlus, function(){ this.value+=10; })
	                  .bind(shc.wpmMinus, function(){ this.value-=10; })
	                  .do(actions.changeWpm);
	    
	  let wpmComp = W().contain(wpmIcon, setWpm, wpmAdjust)
	                .addClass(`setting-wpm`)
	                .run(function () {
	                  this.update = setWpm.update;
	                });


	  let settingsIcon = W().as(j(icons['settings-icon-white']))
	                    .addClass(`settings-bar-icon`)
	                    .run(popUpEditor)
	                    .setPopupEditor(popUpSettings);

	                    


	  let settingsBarComp = W().contain(settingsIcon, wpmComp)
	                        .addClass(`settings-bar`);
	                        
	  
	  let pageComp = W("!page")
	                  .run(input, withLabel)
	                  .setInputAttrs({
	                    maxlength: 4,
	                    size: 4
	                  })
	                  .addClass('settings-input', 'section')
	                  .setValueSanitizer(
	                    v => parseInt(v)
	                  )
	                  .setLabel('page')
	                  .run(function(){
	                    E.createChains(this, 'userEdit');

	                    this.editValue = function(val){
	                      this.value = val;  
	                      this.userEditChain.exec(this.value);
	                    };

	                    this.onUserEdit(actions.changePage);
	                  })
	                  // .do(actions.changePage
	                  .run(function(){
	                    this.onUserInput(val => {
	                      // console.log(val)
	                      this.editValue(val);
	                    });
	                  })
	                  .setValue(1)
	                  .bind(shc.pageNext, function(){
	                    this.editValue(this.value+1);
	                  }, 'keyup')
	                  .bind(shc.pagePre, function(){
	                    this.editValue(this.value-1);
	                  }, 'keyup');
	                  
	                  //.do(actions.changePage)

	  //const comps = [colorsComp, fontComp, foveaComp, modeComp]

	  //comps.forEach(comp => {
	    //comp.do(function(){
	      //console.log(this.key, this.value)
	    //})
	  //})

	  let scaleComp = W("!scale")
	                  .run(input, withLabel)
	                  .setInputAttrs({
	                    maxlength: 3,
	                    size: 4
	                  })
	                  .addClass('settings-input', 'section')
	                  .setValueSanitizer(
	                    v => parseInt(v)
	                  )
	                  .setLabel('scale')
	                  .run(function(){
	                    E.createChains(this, 'userEdit');

	                    this.editValue = function(val){
	                      this.value = val;
	                      this.userEditChain.exec(this.value);
	                    };

	                    this.onUserEdit(actions.changeScale);
	                  })
	                  // .do(actions.changePage
	                  .run(function(){
	                     this.onUserInput(val => {
	                       console.log(val);
	                       this.editValue(val);
	                     });
	                  })
	                  .setValue(100)
	                  .bind(shc.scaleUp, function(){
	                    this.editValue(this.value+5);
	                    return false
	                  })
	                  .bind(shc.scaleDown, function(){
	                    this.editValue(this.value-5);
	                    return false
	                  });                  

	                    
	  let miniSettings = W('mini-settings')
	    .addClass('lector-mini-settings')
	    .contain(scaleComp, pageComp)
	    .pragmatize();
	  
	  
	// 
	// pageComp
	  settings.contain(popUpSettings, settingsBarComp);
	  settings.adopt(miniSettings);
	  
	  const listenTo_ = p => p.key && p.key.indexOf('!') === 0;

	   let fader = W('fader')
	     .run(idler, function(){
	       this.elements = [];
	       this.include =function(){
	         this.elements = this.elements.concat(Array.from(arguments));
	         return this
	       };
	     })
	     .setIdleTime(3000) // TODO CHANGE BACK TO 3000
	     .include(settings, miniSettings)
	     .onIdle(function(){
	       this.elements.forEach(element => {
	         element.css('opacity 0');
	       });
	       // this.css('opacity 0')
	     })
	     .onActive(function(){
	       this.elements.forEach(element => element.css('opacity 1'));
	     });
	  
	   settings.fader = fader;

	  settings.allChildren.forEach(child => {
	    if (listenTo_(child)){
	      child.do(_ => settings._setVal({[child.key.substring(1)]: child.value}));
	    }
	  });
	  
	  settings.do(function(){
	    if (!this._setting){
	      console.log('syncing',this.value);
	    }
	  });

	  //setTimeout(() => {
	    //// simulate websocket event
	    settings.set({
	      'color': colors[1],
	      'font': fonts[1],
	      'mode': modes$1[2],
	      'fovea': 4,
	      'wpm': 420
	    });
	   
	  //}, 1200)
	  
	  return settings.pragmatize()
	}

	// TODO add more default options
	const default_options = {
	  wfy: true,
	  pragmatizeOnCreate: true,
	  experimental: false,
	  settings: false,
	  defaultsStyles: true
	};

	const Mark = (lec) => {
	  let mark = new PragmaMark();

	  function logger(w){
	  }

	  // auto scroll feature
	  // TODO put somewhere else
	  let scrollingIntoView = false;
	  let usersLastScroll = 0;

	  function userIsScrolling(){
	    return usersLastScroll - Date.now() > -10
	  }

	  function autoScroll(w){
	    //return
	    if (userIsScrolling() || isOnScreen(mark.element) || scrollingIntoView) return false
	    // else we're out of view

	    scrollingIntoView = true;

	    let cbs = []; // these will be the callbacks that are gonna run when the scroll is done
	    // TODO  make a class Chain that does this.
	    // Chain.add(cb), Chain.do() to execute and shit
	    if (lec.isReading){
	      lec.pause();
	      cbs.push(() => {
	        lec.read();
	      });
	    }

	    cbs.push(()=>{
	      //console.warn("suck my diiiiiiiiiick")
	    });

	    //console.warn("mark is out of screen")
	    //console.log('lec reading:', lec.isReading)

	    scrollTo(mark).then(() => {
	      cbs.forEach(cb => cb());
	      scrollingIntoView = false;
	    });
	  }

	  const threshold = 40; // how fast should you scroll to pause the pointer
	  let lastScroll = 0;
	  onScroll(s => {
	    usersLastScroll = !scrollingIntoView ? Date.now() : usersLastScroll;
	    // console.log('user is scrolling', userIsScrolling())

	    if (userIsScrolling() && lec.isReading){
	      let dscroll = Math.abs(lastScroll-s);
	      lastScroll = s;
	      if (dscroll>threshold){
	        // console.log('ds=', dscroll)
	        // TODO prevent from calling pause to many times
	        // on too fast scroll, pause mark
	        lec.pause();
	      }
	    }
	  });

	  mark.on('mouseover', function(){
	    console.log(this, 'hover');
	  });

	  mark.do(logger, autoScroll);
	  return mark
	};

	//console.log(_e("#div").deepQueryAll.toString())
	const Word = (element, i, options={ shallow: false }) => {

	  let w = new PragmaWord(i)
	          .as(element)
	          .setValue(0);


	    function hoverCluster(epicenter){

	      //hover(epicenter, 0)
	      function spreadRight(element, cap=1, iter=0){
	        hover(element, iter);
	        if (element.isInTheSameLine(1) && cap > iter){
	          let next = element.next;
	          spreadRight(next, cap, iter+1);
	        }
	      }

	      function spreadLeft(element, cap=1, iter=0){
	        if (iter>0) hover(element, iter);
	        if (element.isInTheSameLine(-1) && cap > iter){
	          let pre = element.pre;
	          spreadLeft(pre, cap, iter+1);
	        }
	      }

	      spreadRight(epicenter, 2);
	      spreadLeft(epicenter, 2);

	      function hover(element, depth){
	        element.toggleClass(`hover-${depth}`);
	      }
	    }

	    let thisw = w.element.findAll('w');
	    // console.timeLog('deepQuery')
	    if (i && thisw.length === 0) {
	      w.addClass('word-element');
	      
	      w.addListeners({
	        "click": function(e, comp){
	          this.summon();
	        },
	        "mouseover": function(){
	          hoverCluster(this);
	        },
	        "mouseout": function(){
	          hoverCluster(this);
	        }
	      });
	    }

	    if (!options.shallow){
	      thisw.forEach((el, i) => {
	        let ww = Word(el, i, { shallow: true });
	        w.add(ww);
	      });
	    }
	    
	  return w
	};

	const Reader = (l, options=default_options) => {
	  l = j(l);
	  if (options.wfy) wfy(l);
	  let w = Word(l);

	  let lec = new PragmaLector("lector")
	              .as(l)
	              .setValue(0)
	              .connectTo(w);
	  
	  lec.mark = Mark(lec);
	  if (options.settings) lec.settings = lectorSettings(lec);


	  function bindKeys(){
	    lec.bind("right", _ => lec.goToNext());
	    lec.bind("left", _ => lec.goToPre());

	    lec.bind("space", _ => false, 'keydown'); // dont trigger the dumb fucken scroll thing
	    lec.bind("space", function(){
	      this.toggle();
	      return false
	    }, 'keyup');

	  }

	  function experiment(){
	    if (globalThis.pragmaSpace.mousetrapIntegration){
	        bindKeys();
	    }
	  }

	  if (options.pragmatizeOnCreate) lec.pragmatize();
	  if (options.experimental) experiment();

	  return lec
	};

	function _needWrapper(op){
	    return op.stream || op.paginate
	}


	function _streamer(sf){
	  return W('streamer')
	          .setValue(0)
	          .run(function(){
	            this.fetch = sf;
	            this.getContent = function(){
	              return this.fetch(this.value)
	            };
	          })

	}

	const Lector = (l, options=default_options) => {
	  if (!_needWrapper(options)) return Reader(l, options)

	  E.log("configuration appears to be a bit more complicated");

	  if (options.defaultStyles){
	    E.addStyles(css.main);
	  }

	  if (options.fullStyles){
	    E.addStyles(css.full);
	  }

	  if (!options.experimental) return console.log('EXPERIMENTAL FEATURES TURNED OFF')
	  let lector;

	  if (options.stream &&
	      options.paginate &&
	      options.paginate.from === 'stream' &&
	      options.paginate.as === 'infiniteScroll'){

	    E.log('setting up streamer service');

	    let streamer = _streamer(options.stream);
	    let paginator = infinityPaginator(streamer, l, options.paginate.config || {});

	    // let reader = _p()
	    //               .as(_e(l).parentElement)

	    // console.log('creating new lector')
	    // console.log(l)
	    // console.log(_e(l).parentElement)
	    // let options = util.objDiff({ skip: true })
	    lector = Reader(j(l).parentElement, options)
	                  .adopt(paginator, streamer);

	    lector.paginator = paginator;
	    if (lector.settings){
	      console.log("lector has settings! connecting paginator's value to pagecomp");
	      let pageComp = lector.settings.find('!page');
	      pageComp.wireTo(lector.paginator);
	    }
	    console.log('paginator', paginator);

	    paginator.fill();
	    // return lector
	  }

	  
	  if (options.scaler){
	    // let _scaler = _p().run(_ext.scaler)
	    let _scaler = new Scaler(lector.element);
	    
	    // _scaler.setTarget(lector.element)
	    
	    _scaler.scaleUp();
	    // _scaler.bind("mod+=", function() { _scaler.scaleUp();  return false;})
	    // _scaler.bind("mod+-", function() { _scaler.scaleDown();  return false;})
	    
	    lector.adopt(_scaler);
	    lector.scaler = _scaler;

	    if (lector.settings){
	      console.log("lector has settings! connecting scaler's value to scalercomp");
	      let scaleComp = lector.settings.find('!scale');
	      if (scaleComp) scaleComp.wireTo(lector.scaler);
	    }  

	  }


	  
	  return lector
	};

	/*global define:false */

	var mousetrap = createCommonjsModule$1(function (module) {
	/**
	 * Copyright 2012-2017 Craig Campbell
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * Mousetrap is a simple keyboard shortcut library for Javascript with
	 * no external dependencies
	 *
	 * @version 1.6.5
	 * @url craig.is/killing/mice
	 */
	(function(window, document, undefined$1) {

	    // Check if mousetrap is used inside browser, if not, return
	    if (!window) {
	        return;
	    }

	    /**
	     * mapping of special keycodes to their corresponding keys
	     *
	     * everything in this dictionary cannot use keypress events
	     * so it has to be here to map to the correct keycodes for
	     * keyup/keydown events
	     *
	     * @type {Object}
	     */
	    var _MAP = {
	        8: 'backspace',
	        9: 'tab',
	        13: 'enter',
	        16: 'shift',
	        17: 'ctrl',
	        18: 'alt',
	        20: 'capslock',
	        27: 'esc',
	        32: 'space',
	        33: 'pageup',
	        34: 'pagedown',
	        35: 'end',
	        36: 'home',
	        37: 'left',
	        38: 'up',
	        39: 'right',
	        40: 'down',
	        45: 'ins',
	        46: 'del',
	        91: 'meta',
	        93: 'meta',
	        224: 'meta'
	    };

	    /**
	     * mapping for special characters so they can support
	     *
	     * this dictionary is only used incase you want to bind a
	     * keyup or keydown event to one of these keys
	     *
	     * @type {Object}
	     */
	    var _KEYCODE_MAP = {
	        106: '*',
	        107: '+',
	        109: '-',
	        110: '.',
	        111 : '/',
	        186: ';',
	        187: '=',
	        188: ',',
	        189: '-',
	        190: '.',
	        191: '/',
	        192: '`',
	        219: '[',
	        220: '\\',
	        221: ']',
	        222: '\''
	    };

	    /**
	     * this is a mapping of keys that require shift on a US keypad
	     * back to the non shift equivelents
	     *
	     * this is so you can use keyup events with these keys
	     *
	     * note that this will only work reliably on US keyboards
	     *
	     * @type {Object}
	     */
	    var _SHIFT_MAP = {
	        '~': '`',
	        '!': '1',
	        '@': '2',
	        '#': '3',
	        '$': '4',
	        '%': '5',
	        '^': '6',
	        '&': '7',
	        '*': '8',
	        '(': '9',
	        ')': '0',
	        '_': '-',
	        '+': '=',
	        ':': ';',
	        '\"': '\'',
	        '<': ',',
	        '>': '.',
	        '?': '/',
	        '|': '\\'
	    };

	    /**
	     * this is a list of special strings you can use to map
	     * to modifier keys when you specify your keyboard shortcuts
	     *
	     * @type {Object}
	     */
	    var _SPECIAL_ALIASES = {
	        'option': 'alt',
	        'command': 'meta',
	        'return': 'enter',
	        'escape': 'esc',
	        'plus': '+',
	        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
	    };

	    /**
	     * variable to store the flipped version of _MAP from above
	     * needed to check if we should use keypress or not when no action
	     * is specified
	     *
	     * @type {Object|undefined}
	     */
	    var _REVERSE_MAP;

	    /**
	     * loop through the f keys, f1 to f19 and add them to the map
	     * programatically
	     */
	    for (var i = 1; i < 20; ++i) {
	        _MAP[111 + i] = 'f' + i;
	    }

	    /**
	     * loop through to map numbers on the numeric keypad
	     */
	    for (i = 0; i <= 9; ++i) {

	        // This needs to use a string cause otherwise since 0 is falsey
	        // mousetrap will never fire for numpad 0 pressed as part of a keydown
	        // event.
	        //
	        // @see https://github.com/ccampbell/mousetrap/pull/258
	        _MAP[i + 96] = i.toString();
	    }

	    /**
	     * cross browser add event method
	     *
	     * @param {Element|HTMLDocument} object
	     * @param {string} type
	     * @param {Function} callback
	     * @returns void
	     */
	    function _addEvent(object, type, callback) {
	        if (object.addEventListener) {
	            object.addEventListener(type, callback, false);
	            return;
	        }

	        object.attachEvent('on' + type, callback);
	    }

	    /**
	     * takes the event and returns the key character
	     *
	     * @param {Event} e
	     * @return {string}
	     */
	    function _characterFromEvent(e) {

	        // for keypress events we should return the character as is
	        if (e.type == 'keypress') {
	            var character = String.fromCharCode(e.which);

	            // if the shift key is not pressed then it is safe to assume
	            // that we want the character to be lowercase.  this means if
	            // you accidentally have caps lock on then your key bindings
	            // will continue to work
	            //
	            // the only side effect that might not be desired is if you
	            // bind something like 'A' cause you want to trigger an
	            // event when capital A is pressed caps lock will no longer
	            // trigger the event.  shift+a will though.
	            if (!e.shiftKey) {
	                character = character.toLowerCase();
	            }

	            return character;
	        }

	        // for non keypress events the special maps are needed
	        if (_MAP[e.which]) {
	            return _MAP[e.which];
	        }

	        if (_KEYCODE_MAP[e.which]) {
	            return _KEYCODE_MAP[e.which];
	        }

	        // if it is not in the special map

	        // with keydown and keyup events the character seems to always
	        // come in as an uppercase character whether you are pressing shift
	        // or not.  we should make sure it is always lowercase for comparisons
	        return String.fromCharCode(e.which).toLowerCase();
	    }

	    /**
	     * checks if two arrays are equal
	     *
	     * @param {Array} modifiers1
	     * @param {Array} modifiers2
	     * @returns {boolean}
	     */
	    function _modifiersMatch(modifiers1, modifiers2) {
	        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
	    }

	    /**
	     * takes a key event and figures out what the modifiers are
	     *
	     * @param {Event} e
	     * @returns {Array}
	     */
	    function _eventModifiers(e) {
	        var modifiers = [];

	        if (e.shiftKey) {
	            modifiers.push('shift');
	        }

	        if (e.altKey) {
	            modifiers.push('alt');
	        }

	        if (e.ctrlKey) {
	            modifiers.push('ctrl');
	        }

	        if (e.metaKey) {
	            modifiers.push('meta');
	        }

	        return modifiers;
	    }

	    /**
	     * prevents default for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _preventDefault(e) {
	        if (e.preventDefault) {
	            e.preventDefault();
	            return;
	        }

	        e.returnValue = false;
	    }

	    /**
	     * stops propogation for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _stopPropagation(e) {
	        if (e.stopPropagation) {
	            e.stopPropagation();
	            return;
	        }

	        e.cancelBubble = true;
	    }

	    /**
	     * determines if the keycode specified is a modifier key or not
	     *
	     * @param {string} key
	     * @returns {boolean}
	     */
	    function _isModifier(key) {
	        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
	    }

	    /**
	     * reverses the map lookup so that we can look for specific keys
	     * to see what can and can't use keypress
	     *
	     * @return {Object}
	     */
	    function _getReverseMap() {
	        if (!_REVERSE_MAP) {
	            _REVERSE_MAP = {};
	            for (var key in _MAP) {

	                // pull out the numeric keypad from here cause keypress should
	                // be able to detect the keys from the character
	                if (key > 95 && key < 112) {
	                    continue;
	                }

	                if (_MAP.hasOwnProperty(key)) {
	                    _REVERSE_MAP[_MAP[key]] = key;
	                }
	            }
	        }
	        return _REVERSE_MAP;
	    }

	    /**
	     * picks the best action based on the key combination
	     *
	     * @param {string} key - character for key
	     * @param {Array} modifiers
	     * @param {string=} action passed in
	     */
	    function _pickBestAction(key, modifiers, action) {

	        // if no action was picked in we should try to pick the one
	        // that we think would work best for this key
	        if (!action) {
	            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
	        }

	        // modifier keys don't work as expected with keypress,
	        // switch to keydown
	        if (action == 'keypress' && modifiers.length) {
	            action = 'keydown';
	        }

	        return action;
	    }

	    /**
	     * Converts from a string key combination to an array
	     *
	     * @param  {string} combination like "command+shift+l"
	     * @return {Array}
	     */
	    function _keysFromString(combination) {
	        if (combination === '+') {
	            return ['+'];
	        }

	        combination = combination.replace(/\+{2}/g, '+plus');
	        return combination.split('+');
	    }

	    /**
	     * Gets info for a specific key combination
	     *
	     * @param  {string} combination key combination ("command+s" or "a" or "*")
	     * @param  {string=} action
	     * @returns {Object}
	     */
	    function _getKeyInfo(combination, action) {
	        var keys;
	        var key;
	        var i;
	        var modifiers = [];

	        // take the keys from this pattern and figure out what the actual
	        // pattern is all about
	        keys = _keysFromString(combination);

	        for (i = 0; i < keys.length; ++i) {
	            key = keys[i];

	            // normalize key names
	            if (_SPECIAL_ALIASES[key]) {
	                key = _SPECIAL_ALIASES[key];
	            }

	            // if this is not a keypress event then we should
	            // be smart about using shift keys
	            // this will only work for US keyboards however
	            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
	                key = _SHIFT_MAP[key];
	                modifiers.push('shift');
	            }

	            // if this key is a modifier then add it to the list of modifiers
	            if (_isModifier(key)) {
	                modifiers.push(key);
	            }
	        }

	        // depending on what the key combination is
	        // we will try to pick the best event for it
	        action = _pickBestAction(key, modifiers, action);

	        return {
	            key: key,
	            modifiers: modifiers,
	            action: action
	        };
	    }

	    function _belongsTo(element, ancestor) {
	        if (element === null || element === document) {
	            return false;
	        }

	        if (element === ancestor) {
	            return true;
	        }

	        return _belongsTo(element.parentNode, ancestor);
	    }

	    function Mousetrap(targetElement) {
	        var self = this;

	        targetElement = targetElement || document;

	        if (!(self instanceof Mousetrap)) {
	            return new Mousetrap(targetElement);
	        }

	        /**
	         * element to attach key events to
	         *
	         * @type {Element}
	         */
	        self.target = targetElement;

	        /**
	         * a list of all the callbacks setup via Mousetrap.bind()
	         *
	         * @type {Object}
	         */
	        self._callbacks = {};

	        /**
	         * direct map of string combinations to callbacks used for trigger()
	         *
	         * @type {Object}
	         */
	        self._directMap = {};

	        /**
	         * keeps track of what level each sequence is at since multiple
	         * sequences can start out with the same sequence
	         *
	         * @type {Object}
	         */
	        var _sequenceLevels = {};

	        /**
	         * variable to store the setTimeout call
	         *
	         * @type {null|number}
	         */
	        var _resetTimer;

	        /**
	         * temporary state where we will ignore the next keyup
	         *
	         * @type {boolean|string}
	         */
	        var _ignoreNextKeyup = false;

	        /**
	         * temporary state where we will ignore the next keypress
	         *
	         * @type {boolean}
	         */
	        var _ignoreNextKeypress = false;

	        /**
	         * are we currently inside of a sequence?
	         * type of action ("keyup" or "keydown" or "keypress") or false
	         *
	         * @type {boolean|string}
	         */
	        var _nextExpectedAction = false;

	        /**
	         * resets all sequence counters except for the ones passed in
	         *
	         * @param {Object} doNotReset
	         * @returns void
	         */
	        function _resetSequences(doNotReset) {
	            doNotReset = doNotReset || {};

	            var activeSequences = false,
	                key;

	            for (key in _sequenceLevels) {
	                if (doNotReset[key]) {
	                    activeSequences = true;
	                    continue;
	                }
	                _sequenceLevels[key] = 0;
	            }

	            if (!activeSequences) {
	                _nextExpectedAction = false;
	            }
	        }

	        /**
	         * finds all callbacks that match based on the keycode, modifiers,
	         * and action
	         *
	         * @param {string} character
	         * @param {Array} modifiers
	         * @param {Event|Object} e
	         * @param {string=} sequenceName - name of the sequence we are looking for
	         * @param {string=} combination
	         * @param {number=} level
	         * @returns {Array}
	         */
	        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
	            var i;
	            var callback;
	            var matches = [];
	            var action = e.type;

	            // if there are no events related to this keycode
	            if (!self._callbacks[character]) {
	                return [];
	            }

	            // if a modifier key is coming up on its own we should allow it
	            if (action == 'keyup' && _isModifier(character)) {
	                modifiers = [character];
	            }

	            // loop through all callbacks for the key that was pressed
	            // and see if any of them match
	            for (i = 0; i < self._callbacks[character].length; ++i) {
	                callback = self._callbacks[character][i];

	                // if a sequence name is not specified, but this is a sequence at
	                // the wrong level then move onto the next match
	                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
	                    continue;
	                }

	                // if the action we are looking for doesn't match the action we got
	                // then we should keep going
	                if (action != callback.action) {
	                    continue;
	                }

	                // if this is a keypress event and the meta key and control key
	                // are not pressed that means that we need to only look at the
	                // character, otherwise check the modifiers as well
	                //
	                // chrome will not fire a keypress if meta or control is down
	                // safari will fire a keypress if meta or meta+shift is down
	                // firefox will fire a keypress if meta or control is down
	                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

	                    // when you bind a combination or sequence a second time it
	                    // should overwrite the first one.  if a sequenceName or
	                    // combination is specified in this call it does just that
	                    //
	                    // @todo make deleting its own method?
	                    var deleteCombo = !sequenceName && callback.combo == combination;
	                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
	                    if (deleteCombo || deleteSequence) {
	                        self._callbacks[character].splice(i, 1);
	                    }

	                    matches.push(callback);
	                }
	            }

	            return matches;
	        }

	        /**
	         * actually calls the callback function
	         *
	         * if your callback function returns false this will use the jquery
	         * convention - prevent default and stop propogation on the event
	         *
	         * @param {Function} callback
	         * @param {Event} e
	         * @returns void
	         */
	        function _fireCallback(callback, e, combo, sequence) {

	            // if this event should not happen stop here
	            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
	                return;
	            }

	            if (callback(e, combo) === false) {
	                _preventDefault(e);
	                _stopPropagation(e);
	            }
	        }

	        /**
	         * handles a character key event
	         *
	         * @param {string} character
	         * @param {Array} modifiers
	         * @param {Event} e
	         * @returns void
	         */
	        self._handleKey = function(character, modifiers, e) {
	            var callbacks = _getMatches(character, modifiers, e);
	            var i;
	            var doNotReset = {};
	            var maxLevel = 0;
	            var processedSequenceCallback = false;

	            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
	            for (i = 0; i < callbacks.length; ++i) {
	                if (callbacks[i].seq) {
	                    maxLevel = Math.max(maxLevel, callbacks[i].level);
	                }
	            }

	            // loop through matching callbacks for this key event
	            for (i = 0; i < callbacks.length; ++i) {

	                // fire for all sequence callbacks
	                // this is because if for example you have multiple sequences
	                // bound such as "g i" and "g t" they both need to fire the
	                // callback for matching g cause otherwise you can only ever
	                // match the first one
	                if (callbacks[i].seq) {

	                    // only fire callbacks for the maxLevel to prevent
	                    // subsequences from also firing
	                    //
	                    // for example 'a option b' should not cause 'option b' to fire
	                    // even though 'option b' is part of the other sequence
	                    //
	                    // any sequences that do not match here will be discarded
	                    // below by the _resetSequences call
	                    if (callbacks[i].level != maxLevel) {
	                        continue;
	                    }

	                    processedSequenceCallback = true;

	                    // keep a list of which sequences were matches for later
	                    doNotReset[callbacks[i].seq] = 1;
	                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
	                    continue;
	                }

	                // if there were no sequence matches but we are still here
	                // that means this is a regular match so we should fire that
	                if (!processedSequenceCallback) {
	                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
	                }
	            }

	            // if the key you pressed matches the type of sequence without
	            // being a modifier (ie "keyup" or "keypress") then we should
	            // reset all sequences that were not matched by this event
	            //
	            // this is so, for example, if you have the sequence "h a t" and you
	            // type "h e a r t" it does not match.  in this case the "e" will
	            // cause the sequence to reset
	            //
	            // modifier keys are ignored because you can have a sequence
	            // that contains modifiers such as "enter ctrl+space" and in most
	            // cases the modifier key will be pressed before the next key
	            //
	            // also if you have a sequence such as "ctrl+b a" then pressing the
	            // "b" key will trigger a "keypress" and a "keydown"
	            //
	            // the "keydown" is expected when there is a modifier, but the
	            // "keypress" ends up matching the _nextExpectedAction since it occurs
	            // after and that causes the sequence to reset
	            //
	            // we ignore keypresses in a sequence that directly follow a keydown
	            // for the same character
	            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
	            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
	                _resetSequences(doNotReset);
	            }

	            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
	        };

	        /**
	         * handles a keydown event
	         *
	         * @param {Event} e
	         * @returns void
	         */
	        function _handleKeyEvent(e) {

	            // normalize e.which for key events
	            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
	            if (typeof e.which !== 'number') {
	                e.which = e.keyCode;
	            }

	            var character = _characterFromEvent(e);

	            // no character found then stop
	            if (!character) {
	                return;
	            }

	            // need to use === for the character check because the character can be 0
	            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
	                _ignoreNextKeyup = false;
	                return;
	            }

	            self.handleKey(character, _eventModifiers(e), e);
	        }

	        /**
	         * called to set a 1 second timeout on the specified sequence
	         *
	         * this is so after each key press in the sequence you have 1 second
	         * to press the next key before you have to start over
	         *
	         * @returns void
	         */
	        function _resetSequenceTimer() {
	            clearTimeout(_resetTimer);
	            _resetTimer = setTimeout(_resetSequences, 1000);
	        }

	        /**
	         * binds a key sequence to an event
	         *
	         * @param {string} combo - combo specified in bind call
	         * @param {Array} keys
	         * @param {Function} callback
	         * @param {string=} action
	         * @returns void
	         */
	        function _bindSequence(combo, keys, callback, action) {

	            // start off by adding a sequence level record for this combination
	            // and setting the level to 0
	            _sequenceLevels[combo] = 0;

	            /**
	             * callback to increase the sequence level for this sequence and reset
	             * all other sequences that were active
	             *
	             * @param {string} nextAction
	             * @returns {Function}
	             */
	            function _increaseSequence(nextAction) {
	                return function() {
	                    _nextExpectedAction = nextAction;
	                    ++_sequenceLevels[combo];
	                    _resetSequenceTimer();
	                };
	            }

	            /**
	             * wraps the specified callback inside of another function in order
	             * to reset all sequence counters as soon as this sequence is done
	             *
	             * @param {Event} e
	             * @returns void
	             */
	            function _callbackAndReset(e) {
	                _fireCallback(callback, e, combo);

	                // we should ignore the next key up if the action is key down
	                // or keypress.  this is so if you finish a sequence and
	                // release the key the final key will not trigger a keyup
	                if (action !== 'keyup') {
	                    _ignoreNextKeyup = _characterFromEvent(e);
	                }

	                // weird race condition if a sequence ends with the key
	                // another sequence begins with
	                setTimeout(_resetSequences, 10);
	            }

	            // loop through keys one at a time and bind the appropriate callback
	            // function.  for any key leading up to the final one it should
	            // increase the sequence. after the final, it should reset all sequences
	            //
	            // if an action is specified in the original bind call then that will
	            // be used throughout.  otherwise we will pass the action that the
	            // next key in the sequence should match.  this allows a sequence
	            // to mix and match keypress and keydown events depending on which
	            // ones are better suited to the key provided
	            for (var i = 0; i < keys.length; ++i) {
	                var isFinal = i + 1 === keys.length;
	                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
	                _bindSingle(keys[i], wrappedCallback, action, combo, i);
	            }
	        }

	        /**
	         * binds a single keyboard combination
	         *
	         * @param {string} combination
	         * @param {Function} callback
	         * @param {string=} action
	         * @param {string=} sequenceName - name of sequence if part of sequence
	         * @param {number=} level - what part of the sequence the command is
	         * @returns void
	         */
	        function _bindSingle(combination, callback, action, sequenceName, level) {

	            // store a direct mapped reference for use with Mousetrap.trigger
	            self._directMap[combination + ':' + action] = callback;

	            // make sure multiple spaces in a row become a single space
	            combination = combination.replace(/\s+/g, ' ');

	            var sequence = combination.split(' ');
	            var info;

	            // if this pattern is a sequence of keys then run through this method
	            // to reprocess each pattern one key at a time
	            if (sequence.length > 1) {
	                _bindSequence(combination, sequence, callback, action);
	                return;
	            }

	            info = _getKeyInfo(combination, action);

	            // make sure to initialize array if this is the first time
	            // a callback is added for this key
	            self._callbacks[info.key] = self._callbacks[info.key] || [];

	            // remove an existing match if there is one
	            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

	            // add this call back to the array
	            // if it is a sequence put it at the beginning
	            // if not put it at the end
	            //
	            // this is important because the way these are processed expects
	            // the sequence ones to come first
	            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
	                callback: callback,
	                modifiers: info.modifiers,
	                action: info.action,
	                seq: sequenceName,
	                level: level,
	                combo: combination
	            });
	        }

	        /**
	         * binds multiple combinations to the same callback
	         *
	         * @param {Array} combinations
	         * @param {Function} callback
	         * @param {string|undefined} action
	         * @returns void
	         */
	        self._bindMultiple = function(combinations, callback, action) {
	            for (var i = 0; i < combinations.length; ++i) {
	                _bindSingle(combinations[i], callback, action);
	            }
	        };

	        // start!
	        _addEvent(targetElement, 'keypress', _handleKeyEvent);
	        _addEvent(targetElement, 'keydown', _handleKeyEvent);
	        _addEvent(targetElement, 'keyup', _handleKeyEvent);
	    }

	    /**
	     * binds an event to mousetrap
	     *
	     * can be a single key, a combination of keys separated with +,
	     * an array of keys, or a sequence of keys separated by spaces
	     *
	     * be sure to list the modifier keys first to make sure that the
	     * correct key ends up getting bound (the last key in the pattern)
	     *
	     * @param {string|Array} keys
	     * @param {Function} callback
	     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
	     * @returns void
	     */
	    Mousetrap.prototype.bind = function(keys, callback, action) {
	        var self = this;
	        keys = keys instanceof Array ? keys : [keys];
	        self._bindMultiple.call(self, keys, callback, action);
	        return self;
	    };

	    /**
	     * unbinds an event to mousetrap
	     *
	     * the unbinding sets the callback function of the specified key combo
	     * to an empty function and deletes the corresponding key in the
	     * _directMap dict.
	     *
	     * TODO: actually remove this from the _callbacks dictionary instead
	     * of binding an empty function
	     *
	     * the keycombo+action has to be exactly the same as
	     * it was defined in the bind method
	     *
	     * @param {string|Array} keys
	     * @param {string} action
	     * @returns void
	     */
	    Mousetrap.prototype.unbind = function(keys, action) {
	        var self = this;
	        return self.bind.call(self, keys, function() {}, action);
	    };

	    /**
	     * triggers an event that has already been bound
	     *
	     * @param {string} keys
	     * @param {string=} action
	     * @returns void
	     */
	    Mousetrap.prototype.trigger = function(keys, action) {
	        var self = this;
	        if (self._directMap[keys + ':' + action]) {
	            self._directMap[keys + ':' + action]({}, keys);
	        }
	        return self;
	    };

	    /**
	     * resets the library back to its initial state.  this is useful
	     * if you want to clear out the current keyboard shortcuts and bind
	     * new ones - for example if you switch to another page
	     *
	     * @returns void
	     */
	    Mousetrap.prototype.reset = function() {
	        var self = this;
	        self._callbacks = {};
	        self._directMap = {};
	        return self;
	    };

	    /**
	     * should we stop this event before firing off callbacks
	     *
	     * @param {Event} e
	     * @param {Element} element
	     * @return {boolean}
	     */
	    Mousetrap.prototype.stopCallback = function(e, element) {
	        var self = this;

	        // if the element has the class "mousetrap" then no need to stop
	        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
	            return false;
	        }

	        if (_belongsTo(element, self.target)) {
	            return false;
	        }

	        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
	        // not the initial event target in the shadow tree. Note that not all events cross the
	        // shadow boundary.
	        // For shadow trees with `mode: 'open'`, the initial event target is the first element in
	        // the events composed path. For shadow trees with `mode: 'closed'`, the initial event
	        // target cannot be obtained.
	        if ('composedPath' in e && typeof e.composedPath === 'function') {
	            // For open shadow trees, update `element` so that the following check works.
	            var initialEventTarget = e.composedPath()[0];
	            if (initialEventTarget !== e.target) {
	                element = initialEventTarget;
	            }
	        }

	        // stop for input, select, and textarea
	        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
	    };

	    /**
	     * exposes _handleKey publicly so it can be overwritten by extensions
	     */
	    Mousetrap.prototype.handleKey = function() {
	        var self = this;
	        return self._handleKey.apply(self, arguments);
	    };

	    /**
	     * allow custom key mappings
	     */
	    Mousetrap.addKeycodes = function(object) {
	        for (var key in object) {
	            if (object.hasOwnProperty(key)) {
	                _MAP[key] = object[key];
	            }
	        }
	        _REVERSE_MAP = null;
	    };

	    /**
	     * Init the global mousetrap functions
	     *
	     * This method is needed to allow the global mousetrap functions to work
	     * now that mousetrap is a constructor function.
	     */
	    Mousetrap.init = function() {
	        var documentMousetrap = Mousetrap(document);
	        for (var method in documentMousetrap) {
	            if (method.charAt(0) !== '_') {
	                Mousetrap[method] = (function(method) {
	                    return function() {
	                        return documentMousetrap[method].apply(documentMousetrap, arguments);
	                    };
	                } (method));
	            }
	        }
	    };

	    Mousetrap.init();

	    // expose mousetrap to the global object
	    window.Mousetrap = Mousetrap;

	    // expose as a common js module
	    if (module.exports) {
	        module.exports = Mousetrap;
	    }

	    // expose mousetrap as an AMD module
	    if (typeof undefined$1 === 'function' && undefined$1.amd) {
	        undefined$1(function() {
	            return Mousetrap;
	        });
	    }
	}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);
	});

	/* Copyright 2012 Mozilla Foundation
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	let renderTextLayer = pdf.renderTextLayer;
	const EXPAND_DIVS_TIMEOUT = 300; // ms

	/**
	 * @typedef {Object} TextLayerBuilderOptions
	 * @property {HTMLDivElement} textLayerDiv - The text layer container.
	 * @property {EventBus} eventBus - The application event bus.
	 * @property {number} pageIndex - The page index.
	 * @property {PageViewport} viewport - The viewport of the text layer.
	 * @property {PDFFindController} findController
	 * @property {boolean} enhanceTextSelection - Option to turn on improved
	 *   text selection.
	 */

	/**
	 * The text layer builder provides text selection functionality for the PDF.
	 * It does this by creating overlay divs over the PDF's text. These divs
	 * contain text that matches the PDF text they are overlaying. This object
	 * also provides a way to highlight text that is being searched for.
	 */
	class TextLayerBuilder {
	  constructor({
	    textLayerDiv,
	    eventBus,
	    pageIndex,
	    viewport,
	    findController = null,
	    enhanceTextSelection = false,
	  }) {
	    this.textLayerDiv = textLayerDiv;
	    this.eventBus = eventBus;
	    this.textContent = null;
	    this.textContentItemsStr = [];
	    this.textContentStream = null;
	    this.renderingDone = false;
	    this.pageIdx = pageIndex;
	    this.pageNumber = this.pageIdx + 1;
	    this.matches = [];
	    this.viewport = viewport;
	    this.textDivs = [];
	    this.findController = findController;
	    this.textLayerRenderTask = null;
	    this.enhanceTextSelection = enhanceTextSelection;

	    this._onUpdateTextLayerMatches = null;
	    this._bindMouse();
	  }

	  /**
	   * @private
	   */
	  _finishRendering() {
	    this.renderingDone = true;

	    if (!this.enhanceTextSelection) {
	      const endOfContent = document.createElement("div");
	      endOfContent.className = "endOfContent";
	      this.textLayerDiv.appendChild(endOfContent);
	    }

	    this.eventBus.dispatch("textlayerrendered", {
	      source: this,
	      pageNumber: this.pageNumber,
	      numTextDivs: this.textDivs.length,
	    });
	  }

	  /**
	   * Renders the text layer.
	   *
	   * @param {number} [timeout] - Wait for a specified amount of milliseconds
	   *                             before rendering.
	   */
	  render(timeout = 0) {
	    if (!(this.textContent || this.textContentStream) || this.renderingDone) {
	      return;
	    }
	    this.cancel();

	    this.textDivs = [];
	    const textLayerFrag = document.createDocumentFragment();
	    this.textLayerRenderTask = renderTextLayer({
	      textContent: this.textContent,
	      textContentStream: this.textContentStream,
	      container: textLayerFrag,
	      viewport: this.viewport,
	      textDivs: this.textDivs,
	      textContentItemsStr: this.textContentItemsStr,
	      timeout,
	      enhanceTextSelection: this.enhanceTextSelection,
	    });
	    this.textLayerRenderTask.promise.then(
	      () => {
	        this.textLayerDiv.appendChild(textLayerFrag);
	        this._finishRendering();
	        this._updateMatches();
	      },
	      function (reason) {
	        // Cancelled or failed to render text layer; skipping errors.
	      }
	    );

	    if (!this._onUpdateTextLayerMatches) {
	      this._onUpdateTextLayerMatches = evt => {
	        if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
	          this._updateMatches();
	        }
	      };
	      this.eventBus._on(
	        "updatetextlayermatches",
	        this._onUpdateTextLayerMatches
	      );
	    }
	  }

	  /**
	   * Cancel rendering of the text layer.
	   */
	  cancel() {
	    if (this.textLayerRenderTask) {
	      this.textLayerRenderTask.cancel();
	      this.textLayerRenderTask = null;
	    }
	    if (this._onUpdateTextLayerMatches) {
	      this.eventBus._off(
	        "updatetextlayermatches",
	        this._onUpdateTextLayerMatches
	      );
	      this._onUpdateTextLayerMatches = null;
	    }
	  }

	  setTextContentStream(readableStream) {
	    this.cancel();
	    this.textContentStream = readableStream;
	  }

	  setTextContent(textContent) {
	    this.cancel();
	    this.textContent = textContent;
	  }

	  _convertMatches(matches, matchesLength) {
	    // Early exit if there is nothing to convert.
	    if (!matches) {
	      return [];
	    }
	    const { textContentItemsStr } = this;

	    let i = 0,
	      iIndex = 0;
	    const end = textContentItemsStr.length - 1;
	    const result = [];

	    for (let m = 0, mm = matches.length; m < mm; m++) {
	      // Calculate the start position.
	      let matchIdx = matches[m];

	      // Loop over the divIdxs.
	      while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
	        iIndex += textContentItemsStr[i].length;
	        i++;
	      }

	      if (i === textContentItemsStr.length) {
	        console.error("Could not find a matching mapping");
	      }

	      const match = {
	        begin: {
	          divIdx: i,
	          offset: matchIdx - iIndex,
	        },
	      };

	      // Calculate the end position.
	      matchIdx += matchesLength[m];

	      // Somewhat the same array as above, but use > instead of >= to get
	      // the end position right.
	      while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
	        iIndex += textContentItemsStr[i].length;
	        i++;
	      }

	      match.end = {
	        divIdx: i,
	        offset: matchIdx - iIndex,
	      };
	      result.push(match);
	    }
	    return result;
	  }

	  _renderMatches(matches) {
	    // Early exit if there is nothing to render.
	    if (matches.length === 0) {
	      return;
	    }
	    const { findController, pageIdx, textContentItemsStr, textDivs } = this;

	    const isSelectedPage = pageIdx === findController.selected.pageIdx;
	    const selectedMatchIdx = findController.selected.matchIdx;
	    const highlightAll = findController.state.highlightAll;
	    let prevEnd = null;
	    const infinity = {
	      divIdx: -1,
	      offset: undefined,
	    };

	    function beginText(begin, className) {
	      const divIdx = begin.divIdx;
	      textDivs[divIdx].textContent = "";
	      appendTextToDiv(divIdx, 0, begin.offset, className);
	    }

	    function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
	      const div = textDivs[divIdx];
	      const content = textContentItemsStr[divIdx].substring(
	        fromOffset,
	        toOffset
	      );
	      const node = document.createTextNode(content);
	      if (className) {
	        const span = document.createElement("span");
	        span.className = className;
	        span.appendChild(node);
	        div.appendChild(span);
	        return;
	      }
	      div.appendChild(node);
	    }

	    let i0 = selectedMatchIdx,
	      i1 = i0 + 1;
	    if (highlightAll) {
	      i0 = 0;
	      i1 = matches.length;
	    } else if (!isSelectedPage) {
	      // Not highlighting all and this isn't the selected page, so do nothing.
	      return;
	    }

	    for (let i = i0; i < i1; i++) {
	      const match = matches[i];
	      const begin = match.begin;
	      const end = match.end;
	      const isSelected = isSelectedPage && i === selectedMatchIdx;
	      const highlightSuffix = isSelected ? " selected" : "";

	      if (isSelected) {
	        // Attempt to scroll the selected match into view.
	        findController.scrollMatchIntoView({
	          element: textDivs[begin.divIdx],
	          pageIndex: pageIdx,
	          matchIndex: selectedMatchIdx,
	        });
	      }

	      // Match inside new div.
	      if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
	        // If there was a previous div, then add the text at the end.
	        if (prevEnd !== null) {
	          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
	        }
	        // Clear the divs and set the content until the starting point.
	        beginText(begin);
	      } else {
	        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
	      }

	      if (begin.divIdx === end.divIdx) {
	        appendTextToDiv(
	          begin.divIdx,
	          begin.offset,
	          end.offset,
	          "highlight" + highlightSuffix
	        );
	      } else {
	        appendTextToDiv(
	          begin.divIdx,
	          begin.offset,
	          infinity.offset,
	          "highlight begin" + highlightSuffix
	        );
	        for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
	          textDivs[n0].className = "highlight middle" + highlightSuffix;
	        }
	        beginText(end, "highlight end" + highlightSuffix);
	      }
	      prevEnd = end;
	    }

	    if (prevEnd) {
	      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
	    }
	  }

	  _updateMatches() {
	    // Only show matches when all rendering is done.
	    if (!this.renderingDone) {
	      return;
	    }
	    const {
	      findController,
	      matches,
	      pageIdx,
	      textContentItemsStr,
	      textDivs,
	    } = this;
	    let clearedUntilDivIdx = -1;

	    // Clear all current matches.
	    for (let i = 0, ii = matches.length; i < ii; i++) {
	      const match = matches[i];
	      const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
	      for (let n = begin, end = match.end.divIdx; n <= end; n++) {
	        const div = textDivs[n];
	        div.textContent = textContentItemsStr[n];
	        div.className = "";
	      }
	      clearedUntilDivIdx = match.end.divIdx + 1;
	    }

	    if (!findController?.highlightMatches) {
	      return;
	    }
	    // Convert the matches on the `findController` into the match format
	    // used for the textLayer.
	    const pageMatches = findController.pageMatches[pageIdx] || null;
	    const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;

	    this.matches = this._convertMatches(pageMatches, pageMatchesLength);
	    this._renderMatches(this.matches);
	  }

	  /**
	   * Improves text selection by adding an additional div where the mouse was
	   * clicked. This reduces flickering of the content if the mouse is slowly
	   * dragged up or down.
	   *
	   * @private
	   */
	  _bindMouse() {
	    const div = this.textLayerDiv;
	    let expandDivsTimer = null;

	    div.addEventListener("mousedown", evt => {
	      if (this.enhanceTextSelection && this.textLayerRenderTask) {
	        this.textLayerRenderTask.expandTextDivs(true);
	        if (
	          (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
	          expandDivsTimer
	        ) {
	          clearTimeout(expandDivsTimer);
	          expandDivsTimer = null;
	        }
	        return;
	      }

	      const end = div.querySelector(".endOfContent");
	      if (!end) {
	        return;
	      }
	      if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
	        // On non-Firefox browsers, the selection will feel better if the height
	        // of the `endOfContent` div is adjusted to start at mouse click
	        // location. This avoids flickering when the selection moves up.
	        // However it does not work when selection is started on empty space.
	        let adjustTop = evt.target !== div;
	        if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
	          adjustTop =
	            adjustTop &&
	            window
	              .getComputedStyle(end)
	              .getPropertyValue("-moz-user-select") !== "none";
	        }
	        if (adjustTop) {
	          const divBounds = div.getBoundingClientRect();
	          const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
	          end.style.top = (r * 100).toFixed(2) + "%";
	        }
	      }
	      end.classList.add("active");
	    });

	    div.addEventListener("mouseup", () => {
	      if (this.enhanceTextSelection && this.textLayerRenderTask) {
	        if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
	          expandDivsTimer = setTimeout(() => {
	            if (this.textLayerRenderTask) {
	              this.textLayerRenderTask.expandTextDivs(false);
	            }
	            expandDivsTimer = null;
	          }, EXPAND_DIVS_TIMEOUT);
	        } else {
	          this.textLayerRenderTask.expandTextDivs(false);
	        }
	        return;
	      }

	      const end = div.querySelector(".endOfContent");
	      if (!end) {
	        return;
	      }
	      if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
	        end.style.top = "";
	      }
	      end.classList.remove("active");
	    });
	  }
	}

	function yoing(){
	    console.log('yoing');
	    console.log(pdf$2);
	}
	yoing();

	var url = 'https://raw.githubusercontent.com/mozilla/pdf.js/ba2edeae/web/compressed.tracemonkey-pldi-09.pdf';

	// Loaded via <script> tag, create shortcut to access PDF.js exports.

	// The workerSrc property shall be specified.
	pdf.GlobalWorkerOptions.workerSrc = '/src/pdfjs/build/pdf.worker.js';

	pdf.getDocument(url).promise
	  .then(function(pdf) {

	    // Get div#container and cache it for later use
	    var container = document.getElementById("the-canvas");

	    // Loop from 1 to total_number_of_pages in PDF document
	    for (var i = 1; i <= pdf.numPages; i++) {

	        // Get desired page
	        pdf.getPage(i).then(function(page) {

	          var scale = 1.5;
	          var viewport = page.getViewport({scale :scale});
	          var div = document.createElement("div");

	          // Set id attribute with page-#{pdf_page_number} format
	          div.setAttribute("id", "page-" + (page.pageIndex + 1));

	          // This will keep positions of child elements as per our needs
	          div.setAttribute("style", "position: relative");

	          // Append div within div#container
	          container.appendChild(div);

	          // Create a new Canvas element
	          var canvas = document.createElement("canvas");

	          // Append Canvas within div#page-#{pdf_page_number}
	          div.appendChild(canvas);

	          var context = canvas.getContext('2d');
	          canvas.height = viewport.height;
	          canvas.width = viewport.width;

	          var renderContext = {
	            canvasContext: context,
	            viewport: viewport
	          };

	          // Render PDF page
	            page.render(renderContext).promise.then(function () {
	                // Get text-fragments
	                return page.getTextContent();
	            })
	                .then(function (textContent) {
	                    // Create div which will hold text-fragments
	                    var textLayerDiv = document.createElement("div");

	                    // Set it's class to textLayer which have required CSS styles
	                    textLayerDiv.setAttribute("class", "textLayer");

	                    // Append newly created div in `div#page-#{pdf_page_number}`
	                    div.appendChild(textLayerDiv);

	                    // Create new instance of TextLayerBuilder class
	                    var textLayer = new TextLayerBuilder({
	                        textLayerDiv: textLayerDiv,
	                        pageIndex: page.pageIndex,
	                        viewport: viewport
	                    });

	                    // Set text-fragments
	                    textLayer.setTextContent(textContent);

	                    // Render text-fragments
	                    textLayer.render();
	                });        });
	    }
	});



	function wfyInner(desc) {
	    if (!desc) return false
	    desc = j(desc);
	    let txt = desc.textContent;
	    if (txt.length === 0) return false

	    let inner = "";
	    for (let txt of desc.textContent.split(" ")) {
	        // console.log(txt)
	        let noWhiteSpace = txt.replace(/\s/g, "");
	        inner += noWhiteSpace.length != 0 ? "<w>" + txt.split(" ").join("</w> <w>") + "</w> " : txt;
	    }

	    desc.html(inner);
	}

	function wfyElement(element) {
	    element = j(element);
	    let nodes = element.findAll("*");
	    if (nodes.length == 0) return wfyInner(element)
	    nodes.forEach(desc => wfyElement(desc));
	}

	//export function wfy(element) {
	    //// console.log(`wfying ${JSON.stringify(element)}`)
	    //element = _e(element)
	    //// if (element.textContent.replaceAll(" ", "").length<1) return false
	    //let txtNodes = element.findAll("*")
	    //if (txtNodes.length == 0) return wfyElement(element)
	    //// txtNodes.each((i, el) => {
	    ////   wfy(el)
	    //// })
	    //txtNodes.forEach(el => wfy(el))
	    //return true
	//}
	console.log(mousetrap);


	setTimeout(() => {
	    console.log('new lector');
	    j('body').findAll('.textLayer').forEach(textLayer => wfyElement(textLayer));
	    
	    let lector = Lector("#the-canvas", {
	        wfy: false,
	        settings: true,
	        defaultStyles: true,
	        fullStyles: true
	    });
	    

	    mousetrap.bind('space', () => {
	        lector.toggle();
	        return false
	    });
	}, 2000);



	//var pdfDoc = null,
	    //pageNum = 1,
	    //pageRendering = false,
	    //pageNumPending = null,
	    //scale = 2,
	    //canvas = document.getElementById('the-canvas'),
	    //ctx = canvas.getContext('2d');

	/**
	 * Get page info from document, resize canvas accordingly, and render page.
	 * @param num Page number.
	 */
	//function renderPage(num) {
	  //pageRendering = true;
	  //// Using promise to fetch the page
	  //pdfDoc.getPage(num).then(function(page) {
	    //var viewport = page.getViewport({scale: scale});
	    //canvas.height = viewport.height;
	    //canvas.width = viewport.width;

	    //// Render PDF page into canvas context
	    //var renderContext = {
	      //canvasContext: ctx,
	      //viewport: viewport
	    //};

	    //var renderTask = page.render(renderContext);

	    //// Wait for rendering to finish
	    //renderTask.promise.then(function() {
	      //pageRendering = false;
	      //if (pageNumPending !== null) {
	        //// New page rendering is pending
	        //renderPage(pageNumPending);
	        //pageNumPending = null;
	      //}
	    //}).then(function () {
	        //// Get text-fragments
	        //return page.getTextContent();
	    //})
	        //.then(function (textContent) {
	            //console.log(textContent)
	            //// Create div which will hold text-fragments
	            //var textLayerDiv = document.createElement("div");

	            //// Set it's class to textLayer which have required CSS styles
	            //textLayerDiv.setAttribute("class", "textLayer");

	            //// Append newly created div in `div#page-#{pdf_page_number}`
	            //div.appendChild(textLayerDiv);

	            //// Create new instance of TextLayerBuilder class
	            //var textLayer = new TextLayerBuilder({
	                //textLayerDiv: textLayerDiv,
	                //pageIndex: page.pageIndex,
	                //viewport: viewport
	            //});

	            //// Set text-fragments
	            //textLayer.setTextContent(textContent);

	            //// Render text-fragments
	            //textLayer.render();
	        //});;
	  //});

	  //// Update page counters
	  //document.getElementById('page_num').textContent = num;
	//}

	/**
	 * If another page rendering in progress, waits until the rendering is
	 * finised. Otherwise, executes rendering immediately.
	 */
	//function queueRenderPage(num) {
	  //if (pageRendering) {
	    //pageNumPending = num;
	  //} else {
	    //renderPage(num);
	  //}
	//}

	/**
	 * Displays previous page.
	 */
	//function onPrevPage() {
	  //if (pageNum <= 1) {
	    //return;
	  //}
	  //pageNum--;
	  //queueRenderPage(pageNum);
	//}
	//document.getElementById('prev').addEventListener('click', onPrevPage);

	/**
	 * Displays next page.
	 */
	//function onNextPage() {
	  //if (pageNum >= pdfDoc.numPages) {
	    //return;
	  //}
	  //pageNum++;
	  //queueRenderPage(pageNum);
	//}
	//document.getElementById('next').addEventListener('click', onNextPage);

	/**
	 * Asynchronously downloads PDF.
	 */
	//pdf.getDocument(url).promise.then(function(pdfDoc_) {
	  //pdfDoc = pdfDoc_;
	  //document.getElementById('page_count').textContent = pdfDoc.numPages;

	  //// Initial/first page rendering
	  //renderPage(pageNum);
	//});

	exports.yoing = yoing;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
